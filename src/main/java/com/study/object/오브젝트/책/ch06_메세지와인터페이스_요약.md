# Chapter 06. 메시지와 인터페이스

> 객체의 품격은 퍼블릭 인터페이스에서 결정된다

---

## 협력과 메시지

### 핵심 용어 정리

```
┌─────────────────────────────────────────────────────────┐
│  메시지 = 오퍼레이션명 + 인자                             │
│  메시지 전송 = 메시지 + 수신자                            │
├─────────────────────────────────────────────────────────┤
│  오퍼레이션 = 퍼블릭 인터페이스의 메시지 (시그니처만)        │
│  메서드 = 메시지 수신 시 실제 실행되는 코드                 │
│  시그니처 = 오퍼레이션 이름 + 파라미터 목록                 │
└─────────────────────────────────────────────────────────┘
```

### 메시지와 메서드의 분리

```
메시지 ──────────────────────────── 메서드
        (런타임에 바인딩)

→ 송신자와 수신자가 느슨하게 결합
→ 유연하고 확장 가능한 코드
```

### 다형성의 정의
> 동일한 오퍼레이션 호출에 대해 **서로 다른 메서드**들이 실행되는 것

---

## 인터페이스와 설계 품질

### 좋은 인터페이스의 조건

| 조건 | 설명 |
|------|------|
| 최소한의 인터페이스 | 꼭 필요한 오퍼레이션만 포함 |
| 추상적인 인터페이스 | "어떻게"가 아닌 "무엇을" 표현 |

**달성 방법**: 메시지가 객체를 선택하게 하라 (책임 주도 설계)

---

## 디미터 법칙 (Law of Demeter)

### 핵심 원칙

```
"낯선 자에게 말하지 말라"
"오직 인접한 이웃하고만 말하라"
```

### 메시지를 보낼 수 있는 대상 (5가지만!)

```java
public class SomeClass {
    private Neighbor neighbor;  // 3. this의 속성

    public void method(Parameter param) {  // 2. 매개변수
        // 1. this 객체
        this.doSomething();

        // 2. 메서드의 매개변수
        param.doSomething();

        // 3. this의 속성
        neighbor.doSomething();

        // 4. this 속성인 컬렉션의 요소
        neighbors.get(0).doSomething();

        // 5. 메서드 내에서 생성된 지역 객체
        Local local = new Local();
        local.doSomething();
    }
}
```

### 기차 충돌 (Train Wreck)

```java
// 나쁜 예: 내부 구조 노출
screening.getMovie().getDiscountConditions().get(0).isSatisfied();

// 좋은 예: 메시지로 요청
screening.calculateFee(audienceCount);
```

### 부끄럼 타는 코드 (Shy Code)
- 불필요한 것을 다른 객체에게 보여주지 않음
- 다른 객체의 구현에 의존하지 않음
- **결과**: 낮은 결합도 유지

---

## 묻지 말고 시켜라 (Tell, Don't Ask)

### 원칙

```
상태를 묻지 말고, 행동을 요청하라
```

### 비교

```java
// 나쁜 예: 상태를 묻고 직접 처리
if (member.getGrade() == Grade.VIP) {
    // 할인 로직...
}

// 좋은 예: 행동을 요청
member.applyDiscount(price);
```

### 효과
- 정보와 행동이 함께 있는 객체
- 함께 변경될 확률이 높은 것들이 하나의 단위로 통합

---

## 의도를 드러내는 인터페이스

### 메서드 명명의 두 가지 방법

| 방법 | 예시 | 평가 |
|------|------|------|
| 어떻게 (구현) | `calculateByPercent()` | X |
| 무엇을 (의도) | `calculateFee()` | O |

### 의도를 드러내는 선택자 (Intention Revealing Selector)

**팁**: "매우 다른 두 번째 구현을 상상하고, 동일한 이름을 붙여보라"
→ 가장 추상적인 이름을 찾게 됨

```java
// 구현을 드러내는 이름 (나쁨)
public Money calculatePercentDiscountedFee() { }
public Money calculateAmountDiscountedFee() { }

// 의도를 드러내는 이름 (좋음)
public Money calculateDiscountedFee() { }
```

---

## 명령-쿼리 분리 원칙 (CQS)

### 정의

| 구분 | 명령 (Command) | 쿼리 (Query) |
|------|----------------|--------------|
| 역할 | 상태를 수정 | 정보를 반환 |
| 부수효과 | 있음 | 없음 |
| 반환값 | 없음 (void) | 있음 |

### 핵심 규칙

```
어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다
```

### 예시

```java
// 나쁜 예: 명령과 쿼리가 섞임
public Event createEvent(String name) {
    this.events.add(new Event(name));  // 명령
    return this.events.getLast();       // 쿼리
}

// 좋은 예: 분리
public void addEvent(String name) {     // 명령
    this.events.add(new Event(name));
}

public Event getLastEvent() {           // 쿼리
    return this.events.getLast();
}
```

### 참조 투명성 (Referential Transparency)
- 표현식을 그 값으로 바꿔도 결과가 동일
- **불변성** → 부수효과 방지 → 참조 투명성
- CQS를 따르면 제한적으로 참조 투명성 혜택을 누림

---

## 원칙의 함정

### 디미터 법칙 오해

```java
// 이것은 디미터 법칙 위반이 아닐 수 있다!
IntStream.of(1, 2, 3)
    .filter(x -> x > 1)
    .map(x -> x * 2)
    .sum();
```

**핵심**: 내부 구조가 외부로 노출되는가?
- 객체 → 디미터 법칙 적용 (내부 구조 숨겨야 함)
- 자료 구조 → 디미터 법칙 불필요 (내부 노출이 당연)

### 균형 잡기

```
원칙을 맹신하지 말라
적절한 상황과 부적절한 상황을 판단하는 안목을 길러라
```

> "소프트웨어 설계에서 유일한 법칙: **경우에 따라 다르다**"

---

## 책임에 초점을 맞춰라

### 메시지를 먼저 선택하면...

| 원칙 | 효과 |
|------|------|
| 디미터 법칙 | 객체의 내부 구조 고민 불필요 → 구조적 결합도 ↓ |
| 묻지 말고 시켜라 | 필요한 정보를 물을 필요 없이 원하는 것을 표현 |
| 의도를 드러내는 인터페이스 | 클라이언트 관점에서 이름 → 의도가 분명히 드러남 |
| 명령-쿼리 분리 | 협력 속에서 예측 가능한 상태 설계 |

---

## 핵심 요약

### 설계 원칙 체크리스트

```
□ 디미터 법칙: 인접한 이웃에게만 메시지 전송?
□ 묻지 말고 시켜라: 상태 대신 행동을 요청?
□ 의도를 드러내는 인터페이스: "무엇을"이 드러나는 이름?
□ 명령-쿼리 분리: 수정과 조회가 분리?
```

### 한 문장 정리

> "책임 주도 설계 방법에 따라 **메시지가 객체를 결정**하게 하라. 그러면 설계가 아름답고 깔끔해지며 심지어 우아해진다."