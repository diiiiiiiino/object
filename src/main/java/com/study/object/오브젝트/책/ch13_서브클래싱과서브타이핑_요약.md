# Chapter 13. 서브클래싱과 서브타이핑

## 1. 상속의 두 가지 용도

| 용도 | 설명 | 결과 |
|------|------|------|
| **타입 계층 구현** | 일반화/특수화 관계 표현 | 유연하고 확장 가능한 설계 |
| **코드 재사용** | 부모 코드를 자식이 물려받음 | 강한 결합, 변경 어려움 |

> **상속의 일차적 목표 = 타입 계층 구현** (코드 재사용 ❌)

---

## 2. 타입의 세 가지 관점

### 개념 관점
- 세상의 사물 종류를 분류

### 프로그래밍 언어 관점
- 비트에 **의미와 제약** 부여
- 유효한 오퍼레이션 집합 정의
- 오퍼레이션에 대한 문맥 제공

### 객체지향 관점
```
┌────────────────────────────────────────────────────┐
│  타입 = 퍼블릭 인터페이스                           │
│                                                    │
│  동일한 퍼블릭 인터페이스 → 동일한 타입            │
│  동일한 상태 + 다른 인터페이스 → 다른 타입         │
│  다른 상태 + 동일한 인터페이스 → 동일한 타입       │
└────────────────────────────────────────────────────┘
```

> **객체에게 중요한 것은 속성이 아니라 행동**

---

## 3. 타입 계층

### 슈퍼타입 vs 서브타입
| 구분 | 퍼블릭 인터페이스 | 의미 |
|------|-----------------|------|
| **슈퍼타입** | 일반화, 범용적, 넓은 | 부모 |
| **서브타입** | 특수화, 구체적, 좁은 | 자식 |

### 핵심 원리
> **서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다**

---

## 4. 상속 사용 조건 (마틴 오더스키)

### 두 가지 질문에 모두 "예"일 때만 상속
```
Q1. is-a 관계를 모델링하는가?
    → "자식 클래스는 부모 클래스다"가 자연스러운가?

Q2. 클라이언트 입장에서 부모 타입으로 자식을 사용해도 되는가?
    → 행동 호환성이 있는가?
```

### 주의사항
- is-a는 **예비 후보**일 뿐
- **행동 호환성**이 더 중요
- 판단 기준은 **클라이언트의 관점**

---

## 5. 서브클래싱 vs 서브타이핑

| 구분 | 서브클래싱 | 서브타이핑 |
|------|-----------|-----------|
| **목적** | 코드 재사용 | 타입 계층 구성 |
| **별칭** | 구현 상속, 클래스 상속 | 인터페이스 상속 |
| **행동 호환성** | ❌ 없음 | ✅ 있음 |
| **대체 가능성** | ❌ 불가 | ✅ 가능 |
| **is-a 관계** | ❌ 아님 | ✅ 맞음 |

### 예시
```
펭귄 extends 새  → 서브클래싱 (fly 불가능)
정사각형 extends 직사각형 → 서브클래싱 (크기 조정 불일치)
```

---

## 6. 리스코프 치환 원칙 (LSP)

### 정의
> **서브타입은 기반 타입을 대체할 수 있어야 한다**
>
> 클라이언트가 차이점을 인식하지 못한 채 서브클래스를 사용할 수 있어야 함

### 핵심
```
┌────────────────────────────────────────────────────┐
│  대체 가능성을 결정하는 것은 클라이언트다           │
│                                                    │
│  • 클라이언트와 격리한 모델 검증은 무의미          │
│  • 모델의 유효성은 클라이언트 관점에서만 검증 가능 │
└────────────────────────────────────────────────────┘
```

### LSP와 유연한 설계
- 클라이언트 코드 **변경 없이** 새로운 자식 클래스 추가 가능
- 퍼블릭 인터페이스 행동이 동일하면 확장 용이

---

## 7. 인터페이스 분리 원칙 (ISP)

### 비대한 인터페이스의 문제
```
비대한 인터페이스
├── 응집성 없음
├── 메서드 그룹이 각기 다른 클라이언트 지원
└── 한 클라이언트의 변경 → 모든 클라이언트 영향
```

### 해결책
```
인터페이스 분리
├── 클라이언트가 기대하는 바에 따라 분리
├── 호출하지 않는 메서드에 대한 의존성 제거
└── 클라이언트 간 독립성 확보
```

> fly만 필요한 클라이언트에게는 fly만 보여야 한다

---

## 8. 계약에 의한 설계 (DbC)

### 서브타입이 지켜야 할 계약 규칙

| 조건 | 서브타입에서 허용 |
|------|------------------|
| **사전조건** | 같거나 **더 약하게** (완화 가능) |
| **사후조건** | 같거나 **더 강하게** (강화 가능) |

### 위반 사례
```
❌ 서브타입에 더 강한 사전조건 → 부모가 허용하던 것을 거부
❌ 서브타입에 더 약한 사후조건 → 부모가 보장하던 것을 미보장
```

---

## 9. 객체지향 vs 객체기반 프로그래밍

| 구분 | 객체기반 | 객체지향 |
|------|----------|----------|
| 객체 조합 | ✅ | ✅ |
| 캡슐화 | ✅ | ✅ |
| 상속 | ❌ | ✅ |
| 다형성 | ❌ | ✅ |

---

## 핵심 정리

### 올바른 상속의 조건
```
1. is-a 관계 (언어적)
2. 행동 호환성 (클라이언트 관점)
3. 대체 가능성 (LSP)
4. 계약 준수 (사전/사후 조건)
```

### 기억할 원칙
| 원칙 | 내용 |
|------|------|
| **타입 = 행동** | 속성이 아닌 퍼블릭 인터페이스로 결정 |
| **상속 목적** | 코드 재사용 ❌, 타입 계층 ✅ |
| **LSP** | 서브타입은 슈퍼타입을 대체 가능해야 함 |
| **클라이언트 중심** | 대체 가능성의 판단 주체는 클라이언트 |
| **ISP** | 인터페이스는 클라이언트 기대에 따라 분리 |

### 한 줄 요약
> **서브타이핑 = 행동 호환성 + 대체 가능성 + 클라이언트 관점**