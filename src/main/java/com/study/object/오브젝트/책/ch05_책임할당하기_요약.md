# Chapter 05. 책임 할당하기

> 책임 주도 설계의 실천 가이드

---

## 책임 주도 설계를 향해

### 전환을 위한 두 가지 원칙

```
1. 데이터보다 행동을 먼저 결정하라
2. 협력이라는 문맥 안에서 책임을 결정하라
```

### 원칙 1: 데이터보다 행동을 먼저

| 질문 순서 | 데이터 중심 | 책임 중심 |
|----------|------------|----------|
| 1번째 | 어떤 데이터가 필요한가? | 어떤 책임이 필요한가? |
| 2번째 | 데이터를 처리할 오퍼레이션은? | 책임을 수행할 데이터는? |

```
책임 → 상태 (O)
상태 → 책임 (X)
```

### 원칙 2: 협력 안에서 책임을 결정

```
메시지를 전송하기 때문에 객체를 갖게 된다
(객체를 가지고 있어서 메시지를 보내는 것이 아님)
```

**메시지 기반 설계의 장점**:
- 메시지가 클라이언트의 의도를 표현
- 송신자는 수신자에 대해 어떤 가정도 할 수 없음
- 수신자가 자연스럽게 캡슐화됨

---

## 책임 주도 설계 흐름

```
┌─────────────────────────────────────────────────┐
│ 1. 시스템 책임 파악                               │
│    ↓                                            │
│ 2. 더 작은 책임으로 분할                          │
│    ↓                                            │
│ 3. 적절한 객체/역할에 책임 할당                    │
│    ↓                                            │
│ 4. 도움이 필요하면 → 다른 객체/역할 찾기           │
│    ↓                                            │
│ 5. 책임 할당 → 협력 형성                          │
└─────────────────────────────────────────────────┘
```

**핵심**: 책임이 정리될 때까지 내부 상태에 관심 갖지 말 것!

---

## GRASP 패턴

> General Responsibility Assignment Software Pattern

### 1. 정보 전문가 (Information Expert)

```
책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하라
```

**설계 시작점**:
1. 메시지를 전송할 객체는 **무엇을 원하는가?**
2. 메시지를 수신할 적합한 객체는 **누구인가?**

**주의**: 정보를 "저장"하고 있을 필요는 없다
- 다른 객체를 알고 있거나
- 필요한 정보를 계산할 수 있으면 됨

### 2. 창조자 (Creator)

> 객체 생성 책임을 누구에게?

**B가 A를 생성해야 하는 조건** (하나 이상 만족):

| 조건 | 설명 |
|------|------|
| 포함/참조 | B가 A를 포함하거나 참조함 |
| 기록 | B가 A를 기록함 |
| 긴밀한 사용 | B가 A를 긴밀하게 사용함 |
| 초기화 정보 | B가 A 초기화에 필요한 데이터 보유 |

**이점**: 이미 결합된 객체에게 생성 책임 → 전체 결합도 유지

### 3. 낮은 결합도 (Low Coupling)

### 4. 높은 응집도 (High Cohesion)

```
책임 할당의 매 순간마다 검토:
"이 할당이 결합도를 낮추고 응집도를 높이는가?"
```

### 5. 다형성 (Polymorphism)

```
타입에 따라 행동이 변한다면?
→ 타입을 분리하고
→ 변화하는 행동을 각 타입의 책임으로 할당
```

| 구현 방법 | 사용 시점 |
|----------|----------|
| 추상 클래스 | 구현을 공유해야 할 때 |
| 인터페이스 | 책임만 정의하고 싶을 때 |

### 6. 변경 보호 (Protected Variations)

```
변경을 캡슐화하도록 책임을 할당하라
```

- 변경될 가능성이 높은가? → **캡슐화하라**
- 클래스 분해 + 인터페이스 = 결합도↓ 응집도↑

---

## 클래스 응집도 판단법

### 3가지 체크리스트

```
┌─────────────────────────────────────────────────────────┐
│ 1. 변경 이유가 하나 이상인가?                             │
│    → 변경 이유별로 클래스 분리                            │
├─────────────────────────────────────────────────────────┤
│ 2. 초기화 시 일부 속성만 초기화되는가?                     │
│    → 초기화 속성 그룹별로 클래스 분리                      │
├─────────────────────────────────────────────────────────┤
│ 3. 메서드가 특정 속성 그룹만 사용하는가?                   │
│    → 속성-메서드 그룹별로 클래스 분리                      │
└─────────────────────────────────────────────────────────┘
```

---

## 변경과 유연성

### 변경에 대비하는 두 가지 방법

| 방법 | 설명 | 적용 시점 |
|------|------|----------|
| 단순하게 | 이해하고 수정하기 쉽게 | 대부분의 경우 |
| 유연하게 | 변경을 수용할 수 있게 | 유사한 변경이 반복될 때 |

**팁**: 상속 대신 **합성**을 사용하면 정책 변경이 간편해짐

---

## 책임 주도 설계의 대안: 리팩터링

### 실용적 접근법

```
1. 빠르게 동작하는 코드 작성
2. 코드에서 책임을 발견
3. 올바른 위치로 이동 (리팩터링)
```

### 몬스터 메서드의 문제점

| 문제 | 증상 |
|------|------|
| 이해 어려움 | 전체 파악에 시간 과다 소요 |
| 수정 어려움 | 변경 부분 찾기 어려움 |
| 버그 유발 | 일부 수정이 다른 부분에 영향 |
| 재사용 불가 | 복사-붙여넣기만 가능 |

### 작은 메서드의 장점

```
작은 메서드 = 재사용↑ + 주석처럼 읽힘 + 오버라이딩 쉬움
```

**핵심 기준**: 길이가 아니라 **이름과 몸체의 의미적 차이**
- 추출이 코드를 명확하게 한다면, 새 메서드 이름이 더 길어도 추출!

### 객체를 자율적으로 만들기

```
메서드가 사용하는 데이터를 가진 클래스로 메서드를 이동시켜라
```

**확인 방법**: 메서드 안에서 어떤 클래스의 접근자를 사용하는가?

---

## 핵심 요약

### 도메인 모델의 역할

```
도메인 개념 → 책임 할당의 후보
도메인 구조 → 코드 구조를 이끌어냄
```

**중요**: 완벽한 도메인 모델보다 **설계를 시작하는 것**이 중요!

### 기억해야 할 것

1. **메시지를 먼저** 결정하고 객체를 선택하라
2. **정보 전문가**에게 책임을 할당하라
3. 매 순간 **응집도와 결합도**를 검토하라
4. 변경이 예상되면 **다형성 + 변경 보호**로 캡슐화하라
5. 막히면 **동작하는 코드 먼저**, 그 다음 리팩터링

### 한 문장 정리

> "캡슐화, 결합도, 응집도를 이해하고 훌륭한 객체지향 원칙을 적용한다면, 책임 주도 설계를 단계적으로 따르지 않더라도 유연하고 깔끔한 코드를 얻을 수 있다."