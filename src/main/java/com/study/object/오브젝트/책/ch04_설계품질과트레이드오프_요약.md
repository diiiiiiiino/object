# Chapter 04. 설계 품질과 트레이드오프

> 가장 중요한 것은 **책임**이다

---

## 핵심 명제

```
객체지향 설계 = 올바른 객체 + 올바른 책임 + 낮은 결합도 + 높은 응집도
```

### 두 가지 핵심 관점
1. 객체지향 설계의 핵심은 **책임**이다
2. 책임 할당은 **응집도/결합도**와 깊이 연관된다

### 훌륭한 설계란?
> 합리적인 비용 안에서 **변경을 수용**할 수 있는 구조

---

## 설계 트레이드오프 3요소

### 1. 캡슐화

| 구분 | 설명 |
|------|------|
| 정의 | 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법 |
| 구현 | 변경될 가능성이 **높은** 부분 |
| 인터페이스 | 상대적으로 **안정적인** 부분 |

#### 캡슐화의 진정한 의미
```
캡슐화 ≠ 단순히 데이터를 숨기는 것
캡슐화 = 변경될 수 있는 "어떤 것이라도" 감추는 것
```

- **데이터 캡슐화**: 내부 속성을 외부로부터 감추는 것 (캡슐화의 한 종류일 뿐)
- 속성 타입, 할인 정책 종류 등 **내부 구현 변경이 외부에 영향**을 주면 캡슐화 위반

### 2. 응집도 (Cohesion)

```
응집도 = 모듈 내부 요소들의 연관 정도
       = 얼마나 관련 높은 책임들을 할당했는가
```

#### 변경 관점에서의 응집도
| 상황 | 응집도 |
|------|--------|
| 하나의 변경 → 하나의 모듈만 변경 | 높음 |
| 하나의 변경 → 다수의 모듈 변경 | 낮음 |

### 3. 결합도 (Coupling)

```
결합도 = 다른 모듈에 대한 의존성의 정도
       = 다른 모듈에 대해 얼마나 많이 아는가
```

#### 변경 관점에서의 결합도
| 상황 | 결합도 |
|------|--------|
| 내부 구현 변경 → 다른 모듈에 영향 | 높음 |
| 퍼블릭 인터페이스 수정만 영향 | 낮음 |

### 세 요소의 관계

```
캡슐화 ↑ → 응집도 ↑ + 결합도 ↓
```

---

## 데이터 중심 vs 책임 중심

### 비교표

| 구분 | 데이터 중심 | 책임 중심 |
|------|------------|----------|
| 질문 | "어떤 데이터가 필요한가?" | "어떤 책임이 필요한가?" |
| 초점 | 객체 내부 (상태) | 객체 외부 (협력) |
| 설계 순서 | 데이터 → 오퍼레이션 | 협력 → 책임 → 상태 |
| 결과 | 변경에 취약 | 변경에 안정적 |

### 데이터 중심 설계의 문제점

#### 1. 캡슐화 위반
```java
// 나쁜 예: 내부 구현이 인터페이스에 노출
public class Movie {
    public MovieType getMovieType() {}
    public Money calculateAmountDiscountedFee() {}  // 할인 정책 노출
    public Money calculatePercentDiscountedFee() {} // 할인 정책 노출
    public Money calculateNoneDiscountedFee() {}    // 할인 정책 노출
}
```

**추측에 의한 설계 전략**의 함정:
- 협력을 고려하지 않고 "다양한 상황에 대비"
- 결과: 최대한 많은 접근자 메서드 추가 → 내부 구현 노출

#### 2. 높은 결합도
- getter = private을 public으로 바꾸는 것과 거의 동일
- 전체 시스템이 하나의 거대한 의존성 덩어리
- 어떤 변경이든 시스템 전체가 요동

#### 3. 낮은 응집도
- 변경 이유가 다른 코드들이 한 모듈에 뭉쳐있음
- 무관한 코드 수정이 다른 곳에 문제 유발
- 하나의 요구사항 변경 → 여러 모듈 동시 수정

---

## 자율적인 객체 만들기

### 원칙 1: 캡슐화를 지켜라

```
캡슐화 = 설계의 제1원리
```

- private 속성 + getter/setter = 여전히 캡슐화 위반
- 객체는 자신이 어떤 데이터를 가지는지 외부에 공개하면 안됨

### 원칙 2: 스스로 자신의 데이터를 책임지게 하라

```
객체 = 단순한 데이터 제공자가 아님
     = 자신의 상태를 스스로 처리하는 존재
```

#### 올바른 질문 방식
```
"이 객체가 어떤 데이터를 포함해야 하는가?"
              ↓ 분리
┌─────────────────────────────────────┐
│ 1. 어떤 데이터를 포함해야 하는가?     │
│ 2. 데이터에 대해 수행할 오퍼레이션은? │
└─────────────────────────────────────┘
```

---

## 데이터 중심 설계가 실패하는 이유

### 근본적 문제 2가지

```
1. 너무 이른 시기에 데이터에 관해 결정
2. 협력이라는 문맥 없이 객체를 고립시켜 설계
```

### 결과
- 데이터에 초점 → 데이터 지식이 인터페이스에 노출
- 인터페이스가 구현 캡슐화 실패
- 코드가 변경에 취약

---

## 핵심 요약

### 기억해야 할 공식

```
상태 = 구현 (불안정, 변하기 쉬움)
책임 = 인터페이스 (안정적)

상태 변경 → 인터페이스 변경 → 모든 의존 객체에 영향
책임 중심 → 안정적 인터페이스 → 구현 변경 파급 차단
```

### 설계의 무게 중심

```
올바른 무게 중심 = 객체의 외부 (협력)
잘못된 무게 중심 = 객체의 내부 (상태)
```

### 한 문장 정리

> "변하는 것이 무엇인지 고려하고, 변하는 개념을 캡슐화하라. 이것이 캡슐화의 진정한 의미다."