# Chapter 08. 의존성 관리하기

> 의존성의 본질: 변경에 영향을 받을 수 있는 가능성

---

## 의존성 이해하기

### 의존성의 두 가지 시점

| 시점 | 의미 |
|------|------|
| 실행 시점 | 의존 대상 객체가 반드시 존재해야 함 |
| 구현 시점 | 의존 대상이 변경되면 함께 변경됨 |

```
의존성 = 변경에 의한 영향의 전파 가능성
       = 항상 단방향
```

### 의존성 전이

```
A → B → C

직접 의존성: A → B (직접 의존)
간접 의존성: A → C (전이에 의한 영향)
```

**전이 여부 결정 요인**: 변경의 방향 + 캡슐화의 정도

### 런타임 vs 컴파일타임 의존성

| 구분 | 주인공 | 다루는 주제 |
|------|--------|------------|
| 런타임 | 객체 | 객체 사이의 의존성 |
| 컴파일타임 | 클래스 | 클래스 사이의 의존성 |

**핵심 원칙**:
```
컴파일타임 구조 ≠ 런타임 구조
→ 거리가 멀수록 설계가 유연해짐
```

---

## 컨텍스트 독립성

### 정의

```
클래스가 사용될 특정 문맥에 대해 최소한의 가정만으로 이뤄진 상태
```

### 원칙

```
구체 클래스를 알면 알수록 → 특정 문맥에 강하게 결합
                        → 다른 문맥에서 재사용 어려움

컨텍스트에 대한 정보가 적을수록 → 더 다양한 컨텍스트에서 재사용 가능
```

---

## 의존성 해결하기

### 세 가지 방법

```
┌─────────────────────────────────────────────────────────┐
│ 1. 생성자 주입                                           │
│    • 객체 생성 시점에 의존성 해결                          │
│    • 완전한 상태의 객체 생성 보장                          │
├─────────────────────────────────────────────────────────┤
│ 2. Setter 주입                                          │
│    • 생성 후 의존 대상 변경 가능                          │
│    • 단점: 불완전한 상태의 객체 존재 가능                  │
├─────────────────────────────────────────────────────────┤
│ 3. 메서드 인자                                           │
│    • 메서드 실행 동안만 일시적 의존                        │
│    • 매번 의존 대상이 달라지는 경우 유용                   │
└─────────────────────────────────────────────────────────┘
```

### 권장 방식: 생성자 + Setter 혼합

```java
// 생성자로 완전한 객체 생성
public Movie(DiscountPolicy policy) {
    this.policy = policy;
}

// 필요시 Setter로 변경 가능
public void setDiscountPolicy(DiscountPolicy policy) {
    this.policy = policy;
}
```

---

## 의존성과 결합도

### 핵심 구분

```
의존성: 관계의 유무 ("존재한다" / "존재하지 않는다")
결합도: 의존성의 정도 ("강하다" / "느슨하다")
```

### 바람직한 의존성

| 의존성 종류 | 재사용성 | 결합도 |
|------------|----------|--------|
| 컨텍스트 독립적 | 높음 | 느슨함 |
| 컨텍스트 종속적 | 낮음 | 강함 |

```
바람직한 의존성 = 다양한 환경에서 재사용 가능한 의존성
              = 느슨한 결합도
```

---

## 지식이 결합을 낳는다

### 공식

```
더 많이 알수록 → 더 강하게 결합
더 적게 알수록 → 더 느슨하게 결합
             → 더 많은 컨텍스트에서 재사용 가능
```

### 해결책: 추상화

```
추상화 = 불필요한 정보를 감춤
      → 알아야 하는 지식의 양 감소
      → 결합도 느슨해짐
```

---

## 추상화에 의존하라

### 결합도 수준 (위에서 아래로 느슨해짐)

```
┌─────────────────────────────────────┐
│ 구체 클래스 의존성        결합도 강함 │
│         ↓                          │
│ 추상 클래스 의존성                   │
│         ↓                          │
│ 인터페이스 의존성         결합도 느슨 │
└─────────────────────────────────────┘
```

### 각 수준의 특징

| 의존 대상 | 숨기는 정보 | 알아야 하는 것 |
|----------|------------|---------------|
| 구체 클래스 | 없음 | 모든 구현 |
| 추상 클래스 | 메서드 구현, 자식 종류 | 상속 계층 |
| 인터페이스 | 상속 계층까지 숨김 | 수신 가능한 메시지만 |

---

## 명시적인 의존성

### 원칙

```
의존성을 구현 내부에 숨기지 말고, 퍼블릭 인터페이스에 드러내라
```

### 비교

```java
// 숨겨진 의존성 (나쁨)
public class Movie {
    private DiscountPolicy policy;

    public Movie() {
        this.policy = new AmountDiscountPolicy();  // 내부에서 생성
    }
}

// 명시적 의존성 (좋음)
public class Movie {
    private DiscountPolicy policy;

    public Movie(DiscountPolicy policy) {  // 외부에서 주입
        this.policy = policy;
    }
}
```

### 명시적 의존성의 장점
- 의존성 파악이 쉬움
- 재사용 시 코드 수정 불필요
- 버그 발생 가능성 감소

---

## new는 해롭다

### new가 해로운 이유

```
1. 구체 클래스 이름을 직접 기술해야 함
2. 생성자 인자 정보까지 알아야 함
   → 지식의 양 증가 → 결합도 상승
```

### 해결책: 생성과 사용의 분리

```java
// 나쁜 예: 생성과 사용이 결합
public class Movie {
    public Movie() {
        this.policy = new AmountDiscountPolicy(
            Money.wons(800),
            new SequenceCondition(1)
        );
    }
}

// 좋은 예: 생성 책임을 클라이언트로
public class Movie {
    public Movie(DiscountPolicy policy) {
        this.policy = policy;
    }
}
```

### 예외: 가끔은 생성해도 무방

```java
// 기본값 제공 + 유연성 확보
public Movie(String title) {
    this(title, new AmountDiscountPolicy(...));  // 기본값
}

public Movie(String title, DiscountPolicy policy) {
    this.policy = policy;  // 유연성
}
```

**트레이드오프**: 결합도 vs 사용성

### 표준 클래스 의존은 무방

```java
// JDK 표준 클래스는 변경 가능성이 거의 없음
private List<Condition> conditions = new ArrayList<>();
```

단, 가능하면 추상 타입 사용 (`ArrayList` 대신 `List`)

---

## 컨텍스트 확장하기

### 예외 케이스 처리 방법

```java
// 나쁜 예: 조건문으로 예외 처리
if (discountPolicy == null) {
    return fee;
}

// 좋은 예: 새로운 정책 클래스로 표현
public class NoneDiscountPolicy extends DiscountPolicy {
    protected Money getDiscountAmount() {
        return Money.ZERO;
    }
}
```

**핵심**: 예외를 협력 방식의 일부로 만들어라

---

## 조합 가능한 행동

### 유연한 설계의 특징

```
어떤 객체와 협력하느냐에 따라 행동이 달라짐
= 작은 객체들을 다양하게 조합
= 애플리케이션 기능의 쉬운 확장
```

### 선언적 설계

```java
// 코드가 "무엇"을 하는지 선언적으로 표현
new Movie("아바타",
    new AmountDiscountPolicy(
        Money.wons(800),
        new SequenceCondition(1),
        new PeriodCondition(MONDAY, ...)
    )
);
```

**장점**: 인스턴스 생성 코드만 봐도 객체의 행동 예측 가능

---

## 핵심 요약

### 의존성 관리 체크리스트

```
□ 추상화에 의존하는가? (인터페이스 > 추상 클래스 > 구체 클래스)
□ 의존성이 명시적으로 드러나는가?
□ 생성과 사용이 분리되어 있는가?
□ 컨텍스트 독립적인가?
```

### 설계 공식

```
유연한 설계 = 추상화 + 명시적 의존성 + 컨텍스트 독립성
            = 작은 객체들의 조합으로 행동을 표현
```

### 한 문장 정리

> "훌륭한 객체지향 설계란 객체가 **어떻게** 하는지를 표현하는 것이 아니라, 객체들의 조합을 선언적으로 표현함으로써 **무엇을** 하는지를 표현하는 설계다."