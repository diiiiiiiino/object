# Chapter 11. 합성과 유연한 설계

## 1. 상속 vs 합성 비교

### 핵심 차이점
| 구분 | 상속 (Inheritance) | 합성 (Composition) |
|------|-------------------|-------------------|
| **관계** | is-a | has-a |
| **의존 대상** | 부모 클래스 구현 | 퍼블릭 인터페이스 |
| **의존성 해결** | 컴파일타임 (정적) | 런타임 (동적) |
| **결합도** | 높음 (클래스 간) | 낮음 (객체 간) |
| **재사용 방식** | 화이트박스 | 블랙박스 |
| **변경 용이성** | 어려움 | 쉬움 |

### 재사용 방식
```
┌─────────────────────────────────────────────────────┐
│  화이트박스 재사용 (상속)                            │
│  → 부모 클래스 내부가 자식에게 공개됨                │
│  → 내부 구현을 알아야 함                            │
├─────────────────────────────────────────────────────┤
│  블랙박스 재사용 (합성)                              │
│  → 내부는 비공개, 인터페이스로만 재사용              │
│  → 내부 구현 변경에 영향 최소화                     │
└─────────────────────────────────────────────────────┘
```

---

## 2. 상속의 문제점

### 클래스 폭발 (Class Explosion)
```
하나의 기능 추가 → 필요 이상으로 많은 클래스 필요

원인:
├── 자식이 부모 구현에 강하게 결합
├── 컴파일타임에 관계가 고정
└── 다양한 조합 = 조합 수만큼 클래스 추가
```

### 상속의 한계
- 부모 클래스 내부 구현을 상세히 알아야 함
- 코드 작성 시점에 결정된 관계는 변경 불가
- 쉽고 간단하지만 **우아하지 않음**

---

## 3. 추상 메서드와 훅 메서드

### OCP를 만족하는 설계 기법

| 메서드 유형 | 특징 | 단점 |
|------------|------|------|
| **추상 메서드** | 자식이 반드시 오버라이딩 | 모든 자식이 구현해야 함 → 중복 발생 가능 |
| **훅 메서드** | 기본 구현 제공 + 오버라이딩 가능 | 편의성 제공 |

```java
// 추상 메서드 - 반드시 구현
abstract Money calculateFee(Call call);

// 훅 메서드 - 기본 구현 있음, 필요시 오버라이딩
Money afterCalculated(Money fee) {
    return fee;  // 기본 구현
}
```

---

## 4. 합성으로 해결하기

### 합성의 본질
```
┌─────────────────────────────────────────────────────┐
│  상속: 조합 결과를 개별 클래스 안으로 밀어넣음       │
│        → 컴파일타임에 고정                          │
├─────────────────────────────────────────────────────┤
│  합성: 요소들을 개별 클래스로 구현                   │
│        → 실행 시점에 인스턴스 조립                  │
│        → 런타임에 관계 변경 가능                    │
└─────────────────────────────────────────────────────┘
```

### 합성의 장점
1. **구현 → 인터페이스 의존성**으로 전환
2. **클래스 결합도 → 객체 결합도**로 낮춤
3. **런타임에 동적으로 관계 변경** 가능
4. 클래스 폭발 문제 해결

---

## 5. 설계의 트레이드오프

### 유연성 vs 복잡성
```
컴파일타임 의존성 ←────거리────→ 런타임 의존성
        │                              │
      가까움                         멀수록
        │                              │
    단순한 설계                    유연한 설계
    이해하기 쉬움                  복잡도 상승
```

### 판단 기준
> **변경의 고통 > 복잡성의 혼란** → 유연성 선택
>
> 설계는 **변경과 유지보수**를 위해 존재한다

### 아이러니
```
유연성을 위해 복잡성 추가 → 오히려 단순해지는 경우 있음
(상속 → 합성 변환 시 자주 발생)
```

---

## 6. 상속을 사용해야 할 때

### 상속의 두 종류
| 종류 | 설명 | 권장 여부 |
|------|------|----------|
| **구현 상속** | 코드 재사용 목적 | 피해야 함 |
| **인터페이스 상속** | 다형성 활용 목적 | 권장 |

> 이 장의 상속 단점은 **구현 상속**에 국한됨

---

## 핵심 정리

### 의존성 비교
```
상속: 구현에 의존 → 높은 결합도 → 정적 관계
합성: 인터페이스에 의존 → 낮은 결합도 → 동적 관계
```

### 기억할 원칙
| 원칙 | 내용 |
|------|------|
| **합성 우선** | 객체 합성이 클래스 상속보다 좋다 |
| **인터페이스 재사용** | 구현이 아닌 인터페이스를 재사용하라 |
| **런타임 유연성** | 컴파일타임이 아닌 런타임에 관계를 결정하라 |
| **변경 중심 설계** | 설계는 변경과 유지보수를 위해 존재한다 |

### 한 줄 요약
> **합성 = 인터페이스 재사용 + 런타임 유연성 + 낮은 결합도**