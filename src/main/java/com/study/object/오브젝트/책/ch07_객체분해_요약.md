# Chapter 07. 객체 분해

> 설계는 코드 배치 방법이며, 변경에 대비하기 위한 것이다

---

## 핵심 명제

```
변경 = 성공적인 소프트웨어의 피할 수 없는 운명
설계 = 변경에 대비하는 코드 배치 방법
```

---

## 하향식 접근법의 한계

### 문제점

| 문제 | 설명 |
|------|------|
| 이른 결정 강요 | 초기 단계부터 입력/출력 양식을 함께 고민 |
| 문맥 종속성 | 하위 함수가 상위 함수보다 문맥에 더 종속적 |
| 재사용 어려움 | 일반성이 부족해짐 |

### 하향식 vs 객체지향

```
하향식: 함수 간의 호출 순서 중심
객체지향: 객체 사이의 논리적 관계 중심
```

---

## 정보 은닉과 모듈

### 정보 은닉의 핵심

```
자주 변경되는 부분 → 안정적인 인터페이스 뒤로 감춰라
```

### 모듈이 감춰야 할 두 가지 비밀

```
┌─────────────────────────────────────────────────────────┐
│                    모듈의 비밀                           │
├─────────────────────────┬───────────────────────────────┤
│       복잡성             │       변경 가능성              │
├─────────────────────────┼───────────────────────────────┤
│ 이해하고 사용하기 어려움   │ 노출 시 변경의 파급효과 증가    │
│           ↓             │              ↓                │
│ 간단한 인터페이스 제공     │ 모듈 내부로 감추기             │
└─────────────────────────┴───────────────────────────────┘
```

### 가장 일반적인 비밀 = 데이터

```
비밀의 종류:
• 데이터 (가장 일반적)
• 복잡한 로직
• 변경 가능성이 큰 자료 구조

→ 데이터 변경이 시스템을 굴복시키는 가장 흔한 경우
```

---

## 추상 데이터 타입 vs 클래스

### 핵심 차이

| 구분 | 추상 데이터 타입 | 클래스 (객체지향) |
|------|-----------------|------------------|
| 추상화 대상 | 타입 | 절차 |
| 묶는 기준 | 오퍼레이션 기준으로 타입을 묶음 | 타입 기준으로 오퍼레이션을 묶음 |
| 다형성 | 지원 안 함 | 지원 |
| 상속 | 지원 안 함 | 지원 |

### 시각화

```
추상 데이터 타입:
┌─────────────────────────────┐
│      오퍼레이션              │
│  ┌─────┬─────┬─────┐       │
│  │타입A│타입B│타입C│        │
│  └─────┴─────┴─────┘       │
└─────────────────────────────┘

클래스 (객체지향):
┌─────────────────────────────┐
│         타입                 │
│  ┌─────┬─────┬─────┐       │
│  │절차A│절차B│절차C│        │
│  └─────┴─────┴─────┘       │
└─────────────────────────────┘
```

### 객체지향의 본질

```
다형성 = 절차에 대한 차이점을 감춤
객체지향 = 절차 추상화
```

---

## 변경을 기준으로 선택하라

### 객체지향 프로그래밍의 조건

```
클래스 사용 ≠ 객체지향

타입을 기준으로 절차를 추상화해야 진정한 객체지향
```

### 추상 데이터 타입 냄새 맡기

**체크**: 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는가?

```java
// 추상 데이터 타입 스타일 (나쁨)
public class Employee {
    private EmployeeType type;  // 타입 변수!

    public Money calculatePay() {
        switch (type) {
            case HOURLY: return calculateHourlyPay();
            case SALARIED: return calculateSalariedPay();
        }
    }
}

// 객체지향 스타일 (좋음)
public abstract class Employee {
    public abstract Money calculatePay();
}

public class HourlyEmployee extends Employee {
    public Money calculatePay() { ... }
}

public class SalariedEmployee extends Employee {
    public Money calculatePay() { ... }
}
```

### 조건문을 기피하는 이유

```
타입 체크 조건문 → 새 타입 추가 시 모든 조건문 수정 필요
다형성 → 새 클래스만 추가하면 됨 (기존 코드 수정 불필요)
```

---

## 개방-폐쇄 원칙 (OCP)

### 정의

```
기존 코드에 아무런 영향도 미치지 않고
새로운 객체 유형과 행위를 추가할 수 있는 특성
```

### 비교

| 상황 | 추상 데이터 타입 | 객체지향 |
|------|-----------------|----------|
| 새 타입 추가 | 모든 조건문 수정 | 새 클래스만 추가 |
| 클라이언트 영향 | 수정 필요 | 수정 불필요 |

---

## 핵심 요약

### 변경 대응 전략

```
1. 영향 받는 부분과 받지 않는 부분을 명확히 분리
2. 잘 정의된 퍼블릭 인터페이스로 변경 부분 접근 통제
3. 타입을 기준으로 절차를 추상화 (다형성 활용)
```

### 설계 판단 기준

```
□ 모듈이 복잡성과 변경 가능성을 감추고 있는가?
□ 클래스 내부에 타입을 표현하는 변수가 있는가? (있으면 리팩터링)
□ 새 타입 추가 시 기존 코드 수정이 필요한가?
```

### 한 문장 정리

> "단순히 클래스를 사용한다고 객체지향이 아니다. **타입을 기준으로 절차를 추상화**해야 진정한 객체지향 분해다."