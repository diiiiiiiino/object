# Chapter 12. 다형성

## 1. 다형성의 분류

> **Polymorphism** = poly(많은) + morph(형태) = 많은 형태를 가질 수 있는 능력

```
다형성
├── 유니버설 (Universal)
│   ├── 매개변수 (Parametric) ─── 제네릭
│   └── 포함 (Inclusion) ─────── 서브타입 ⭐ 핵심
│
└── 임시 (Ad Hoc)
    ├── 오버로딩 (Overloading) ─ 같은 이름, 다른 시그니처
    └── 강제 (Coercion) ──────── 자동 타입 변환
```

### 다형성 유형별 특징
| 유형 | 설명 | 예시 |
|------|------|------|
| **매개변수** | 타입을 파라미터로 받아 사용 시점에 지정 | `List<T>`, 제네릭 |
| **포함** | 수신 객체 타입에 따라 행동이 달라짐 | 상속, 인터페이스 |
| **오버로딩** | 같은 이름, 다른 매개변수 | `print(int)`, `print(String)` |
| **강제** | 자동 타입 변환으로 연산자 재사용 | `1 + "2"` → `"12"` |

> **"다형성" = 포함 다형성**이 일반적

---

## 2. 상속의 양면성

### 상속의 진정한 목적
```
❌ 코드 재사용
✅ 다형성을 위한 서브타입 계층 구축
```

### 데이터 관점 vs 행동 관점
| 관점 | 상속의 의미 |
|------|------------|
| **데이터** | 자식 인스턴스 안에 부모 인스턴스 포함 |
| **행동** | 부모 메서드가 자식의 퍼블릭 인터페이스에 합쳐짐 |

### 메모리 구조
```
┌─────────────────┐
│ GradeLecture    │──→ [GradeLecture 클래스]──parent──→ [Lecture 클래스]──→ [Object]
│ 인스턴스        │              ↑                              ↑
│ ┌─────────────┐ │         class 포인터                   parent 포인터
│ │ Lecture     │ │
│ │ 인스턴스    │ │
│ └─────────────┘ │
└─────────────────┘
```

---

## 3. 업캐스팅과 동적 바인딩

### 업캐스팅 (Upcasting)
```java
// 부모 타입 변수에 자식 인스턴스 할당 - 암시적 허용
Lecture lecture = new GradeLecture(...);
```

### 다운캐스팅 (Downcasting)
```java
// 자식 타입으로 변환 - 명시적 캐스팅 필요
GradeLecture grade = (GradeLecture) lecture;
```

### 동적 바인딩 (Dynamic Binding)
```
컴파일 시점: 어떤 메서드인지 알 수 없음
실행 시점:   객체의 실제 타입에 따라 메서드 결정
```
- = 지연 바인딩 (Late Binding)

---

## 4. 동적 메서드 탐색

### 탐색 규칙
```
1. 수신 객체의 클래스에서 메서드 검색
   ↓ (없으면)
2. 부모 클래스로 이동하며 계속 검색
   ↓ (없으면)
3. 최상위까지 못 찾으면 예외 발생
```

### 두 가지 원리
| 원리 | 설명 |
|------|------|
| **자동적인 메시지 위임** | 이해 못하면 부모에게 자동 전달 |
| **동적인 문맥 사용** | self 참조로 탐색 경로 결정 |

### self 참조 (self reference)
- 메시지 수신 시 **자동 생성**되는 임시 변수
- 수신한 **객체 자신**을 가리킴
- 메서드 탐색의 **시작점** 결정
- 탐색 종료 시 **자동 소멸**

---

## 5. 메서드 오버라이딩 vs 오버로딩

### 오버라이딩 (Overriding)
```
자식 클래스 메서드가 부모 메서드를 "가림"
→ 동일한 시그니처, 자식이 먼저 탐색되므로
```

### 오버로딩 (Overloading)
```
이름만 같고 시그니처가 다른 메서드들이 "공존"
→ 상속 계층에 걸쳐 사이좋게 존재
```

---

## 6. self 전송 vs super 전송

### self 전송
```
self.method()
├── 탐색 시작: self가 가리키는 객체의 클래스
├── 시작 위치: 동적으로 결정 (런타임)
└── 특징: 메시지 수신 객체에 따라 달라짐
```

### super 전송
```
super.method()
├── 탐색 시작: 현재 클래스의 부모 클래스
├── 시작 위치: 정적으로 결정 (컴파일타임)
└── 특징: 반드시 부모에 있을 필요 없음 (조상 어딘가에만 있으면 됨)
```

### 핵심 차이
| 구분 | self 전송 | super 전송 |
|------|----------|-----------|
| 탐색 시작 | 수신 객체의 클래스 | 현재 클래스의 부모 |
| 결정 시점 | 런타임 (동적) | 컴파일타임 (정적) |

> **super의 의미**: "부모 클래스 메서드 호출" ❌
> "부모 클래스에서부터 탐색 시작" ✅

---

## 7. 위임 (Delegation)

### 위임 vs 포워딩
| 구분 | self 참조 전달 | 용도 |
|------|---------------|------|
| **위임** | O | 다형성 구현 (상속 대체) |
| **포워딩** | X | 단순 코드 재사용 |

### 위임의 본질
```
상속 = 클래스 간의 관계
위임 = 객체 간의 관계로 다형성 구현
```

> **위임의 정확한 용도**: 클래스 상속을 객체 합성으로 대체하여 다형성 구현

---

## 8. 정적 타입 vs 동적 타입 언어

### 이해할 수 없는 메시지 처리
| 언어 유형 | 처리 방식 |
|----------|----------|
| **정적 타입** | 컴파일 에러 발생 |
| **동적 타입** | 런타임에 발견, `doesNotUnderstand` 등 메시지 전송 |

---

## 핵심 정리

### 상속의 메커니즘 5가지
| 개념 | 설명 |
|------|------|
| **업캐스팅** | 자식 → 부모 타입 암시적 변환 |
| **동적 바인딩** | 런타임에 메서드 결정 |
| **동적 메서드 탐색** | 자식 → 부모 방향으로 탐색 |
| **self 참조** | 수신 객체를 가리키는 동적 참조 |
| **super 참조** | 부모부터 탐색 시작하는 정적 참조 |

### 기억할 원칙
```
┌────────────────────────────────────────────────────┐
│  상속의 목적 = 코드 재사용 ❌                       │
│  상속의 목적 = 다형성을 위한 서브타입 계층 구축 ✅  │
└────────────────────────────────────────────────────┘
```

### 한 줄 요약
> **포함 다형성 = 상속 계층 + 동적 메서드 탐색 + self/super 참조**