# Chapter 09. 유연한 설계

## 1. 개방-폐쇄 원칙 (OCP)

> **확장에는 열려 있고, 수정에는 닫혀 있어야 한다**

### 핵심 개념
| 키워드 | 관점 | 의미 |
|--------|------|------|
| **확장** | 동작 | 새로운 기능을 추가할 수 있다 |
| **수정** | 코드 | 기존 코드를 변경하지 않는다 |

### 컴파일타임 vs 런타임 의존성
```
[컴파일타임] 코드에 드러난 클래스 관계 → 고정
[런타임]     실행 시 객체들 사이의 관계 → 유연하게 변경
```

**OCP를 따르는 설계** = 컴파일타임 의존성은 유지 + 런타임 의존성은 확장 가능

### 추상화가 핵심
- **추상화**: 변하지 않는 부분만 남기고 변하는 부분은 생략
- 생략된 부분 → 확장의 여지 (열려 있음)
- 남겨진 부분 → 수정 불필요 (닫혀 있음)

> 올바른 추상화 = 변하는 것과 변하지 않는 것을 구분하여 신중하게 선택

---

## 2. 생성 사용 분리

### 문제점
- 객체 생성 지식 → 과도한 결합도 유발
- 생성과 사용이 같은 클래스에 공존 → 컨텍스트 종속

### 해결책
```
┌─────────────────────────────────────────────┐
│  객체 생성 책임  ≠  객체 사용 책임          │
│  → 서로 다른 객체로 분리!                   │
└─────────────────────────────────────────────┘
```

**방법 1**: 클라이언트로 생성 책임 이동
**방법 2**: FACTORY 패턴 사용

### PURE FABRICATION (순수한 가공물)
- 도메인 개념이 아닌, 설계 품질을 위해 만든 인공적 객체
- FACTORY가 대표적인 예

| 분해 방식 | 설명 |
|-----------|------|
| 표현적 분해 | 도메인 개념 → 객체 |
| 행위적 분해 | 순수한 기술적 필요 → 가공물 |

> 도메인 객체 + 가공물이 조화롭게 협력하는 것이 목표

---

## 3. 의존성 주입 (DI)

> 외부에서 의존성을 전달하여 해결

### 세 가지 방법
| 방식 | 시점 | 특징 |
|------|------|------|
| **생성자 주입** | 객체 생성 시 | 필수 의존성 명시, 생명주기 전체 유지 |
| **setter 주입** | 생성 후 | 런타임에 교체 가능, 누락 위험 |
| **메서드 주입** | 메서드 호출 시 | 특정 메서드만 필요할 때 |

### SERVICE LOCATOR의 문제점
```
숨겨진 의존성의 폐해:
├── 문제 발견 시점이 런타임으로 지연
├── 단위 테스트 어려움 (정적 변수 공유)
├── 캡슐화 위반 (내부 구현을 알아야 함)
└── 의존성 설정 시점과 해결 시점이 분리
```

### 결론
> **명시적 의존성 > 숨겨진 의존성**
>
> 의존성은 퍼블릭 인터페이스에 노출하라

---

## 4. 의존성 역전 원칙 (DIP)

### 원칙
1. 상위 모듈 ≠ 하위 모듈에 의존 → **둘 다 추상화에 의존**
2. 추상화 ≠ 구체적 사항에 의존 → **구체가 추상에 의존**

### 왜 "역전"인가?
```
[전통적 패러다임]
상위 모듈 → 하위 모듈
인터페이스 소유권: 서버 모듈

[객체지향 패러다임]
상위 모듈 → 추상화 ← 하위 모듈
인터페이스 소유권: 클라이언트 모듈 (역전!)
```

### SEPARATED INTERFACE 패턴
- 추상화를 클라이언트 패키지에 포함
- 재사용 단위가 다른 클래스는 별도 패키지로 분리
- 불필요한 재컴파일 방지

---

## 5. 유연성에 대한 조언

### 양면성
| 유연한 설계 | 단순한 설계 |
|-------------|-------------|
| 복잡하고 암시적 | 단순하고 명확 |
| 확장 용이 | 이해 용이 |
| 런타임 ≠ 컴파일타임 | 구조 = 실행 |

### 핵심 원칙
```
유연성은 필요할 때만 가치 있다
├── 변경은 "예상"이 아닌 "현실"이어야
├── 막연한 불안감 → 불필요한 복잡성
└── 복잡성의 근거를 제시할 수 있어야
```

### 설계 우선순위
```
1순위: 역할, 책임, 협력 설계
2순위: 의존성 관리
3순위: 객체 생성 방법 (가장 마지막!)
```

> **"객체가 무엇이 되고 싶은지 알기 전까지**
> **인스턴스화 방법은 신경 쓰지 마라"**

---

## 한 줄 요약

| 원칙 | 핵심 |
|------|------|
| OCP | 추상화에 의존하여 확장은 열고 수정은 닫아라 |
| 생성/사용 분리 | 생성 책임은 FACTORY나 클라이언트로 분리 |
| DI | 의존성을 명시적으로 퍼블릭 인터페이스에 노출 |
| DIP | 상위/하위 모두 추상화에 의존, 인터페이스는 클라이언트 소유 |
| 유연성 | 필요할 때만, 책임 설계가 먼저 |