# Chapter 10. 상속과 코드 재사용

## 1. DRY 원칙

> **Don't Repeat Yourself**: 동일한 지식을 중복하지 말라

### 중복 코드가 문제인 이유
```
중복 코드
├── 변경을 방해
├── 수정 노력 몇 배 증가
├── 일관성 붕괴 위험
└── 시스템 공황 상태 가능
```

### 중복 여부 판단 기준
| 기준 | 중복 여부 |
|------|----------|
| **변경** | 함께 수정해야 하면 중복 ✅ |
| **모양** | 유사해 보여도 중복 아닐 수 있음 ❌ |

> **핵심**: 중복 = 코드가 **변경에 반응하는 방식**으로 판단

---

## 2. 취약한 기반 클래스 문제

### Fragile Base Class Problem
> 부모 클래스의 변경에 의해 자식 클래스가 영향받는 현상

```
부모 클래스 수정 (안전해 보임)
    ↓
새로운 행동이 자식에게 상속
    ↓
자식 클래스 오작동 가능
    ↓
모든 자식 클래스 점검 + 테스트 필요
```

### 상속이 위험한 이유
- 자식이 부모의 **구현 세부사항에 의존**
- 퍼블릭 인터페이스가 아닌 **구현 변경에도** 영향받음
- **캡슐화 약화** + **결합도 증가**

---

## 3. 상속을 위한 4가지 경고

### 경고 1: super 호출의 결합
```
super 참조로 부모 메서드 직접 호출
→ 두 클래스 강하게 결합
→ super 호출 제거 방법을 찾아라
```

### 경고 2: 불필요한 인터페이스 상속
```
상속받은 부모 메서드가
자식의 내부 구조 규칙을 깨트릴 수 있다

예: Stack extends Vector
    → add()로 중간 삽입 가능 (LIFO 위반)
```

### 경고 3: 메서드 오버라이딩 오작용
```
자식이 부모 메서드 오버라이딩 시
부모가 자신의 메서드 사용하는 방법에 결합

예: InstrumentedHashSet.addAll()
    → 내부적으로 add() 호출하는 것 몰랐음
```

### 경고 4: 동시 수정 문제
```
상속하면 둘 중 하나 선택:
├── 영원히 변경 안 하거나
└── 부모/자식 동시에 변경
```

---

## 4. 해결 방법: 추상화에 의존

### 핵심 원칙
> 부모와 자식 **모두** 추상화에 의존하도록 만들어라

### 두 가지 지침
| 지침 | 설명 |
|------|------|
| **차이점을 메서드로 추출** | 유사한 두 메서드의 다른 부분을 별도 메서드로 |
| **코드를 상위로 올려라** | 자식의 코드를 부모로 올리기 (내리지 말고) |

### 왜 '위로 올리기'인가?
| 전략 | 실수했을 때 |
|------|------------|
| **위로 올리기** ✅ | 컴파일 에러로 쉽게 발견 |
| **아래로 내리기** ❌ | 구체적 행동이 상위에 남음 |

### 리팩터링 순서
```
1. 메서드 먼저 이동 (인스턴스 변수 전에)
2. 컴파일 에러 발생
3. 필요한 것 파악
4. 필요한 것만 이동
```

---

## 5. 추상화의 핵심

### 목표 구조
```
┌─────────────────────────────┐
│   AbstractPhone (추상화)     │
│   ┌───────────────────┐     │
│   │ calculateFee()    │←────│── 추상 메서드 호출
│   │ (공통 로직)        │     │   (DIP 준수)
│   └───────────────────┘     │
└─────────────────────────────┘
         △
    ┌────┴────┐
    │         │
[Phone]  [NightlyDiscountPhone]
 구체 구현     구체 구현
```

### 인스턴스 변수의 한계
| 상황 | 결과 |
|------|------|
| 인스턴스 변수 불변 + 행동만 변경 | 독립적 진화 가능 ✅ |
| 인스턴스 변수 추가 | 상속 계층 전반 변경 필요 ❌ |

> 그래도 **핵심 로직 중복**보다는 **초기화 로직 변경**이 낫다

---

## 6. 차이에 의한 프로그래밍

### Programming by Difference
> 기존 코드와 **다른 부분만 추가**하여 기능 확장

```
기존 클래스 코드 + 차이점 구현 = 새로운 기능
→ 점진적 정의 (incremental definition) 가능
```

### 코드 재사용의 가치
```
재사용 가능한 코드 = 심각한 버그 없는 코드

재사용하면:
├── 품질 유지
├── 작성 노력 감소
└── 테스트 부담 감소
```

---

## 7. 결론: 상속보다 합성

### 상속의 매력과 위험
| 장점 | 위험 |
|------|------|
| 새 기능 추가 코드량 최소화 | 오용/남용 시 이해 어려움 |
| 익숙한 개념으로 빠른 추가 | 확장이 어려워짐 |

### 최종 조언
```
┌────────────────────────────────────────────────────┐
│  정말로 필요한 경우에만 상속을 사용하라             │
│  상속은 대부분의 경우 우아한 해결 방법이 아니다     │
│                                                    │
│  → 더 좋은 방법: 합성 (Composition)                │
└────────────────────────────────────────────────────┘
```

---

## 핵심 정리

### 4가지 경고 요약
| # | 경고 | 해결책 |
|---|------|--------|
| 1 | super 호출 → 강한 결합 | super 제거 방법 찾기 |
| 2 | 부모 메서드가 자식 규칙 파괴 | 인터페이스 신중히 설계 |
| 3 | 오버라이딩 시 부모 구현에 결합 | 추상 메서드 활용 |
| 4 | 동시 수정 강제 | 추상화에 의존 |

### 기억할 원칙
| 원칙 | 내용 |
|------|------|
| **DRY** | 동일한 지식을 중복하지 말라 |
| **추상화 의존** | 부모/자식 모두 추상화에 의존 |
| **위로 올리기** | 자식 코드를 부모로 (내리지 말고) |
| **차이점 추출** | 다른 부분만 별도 메서드로 |
| **합성 우선** | 상속보다 합성 사용 |

### 한 줄 요약
> **상속 = 결합도 증가 + 캡슐화 약화 → 합성으로 대체하라**