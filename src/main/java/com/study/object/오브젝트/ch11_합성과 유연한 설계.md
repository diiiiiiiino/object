싱속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다. 스와 자식 클래스를 연결해서 부모 클래스의 코드를 재시용히는 데 비해 합성은 전체를 가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다. 싱속에서 부모 래스 사이의 의존성은 컴파일타임에 해결되지만 합성에서 두 객체 시이의 의존성은 다. 싱속 관계는 is-a 관계리고 부르고 합성 관계는 has-a 관계라고 부른다. 싱속과 용이리는 동일한 목적을 가진다는 점을 제외하면 구현 방법부터 변경을 다루는 방식에 든 면에서 도드라진 차이를 보인다.
싱속이 부모 클래
표현하는 객체
클래스와 자식 클
런타임에 해결된
합성은 코드 재사
이르기까지 모
상속을 이용하면 자식 클래스의 정의에 부모 클래스의 이름을 덧붙이는 것만으로 부모 클래스의 를 재사용할 수 있게 된다. 싱속을 통해 자식 클래스는 부모 클래스의 정의 대부분을 물려받게 모 클래스와 다른 부분만 추가하거나 재정의함으로써 기존 코드를 쉽게 획장할 수 있다. 그러나 제대로 횔용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알o탸 하기 때문에 자식 와 부모 클래스 사이의 결합도가 높아질 수밖에 없다. 결과적으로 싱속은 코드를 재사용할 고 간단한 방법 일 지는 몰리도 우아한 방법 이 라고 할 수는 없다,
코드
되며 부
싱속을
클래스
수 있는 쉽
합성은 퍼블릭 향을 구현에 의존하지 인터페이스에 최소회할 수 있기 않는다는 의존한다. 때문에 변경에 점에서 따라서 싱속과 합성을 더 안정적인 다르다. 이용하면 코드를 합성은 포함된 얻을 내부에 객체의 수 있게 포함되는 내부 구현이 객체의 구현이 아닌
변경되더라도 영
된다.

싱속 관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계다. 이 차이점
은 생각보다 중요한데. 코드 작성 시점에 결정한 싱속 관계는 변경이 불가능하지만 합성 관계는 실행
시점에 동적으로 변경할 수 있기 때문이다. 따라서 상속 대신 합성을 시용하면 변경하기 쉽고 유연한
설계를 얻을 수 있다.
물론 상속보다 합성을 이용하는 것이 구현 관점에서 좀 더 번거롭고 복잡하게 느껴질 수도 있다. 하지
만 설계는 변경과 관련된 것이리는 점을 기억하라. 변경에 유연하게 대처할 수 있는 설계가 대부분의
경우에 정답일 가능성이 높다. 따라서 디음과 같이 정 리할 수 있다.

상속과 합성은 재사용의 대상이 다르다. 싱속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합
성은 포함되는 객체의 퍼블릭 인터페이스를 재시용한다. 따라서 싱속 대신 합성을 사용하면 구현에 대
한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다. 다시 밀해서 클래스 사이의 높은 결합도를
객체 사이의 낮은 결힘도로 대체할 수 있는 것이다.

객체지향 시스템에서 기능을 재사용할 수 있는 가장 대표적인 기법은 클래스 상속(Class inheritance)과 객
체 힙성(object composition)이다. ... 클래스 상속은 다른 클래스를 이용해서 한 클래스의 구현을 정의하
는 것이다. 서브클래싱에 의한 재사용을 호FI트박스 재사용(white-box reu5e)이라고 부른다. 화이트박스라
는 말은 가시성 때문에 나온 밀cl다. 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화
이트박스인 셈이다.
객체 합성은 클래스 상속의 대인이다. 새로운 7 I능을 위해 객체들을 합성힌다. 객체를 합성하려면 합성할 객체
들의 인터페이스를 명확하게 정의해야만 한다. 이런 스태일의 재사용을 불랙박스 재사용(bl ack-box reuse)이
라고 하는데. 객제의 내부는 공개되지 않고 인터페이스를 통해서만 재시용되게 때문이다[COF94] .

## 추상 메서드와 훅 메서드
개방-폐쇄 원칙을 만족하는 설계를 만들 수 있는 한 가지 방법은 부모 클래스에 새로운 추상 메서드를 추가하고 부모
클래스의 다른 메서드 안에서 호줄하는 것이다. 자식 클래스는 추상 메서드를 오버라이딩하고 자신만의 로직을 구현해서
부모 클래스에서 정의한 플로우에 개입할 수 있게 된다. 처음에 Phone 클래스에서 추상 메서드인 CalculateFee와
afterCalCulated를 선언하고 자식 클래스에서 두 메서드를 오버라이딩한 것 역시 이 방식을 응용한 것이다.
추상 메서드의 단점은 상속 계층에 속하는 모든 자식 클래스가 추상 메서드를 오버라이딩해야 한다는 것이다. 대부분의
자식 클래스가 추상 메서드를 동일한 방식으로 구현한다면 싱속 계층 전반에 걸쳐 중복 코드가 존재하게 될 것이다. 해결
방법은 메서드에 기본 구현을 제공하는 것이다. 이처 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로
메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 에서드를 혹 메서드(hook method)라고 부른다. 예제에서 기본
구현을 가지토록 수정된 afterCalculated 메서드가 바로 혹 에서드다.

상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가
해야 하는 경우를 가리켜 클래스 폭발(class explosion)[Sh레llowayOI] 문제 또는 조합의 폭발
(combinational explosion) 문제리고 부른다. 클래스 폭발 문제는 자식 클래스가 부모 클래스의 구
현에 강하게 결합되도록 깅요히는 싱속의 근본적인 한계 때문에 발생히는 문제다. 컴파일타임에 결정
된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에 자식 클래스와 부모 클래스의 다
양한 조합이 필요한 상황게서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것뿐이다.

## 합성 관계로 변경하기
싱속 관계는 컴파일타임에 결정되고 고정되기 때문에 코드를 실행히는 도중에는 변경할 수 없다. 따라
서 여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야
한다. 이것이 바로 핸드폰 괴금 시스템의 설계 과정에서 직면했던 클래스 폭발 문제다.
합성은 컴파일타임 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다. 합성을 시용하면 구현이
아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있다.
8장에서 컴파일타임 의존성과 런타임 의존성의 거리가 멀수록 설계가 유연해진다고 했던 것을 기억하
라. 싱속을 사용하는 것은 컴파일타임의 의존성과 런타임의 의존성을 동일하게 만들겠다고 선언하는
것이다. 따라서 싱속을 사용하면 부모 클래스와 자식 클래스 사이의 관계가 정 적으로 고정되기 때문에
실행 시점에 동적으로 관계를 변경할 수 있는 방법이 없다.
싱속과 달리 합성 관계는 런타임에 동적으로 변경할 수 있다. 합성을 사용하면 컴파일타임 의존성과 런
타임 의존성을 다르게 만들 수 있다. 사실 8장에서 살펴본 유연한 설계를 만들기 위한 대부분의 의존성
관리 기법은 싱속이 아닌 합성을 기반으로 한다. 클래스 폭발 문제를 해결하기 위해 합성을 사용하는
이유는 런타임에 객체 사이의 의존성을 자蒲게 변경할 수 있기 때문이다.
사실 우리는 이미 행동을 조합하기 위해 합성을 이용하는 개념적인 방법에 관해 살펴본 적이 있다. 앞
으로 돌아가 그림 11.2를 다시 살펴보자. 그림 11.2에서 기본 정책과 부가 정책을 독립적인 박스로 표
현하고 순서 에 따라 조합했다는 것에 주목하라.
이 것이 바로 합성의 본질이다. 합성을 시용하면 구현 시점에 정책들의 관계를 고정시 킬 필요가 없으며
실행 시점에 정책들의 관계를 유연하게 변경할 수 있게 된다. 싱속이 조합의 결괴를 개별 클래스 안으
로 밀어 넣는 방법이라면 합성은 조합을 구성히는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스
턴스를 조립하는 방법을 시용하는 것이리고 할 수 있다. 컴파일 의존성에 속박되지 않고 다잉한 방식의
런타임 의존성을 구성할 수 있다는 것이 합성이 제공히는 가장 커다란 장점 인 것이다.

물론 컴파일타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복집도가 상승하기 때문에 코
드를 이해하기 어려워지는 것 역시 사실이다. 하지만 설계는 변경과 유지보수를 위해 존재한디는 사실
을 기억히라. 설계는 트레이드오프의 산물이다. 대부분의 경우에는 단순한 설계가 정답이지만 변경에
따르는 고통이 복잡성으로 인한 혼란을 넘어서고 있다면 유연성의 손을 들어주는 것이 현명한 판단일
획률이 높다.
아이러니하게도 변경하기 편리한 설계를 만들기 위해 복잡성을 더히고 나면 원래의 설계보다 단순해지
는 경우를 종종 볼 수 있다. 싱속을 힙성으로 변경한 핸드폰 괴금 시스템이 바로 그런 경우다. 그 이유
를 살펴 보자.

* 객체 합성이 클래스 싱속보다 더 좋은 방법이다
  객체지향에서 코드를 재시용하기 용을 위한 우이한 해결책은 아니다. 시키기 때문에 코드의 진회를 방해한다.
  위해 상속은 가장 널리 부모 시용되는 클래스의 방법은 세부적인 싱속이다. 구현에 자식 하지만 상속은 클래스를 코드 강하게 재사
  결합
  코드를 재시용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 이 구현을 재시용하는 데 비해 합성은 객체의 인터페이스를 재시용한다.
  합성을 이용하는 것이다. 싱속
  여기서 한 가지 의문이 들 것이다. 그렇다면 경우는 언제인기? 이 의문에 대딥하기 로 니눠야 한디는 시실을 이해해야 한다. 싱속에 국한된디는 점 또한 이해해야 한다.
  상속은 위해서는 그리고 시용해서는 먼저 이번 싱속을 장에서 안 되는 것인가? 상속을 구현 싱속과 인터페이스 살펴본 싱속에 대한 모든 시용해야 싱속의 단점들은 하는
  두 기지
  구현
  15장에서는 13징을 읽고 인터페이스 나면 구현 싱속이 이번 징에서 싱속을 피히고 인터 페이스 살펴본 상속을 구현 상속과 사용해야 어떤 히는 면에서 이유를 디튼지 이해히케 살펴볼 것이다.
  될 것이다.
