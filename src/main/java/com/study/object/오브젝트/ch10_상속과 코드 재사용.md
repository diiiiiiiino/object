## 상속과 중복 코드
### 상속과 중복 코드
* DRY	원ᆴ
  * 중복	ᇬ드는	변경을	방해한다.	이것이	중복	ᇬ드൐	제거해야	하는	가장	큰	이유다.	프ച그램의	본질은
    비즈니스와	관ഏ된	지식을	ᇬ드ച	변환하는	것이다.	안타깝게도	이	지식은	힝상	변한다.	그에	맞ᆛ	지
    식을	표현하는	ᇬ드	역시	변경해야	한다.	그	이유가	무엇이건	일단	새ച운	ᇬ드൐	추가하고	나면	언젠
    가는	변경될	것이라고	생각히는	것이	현명하다.
    중복	ᇬ드가	가지는	가장	큰	문제는	ᇬ드൐	수정하는	데	필요한	노എ을	몇	배ച	증가시킨디는	것이다.
    우선	어떤	ᇬ드가	중복인지൐	찾이야	한다.	일단	중복	ᇬ드의	묶음을	찾았다면	찾아낸	모든	ᇬ드൐	일
    관되게	수정해야	한다.	모든	중복	ᇬ드൐	개별적으ച	테스트해서	동일한	결괴൐	내놓는지	확인해야만
    한다.	중복	ᇬ드는	수정과	테스트에	드는	비용을	증가시킬뿐만	아니라	시스템과	여೻분을	공힁상태ച
    몰아넣을	수도	있다.
    중복	여부൐	판단하는	기준은	변경이다.	요구사항이	변경됐을	때	두	ᇬ드൐	함께	수정해야	한다면	이
    ᇬ드는	중복이다.	함께	수정할	필요가	없다면	중복이	아니다.	중복	ᇬ드൐	결정히는	기준은	ᇬ드의	모
    양이	아니다.	모양이	유시하다는	것은	단지	중복의	징후일	뿐이다.	중복	여부൐	결정하는	기준은	ᇬ드
    가	변경에	반응하는	방식이다.
    신ദ할	수	있고	수정하기	쉬운	소프트웨어൐	만드는	효과적	인	방법	중	하니는	중복을	제	거	히는	것이	다.
    앤드൅	헌트와	데이비드	토마스의	말을	인용하자면	프ച그래머들은	DRY	원ᆴ을	따൘야	한다.	DRY는
    ‘반복하지	마라,൘는	뜻의	Don't	Repeat	Yourself의	첫	글자൐	모아	만든	용어ച	간단히	말해	동일한
    지식을	중복하지	말൘는	것이다
  * DRY	원ᆴ은	한	번.	단	한번(once	and	Only	once)	원ᆴ[Beck96]	또는	단일	지점	제어(SinglePoint	Control)	원ᆴ[GI겐ssO6b]이라고도	부൏다.	원ᆴ의	이൑이	무엇이건	핵심은	ᇬ드	안에	중복이
    존재해서는	안	된다는	것이다.
* 중복과	변경
  * 지금	살펴본	것처೿	중복	ᇬ드는	새ച운	중복	ᇬ드൐	부൏다.	중복	ᇬ드൐	제거하지	않은	상태에서	ᇬ
    드൐	수정할	수	있는	유일한	방법은	새ച운	중복	ᇬ드൐	추가하는	것뿐이다.	새ച운	중복	ᇬ드൐	추가
    하는	과정에서	ᇬ드의	일관성이	무너질	위험이	항상	도사൘고	있다.	더	큰	문제는	중복	ᇬ드가	늘어날
    수ഛ	애플൘ᇛ이션은	변경에	ᆟ약해지고	버그가	발생할	기능성이	높아진다는	것이다.	중복	ᇬ드의	양
    이	많아질수ഛ	버그의	수는	증가하며	그에	비ഖ해	ᇬ드൐	변경하는	속도는	점점	더	느഍진다.
    민첩하게	변경하기	위해서는	중복	ᇬ드൐	추가하는	대선	제거해야	한다.	기회가	생길	때마다	ᇬ드൐
    DRY하게	만들기	위해	노എ하라.
* 타입 코드 사용하기
  * 두	클래스	사이의	중복	ᇬ드൐	제거하는	한	가지	방법은	클래스൐	하나ച	합ᆳ는	것이다.	다음
    과	같이	요금제൐	구분하는	타입	ᇬ드൐	추가하고	타입	ᇬ드의	값에	따라	ച직을	분기시ᇣ	Phone과
    NightlyDi5countPhone을	하나ച	합ᆷ	수	있다.	하지만	계속	강조했던	것처೿	타입	ᇬ드൐	사용하는	클래
    스는	낮은	응집도와	높은	결합도൘는	문제에	시달൘게	된다.
* 상속을	이용해서	중복	ᇬ드	제거하기
  * 싱속의	기본	아이디어는	매우	간단하다.	이미	존재하는	클래스와	유시한	클래스가	필요하다면	ᇬ
    드൐	복시하지	말고	싱속을	이용해	ᇬ드൐	재사용하라는	것이다.
* 깊고	깊은	싱속	곏의	계단을	하나	내഍
  올	때마다	이	해하기	어	഍운	가정과	마주효셔l	된디고	생각해보라.
  4장에서	결합도൐	하니의	모듈이	디൏	모ൈ게	대해	얼마나	많은	지식을	갖고	있는지൐	니타내는	정도
  ച	정의했다.	이	예제에서	볼	수	있는	것처೿	싱속을	이용해	ᇬ드൐	재사용하기	위해서는	부모	클래스
  의	개발자가	세웠던	가정이나	추ജ	과정을	정확하게	이해해야	한다.	이것은	자식	클래스의	작성자가	부
  모	클래스의	구현	방법에	대한	정확한	지식을	가져야	한디는	것을	의미한다.
  따൘서	상속은	결힘도൐	높인다.	그൘고	싱속이	초래히는	부모	클래스와	자식	클래스	시cl의	깅한	결합
  이	ᇬ드൐	수정늅pl	어ഒ게	만든다.
* 자식	클래스의	메서드	안에서	5uper	ᆹ조൐	이용해	부모	클래스의	에서드൐	직접	호출할	경우	두	클래스는	강하게
  결합된다.	super	호출을	제거할	수	있는	방법을	찾아	결힙도൐	제거히라

### 취약한 기반 클래스 문제
* 자식	클래스는	부모	클래스의	불필요한	세부사힝예	엮이게	된다.	부모	클래스의	직은	변경에도	자식	클
  래스는	ᇖ파일	오൅와	실행	에೻൘는	고통에	시달഍야	할	수도	있다.
  이처೿	부모	클래스의	변경에	의해	자식	클래스가	영향을	받는	현상을	ᆟ약한	기반	클래스	문제
  (Fragile	Base	CIass	Problem,	Brillle	Base	CIass	Problem)[HolubO4]൘고	부൏다.	이	문제는
  싱속을	 사용한다면	 피할	 수	 없는	 객체지향	 프ച그래밍의	 근본적인	 ᆟ약성이다.
* 이제	결합도의	개념을	상속에	적용해보자.	구현을	상속한	경우(extends൐	사용한	경우)	파생	클래스는	게반
  클래스에	깅하게	겸합되며,	이	둘	사이의	밀접한	연결은	바람직하지	않다.	설계자들은	이೽	현싱에	대해	‘ᆟ약힌
  기반	클래스	문제”라는	명	ᆼ을	붙였다.	겉	으ച	보기에는	안전한	방식으ച	기반	클래스൐	수정한	것처೿	보이더라
  도	이	새ച운	행동이	파생	클래스에게	상속될	경우	파생	클래스의	잘못된	동작을	초래할	수	있기	때문에	기반	클
  래스는	“ᆟ약하다'..	단순히	기반	클래스의	메서드들만을	조시하는	것만으ച는	기반	클래스൐	변경하는	것이	안
  전하다고	확신할	수	없다모든	파생	클래스들을	살펴봐야(그൘고	데스트까지	해야l	힌다.	L	k	I가	기반	클래스와
  파생	클래스൐	사용하는	모든	ᇬ드가	새ച운	ᇬ드ച	인해	영향을	받지	않았는지	점검해야	힌다.	핵심적인	기반
  클래스에	대한	단순한	변경이	전체	프ച그램을	불안정한	상태ച	만들어버릴	수도	있다
* ᆟ약한	기반	클래스	문제는	싱속이൘는	문맥	안에서	결힘도가	초래히는	문제점을	가൘키는	용어다.	상
  속	관계൐	추가할수ഛ	전체	시스템의	결합도가	높아진다는	사실을	알고	있어야	한다.	싱속은	자식	클래
  스൐	점진적으ച	추가해서	기능을	확장하는	데는	용이하지만	높은	결합도ച	인해	부모	클래스൐	점진
  적으ച	개선히는	것은	어ഒ게	만든다.	최악의	경우에는	모든	자식	클래스൐	동시에	수정하고	테스트해
  야	할	수도	있다.
  ᆟ약한	기반	클래스	문제는	ᇊ슐회൐	약화시키고	결합도൐	높인다.	싱속은	자식	클래스가	부모	클래스
  의	구현	세부사힝에	의존하도ഛ	만들기	때문에	ᇊ슐회൐	약화시킨다[Snyder86].	이것이	싱속이	위험
  한	이유인	동시에	우൘가	싱속을	피해야	히는	첫	번째	이유다.
  객체൐	사용하는	이유는	구현과	관ഏ된	세부시힝을	퍼블൙	인터페이스	뒤ച	ᇊ슐화할	수	있기	때문이
  다.	ᇊ슐회는	변경에	의한	피급효괴൐	제어할	수	있기	때문에	갌가	있다.	객체는	변경될지도	모്는
  불안정한	요소൐	ᇊ슐회함으ച써	피급효과൐	걱	정하지	않고도	자유ട게	내부൐	변경	할	수	있다.
  안타깝게도	싱속을	시용하면	부모	클래스의	퍼블൙	인터페이스가	아닌	구현을	변경하더라도	자식	클래
  스가	영향을	받기	쉬워진다.	싱속	곏의	상위에	윐한	클래스에	가해지는	직은	변경만으ച도	싱속	계
  ᆲ에	속한	모든	지손들이	급격하게	요동ᆷ	수	있다.
* 불필요한	인터페이스	상속	문제
  * 상속을위한경고2
    * 싱속받은	부모	클래스의	메서드가자식	클래스의	내부	구조에	대한	귩을	깨트릴	수있댜
  * 5tack과	PropertieS의	예는	퍼블൙	인터페이스에	대한	고഍	없이	단순히	ᇬ드	재시용을	위해	상속을	이
    용히는	것이	얼마나	위험한지൐	잘	보여준다.	객체지향의	핵심은	객체들의	협	എ이다.	단순히	ᇬ드൐	재
    사용하기	위해	불필요한	오퍼അ이션이	인터	페이스에	스며들도ഛ	방ᆳ해서는	안	된다.
* 메서드	오버라이딩의	오직용	문제
  * InstrumentedHash5et addAll 메서드
  * 상속을 위한 경고3
    * 자식	 클래스가	 부모	 클래스의	 메서드൐	 오버라이딩할	 경우	 부모	 클래스가	 자신의	 메서드൐	 사용하는	 방법에	 자식
      클래스가결힙될수있댜	 
  * 설계는	트അ이드오프	활동이	라는	사실을	기	억하라.	싱속은	ᇬ드	재사용을	위해	ᇊ슐회൐	희생한다.	완
    벽한	ᇊ슐회൐	원한다면	ᇬ드	재사용을	포기하거나	싱속	이외의	다൏	방법을	사용해야	한다.
* 부모	클래스와	자식	클래스의	동시	수정	문제
  * 결합도란	디൏	대상에	대해	알고	있는	지식의	양이다.	싱속은	기본적으ച	부모	클래스의	구현을	재사
    용한다는	기본	전제൐	띠്기	때문에	자식	클래스가	부모	클래스의	내부에	대해	속속들이	일도ഛ	강요
    한다.	따라서	ᇬ드	재시용을	위한	상속은	부모	클래스와	자식	클래스൐	강하게	결합시키기	때문에	함께
    수정해야	하는	싱황	역시	빈번하게	발생할	수밖에	없는	것이다.
  * 상 속 을 위 한 경 고 4	 
    * 클래스൐	상속하면	결합도ച	인해	자식	클래스와	부모	클래스의	구현을	영원히	변경하지	않거나.	자식	클래스와	부모
      클래스൐	동시에	변경하거나	둘	중	하나൐	선택할	수밖에	없다.

### Phone 다시 살펴보기
* 추싱화에	의존하자
  * .	이	문제൐	해결하는	가장	일반적인	방법은	자식	클래스가	부모	클
    래스의	구현이	아닌	추싱화에	의존하도ഛ	만드는	것이다.	정확하게	밀하면	부모	클래스와	자식	클래스
    모두	추싱회에	의존하도ഛ	수정해야	한다.
  * 개인적으ച	ᇬ드	중복을	제거하기	위해	싱속을	도입할	때	띠്는	두	가지	원ᆴ이	있다
    ◎	두	메서드가	유人后卜게	보인다면	윳m	I점을	에서드ച	추출하೶	에서드	추출을	통해	두	메서드൐	동일한	형태ച	보이도ഛ	만
    돌수있대FeathersO41
    .	부모	클래스의	ᇬ드൐	하위ച	내൘지	말고	자식	클래스의	ᇬ드൐	상위ച	올഍라.	부모	클래스의	구체적인	메서드൐	자식
    클래스ച	내൘는	것보다	자식	클래스의	추싱적인	메서드൐	부모	클래스ച	올൘는	것이	재사용성과	응집도	ᆬ면에서	더	뛰
    어난결괴൐얻을수있대Metzl21
* ᆳ이൐	메서드ച	추출융尺卜
  * 기장	먼저	할	일은	중복	ᇬ드	인에서	차이점을	별도의	메서드ച	추출하는	것이다.	이것은	흔히	말히는
    “변히는	것으ച부터	변하지	않는	것을	분൘하라’,	또는	‘‘변히는	부분을	찾고	이൐	ᇊ슐회하라'൘는	조
    언을	머I서드	수준에서	적용한	것이다
  * 먼저	할	일은	두	클래스의	메서드에서	디൏	부분을	별도의	메서드ച	추출히는	것이다.	이 빈시	일	릴는	구	글메스뵉	예셔느oll시	댜든	무문늘	별도의	메서드ച	주줄하는	것이다
* 중복	ᇬ드൐	부모	클래스ച	올഍라
  * 부모	클래스൐	추가히자.	목표는	모든	클래스물기	추싱회에	의존하도ഛ	만드는	것이기	때문에	이	클래
    스는	추상	클래스ച	구현히는	것이	적합할	것이다.	
  * .	공통	ᇬ드൐	옮길	때	인
    스턴스	변수보다	메서드൐	먼저	이동시키는	게	편한데,	메서드൐	옮기고	나면	그	메서드에	필요한	메서
    드나	인스턴스	변수가	무엇인지൐	ᇖ파일	에೻൐	통해	지동으ച	알	수	있기	때문이다.	ᇖ파일	에೻൐
    비탕으ച	메서드와	인스턴스	변수൐	이동시키면	불필요한	부분은	지식	클래스에	둔	채ച	부모	클래스
    에	꼭	필요한	ᇬ드만	이동시	킬	수	있다.
  * ‘위ച	올൘기.	전೷은	실패했더라도	수정하기	쉬운	문제൐	발생시킨다.	문제는	쉽게	찾을	수	있고	쉽게	곰	수
    있다.	추싱회하지	않고	배먹은	ᇬ드가	있더라도	하위	클래스가	해당	행동을	필요ച	할	때가	오면	이	문제는	바
    ച	눈에	띈다.	모든	하위	클래스가	이	행동을	할	수	있게	만들഍면	여೻	개의	중복	ᇬ드൐	양뺘}거나	이	행동을
    상위	클래스ച	올൘는	수밖에	없다.	가장	초보적인	프ച그래머라도	중복	ᇬ_드൐	양뺘}지	말라고	배웠기	때문에
    나젊l	누가	이	애플൘ᇛ이션을	괸൘하든	이	문제는	쉽게	눈에	띈다.	위ച	올൘기에서	실수하더라도	추싱화벌	ᇬ
    드는	눈에	띄고	결국	상위	클래스ച	올഍지면서	ᇬ_드의	품질이	높아진다.	..	.	햐지만	이	൘빽터링을	빈대	방향으ച
    진행한E	佃	,	다시	밀해	구체적인	구현을	아래ച	내൘는	방식으ച	현재	클래스൐	구체	클래스에서	추상	클래스ച
    변경하഍	한다면	작은	실수	한	번으ച도	구체적인	행동을	상위	클래스에	남겨	놓게	된다[
* 추상화가 핵심이다
  * 사실	부모	클래스	역시	자신의	내부에	구현된	추상	메서드൐	호출하기	때문에	추상화에	의존한다
    고	말할	수	있다.	의존성	역전	원ᆴ도	준수하는데,	
  * 지금까지	실펴본	모든	장점은	클래스들이	추싱회에	의존하기	때문에	얻어지는	장점이다.	싱속	곏이
    ᇬ드൐	진화KI키는	데	걸림돌이	된다면	추싱회൐	책}내고	싱속	곏	안의	클래스들이	그	추싱회에
    의존히도ഛ	ᇬ드൐	൘팩터링하라.	차이점을	메서드ച	추출하고	공통적인	부분은	부모	클래스ച	이동
    하	라
* 클래스൘는	도구는	메서드뿐만	아니라	인스턴스	변수도	함께	포힘한다.	따라서	클래스	시cI의	싱속은
  자식	클래스가	부모	클래스가	구현한	행동뿐만	이ᇇ-l라	인스턴스	변수에	대해서도	결합되게	만든다.
  인스턴스	변수의	목ഛ이	변하지	않는	싱횡에서	객체의	행동만	변경된다면	싱속	곏에	속한	각	클래스
  들을	독립적으ച	진회시킬	수	있다.	하지만	인스턴스	변수가	추가되는	경우는	디്다.	자식	클래스는
  자신의	인스턴스൐	생성할	때	부모	클래스에	정의된	인스턴스	변수൐	초기회해야	하기	때문에	자연스
  ഀ게	부모	클래스에	추가된	인스턴스	변수는	지식	클래스의	초기화	ച직에	영향을	밄게	된다.	결과적
  으ച	책임을	이무൘	잘	분൘하더൘도	인스턴스	변수의	추기는	종종	싱속	곏	전반에	걸ᆵ	변경을	유발
  한다.
* 하지만	인스턴스	초기화	ച직을	변경히는	것이	두	클래스에	동일한	세금	계산	ᇬ드൐	중복시키는	것보
  디는	현명한	선택이다.	8징을	주의깊게	읽었다면	객체	생성	ച직이	변경됐을	때	영향을	받는	부분을	최
  소회하기	위해	노എ해야	한디는	사실을	잘	일고	았을	것이다.	객체	생성	ച직의	변경에	유연하게	대응
  할	수	있는	다양한	방법이	존재한다.	따라서	객체	생성	ച직에	대한	변경을	막기보디는	핵심	ച직의	중
  복을	믹아라.	핵심	ച직은	한	곳에	모아	놓고	조심스ഀ게	ᇊ슐화해야	한다.	그൘고	공통적인	핵심	ച직
  은	최대한	추싱회해야	한다
* 지금까지	살펴본	것처೿	상속으ച	인한	클래스	사이의	결합을	피할	수	있는	방법은	없다.	싱속은	어떤
  빙식으ച든	부모	클래스와	지식	클래스൐	결합시킨다.	메서드	구현에	대한	결힘은	추상	메서드൐	추가
  함으ച써	어느	정도	완화할	수	있지만	인스턴스	변수에	대한	짐재적인	결합을	제거할	수	있는	방법은
  없다.	우൘가	원히는	것은	행동을	변경하기	위해	인스틴스	변수൐	추기하더൘도	싱속	곏	전체에	걸쳐
  부직용이	퍼지지	않게	믹는	것이다.
### 차이에 의한 프로그래밍
* 지금까지	살펴본	것처	೿	싱속을	사용하면	이	미	존재하는	클래스의	ᇬ드൐	기반으ച	다൏	부분을	구현
  함으ച써	새ച운	기능을	쉽고	빠്게	추가할	수	있다.	싱속이	강എ한	이유는	익숙한	개념을	이용해서
  새ച운	개념을	쉽고	빠്게	추가할	수	있기	때문이다.
  이처೿	기존	ᇬ드와	다൏	부분만을	추가함으ച써	애플൘ᇛ이션의	기능을	확장하는	방법을	차이에	의
  한	프ച그래밍(programming	by	difrbrence)[Fe겐thers	2004]이라고	부൏다.	싱속을	이용하면	이미
  존재히는	클래스의	ᇬ드൐	쉽게	재시용할	수	있기	때문에	애플൘ᇛ이션의	점진적인	정의(increment첸l
  definition)	가	가능해	진다[ra	iv겐	lsaa	ri961
  차이에	의한	프ച그래밍의	목표는	중복	ᇬ드൐	제거하고	ᇬ드൐	재시용하는	것이다.	사실	중복	ᇬ드	제
  거와	ᇬ드	재사용은	동일한	행동을	가൘키는	서ച	디൏	단어다.	중복을	제거하기	위해서는	ᇬ드൐	재사
  용	가능한	단위ച	분해하고	재구성해야	한다.	ᇬ드൐	재시용하기	위해서는	중복	ᇬ드൐	제거해서	하나
  의	모듈ച	모아야	한다.	프ച그래밍의	세계에서	중복	ᇬ드는	악의	근원이다.	따라서	중복	ᇬ드൐	제거
  하기	위해	최대한	ᇬ드൐	재시용해야	한다.
  ᇬ드൐	재사용히는	것은	단순히	문x튼	타이핑하는	수고൐	덜어주는	수준의	문제가	아니다.	재사용	가
  능한	ᇬ드란	심각한	버그가	존재하지	않는	ᇬ드다.	따라서	ᇬ드൐	재사용하면	ᇬ드의	품질은	유지하면
  서도	ᇬ드൐	작성히는	노എ과	테스트는	줄일	수	있다.
  객체지향	세계에서	중복	ᇬ드൐	제거하고	ᇬ드൐	재사용할	수	있는	가장	유명한	방법은	싱속이다.	기본
  아이디어는	간단하다.	여೻	클래스에	공통적으ച	포함돼	있는	중복	ᇬ드൐	하나의	클래스ച	모은다.	원
  래	클래스들에서	중복	ᇬ드൐	제거한	후	중복	ᇬ드가	옮겨진	클래스൐	상속	관계ച	연결한다.	ᇬ드൐
  ᇖ파일하면	무대	뒤에서	마법이	일어나	싱속	관계ച	연결된	ᇬ드들이	하나ച	합쳐진다.	따라서	상속을
  사용하면	여	೻	클래스	시이	에서	재시용	가능한	ᇬ드൐	하나의	클래스	인으ച	모을	수	있다.
* 싱속은	강എ한	도구다.	싱속을	이용하면	새ച운	기능을	추가하기	위해	직접	구현해야	하는	ᇬ드의	양을
  최소회할	수	있다.	싱속은	너무나도	매എ적이기	때문에	객체지향	프ച그래밍에	갓	입문한	프ച그래머
  들은	상속의	매എ에	도ᆟ된	나머지	모든	설계에	싱속을	적용하഍고	시도한다.
  시간이	흐്고	객체지향에	대한	이해가	깊어지면서	사람들은	ᇬ드൐	재사용하기	위해	맹목적으ച	싱속
  을	시용하는	것이	위험하다는	사실을	깨닫기	시작했다.	싱속이	ᇬ드	재시용이൘는	ᆬ면에서	매우	강എ
  한	도구인	것은	사실이지만	강എ한	만큼	잘못	사용할	경우에	돌아오는	피해	역시	크다는	사실을	뼈저൘
  게	경험한	것이다.	싱속의	오용과	남용은	애플൘ᇛ이션을	이해하고	확장하기	어ഒ게	만든다.	정말ച	필
  요한	경우에만	상속을	사용하라.
  싱속은	ᇬ드	재사용과	관ഏ된	대부분의	경우에	우아한	해결	방법이	아니다.	객체지향에	능숙한	개발자
  들은	싱속의	단점을	피하면서도	ᇬ드൐	재시용할	수	있는	더	좋은	방법이	있디는	사실을	알고	있다.	바
  ച	합성	이	다