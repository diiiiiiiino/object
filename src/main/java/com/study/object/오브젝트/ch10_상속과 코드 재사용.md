# Chapter 10. 상속과 코드 재사용

---

## 1. 상속과 중복 코드

### 1.1 DRY 원칙

> **DRY (Don't Repeat Yourself)**: 동일한 지식을 중복하지 말라

#### 중복 코드가 문제인 이유

- **변경을 방해한다**: 프로그램의 본질은 비즈니스 지식을 코드로 변환하는 것인데, 이 지식은 항상 변한다
- **수정 노력이 몇 배로 증가한다**
  - 어떤 코드가 중복인지 찾아야 한다
  - 찾아낸 모든 코드를 일관되게 수정해야 한다
  - 모든 중복 코드를 개별적으로 테스트해야 한다
- **시스템을 공황상태로 몰아넣을 수 있다**

#### 중복 여부를 판단하는 기준

| 기준 | 설명 |
|------|------|
| ✅ 변경 | 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 중복 |
| ❌ 모양 | 코드 모양이 유사한 것은 단지 중복의 징후일 뿐 |

**핵심**: 중복 여부를 결정하는 기준은 코드가 **변경에 반응하는 방식**이다.

#### 관련 원칙들

- **DRY 원칙** (Don't Repeat Yourself) - 앤드류 헌트, 데이비드 토마스
- **Once and Only Once 원칙** [Beck96]
- **Single-Point Control 원칙** [Glass06b]

---

### 1.2 중복과 변경

```
중복 코드 → 새로운 중복 코드를 부름 → 일관성 붕괴 위험 → 버그 증가 → 변경 속도 저하
```

- 중복 코드가 늘어날수록 애플리케이션은 **변경에 취약**해진다
- 민첩하게 변경하려면 중복 코드를 **추가하는 대신 제거**해야 한다
- 기회가 생길 때마다 코드를 **DRY하게** 만들어라

---

### 1.3 타입 코드 사용하기

두 클래스 사이의 중복 코드를 제거하는 방법 중 하나는 **클래스를 하나로 합치는 것**이다.

```java
// 타입 코드로 요금제 구분
Phone + NightlyDiscountPhone → Phone (with type code)
```

⚠️ **문제점**: 타입 코드를 사용하는 클래스는 **낮은 응집도**와 **높은 결합도** 문제에 시달린다.

---

### 1.4 상속을 이용해서 중복 코드 제거하기

#### 상속의 기본 아이디어

> 이미 존재하는 클래스와 유사한 클래스가 필요하다면, 코드를 복사하지 말고 **상속을 이용해 코드를 재사용**하라.

#### 상속의 문제점

- 깊은 상속 계층의 계단을 내려올 때마다 **이해하기 어려운 가정**과 마주하게 된다
- 부모 클래스 개발자의 **가정이나 추론 과정**을 정확하게 이해해야 한다
- 자식 클래스 작성자가 부모 클래스의 **구현 방법에 대한 정확한 지식**을 가져야 한다

#### 결론

> ⚠️ **상속은 결합도를 높인다.**
>
> 부모-자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.

---

### 🚨 상속을 위한 경고 1

> **super 참조를 이용해 부모 클래스의 메서드를 직접 호출하면 두 클래스는 강하게 결합된다.**
>
> super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

---

## 2. 취약한 기반 클래스 문제

### 2.1 개념

> **취약한 기반 클래스 문제 (Fragile Base Class Problem)**
>
> 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상 [Holub04]

- 상속을 사용한다면 **피할 수 없는** 객체지향 프로그래밍의 근본적인 취약성
- 상속이라는 문맥 안에서 **결합도가 초래하는 문제점**을 가리키는 용어

### 2.2 왜 기반 클래스는 '취약'한가?

```
겉으로 안전해 보이는 기반 클래스 수정
    ↓
새로운 행동이 파생 클래스에게 상속
    ↓
파생 클래스의 잘못된 동작 초래 가능
```

**확인해야 할 것들:**
- 모든 파생 클래스들을 살펴봐야 한다
- 테스트까지 해야 한다
- 기반/파생 클래스를 사용하는 모든 코드가 영향받지 않았는지 점검해야 한다

### 2.3 상속과 결합도

| 상속의 장점 | 상속의 단점 |
|------------|------------|
| 자식 클래스를 점진적으로 추가해서 기능 확장 용이 | 높은 결합도로 인해 부모 클래스 개선이 어려움 |
| | 최악의 경우 모든 자식 클래스를 동시에 수정/테스트 필요 |

### 2.4 상속과 캡슐화

> **취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다.**

- 상속은 자식 클래스가 부모 클래스의 **구현 세부사항에 의존**하도록 만든다 [Snyder86]
- 이것이 상속이 위험한 이유이자 **상속을 피해야 하는 첫 번째 이유**다

#### 캡슐화의 가치

```
객체 사용 이유: 구현 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화
    ↓
캡슐화의 가치: 변경에 의한 파급효과 제어
    ↓
결과: 자유롭게 내부 변경 가능
```

**But**, 상속을 사용하면:
- 퍼블릭 인터페이스가 아닌 **구현을 변경해도** 자식 클래스가 영향받음
- 상위 클래스의 **작은 변경**만으로도 모든 자손들이 급격하게 요동칠 수 있음

---

### 🚨 상속을 위한 경고 2: 불필요한 인터페이스 상속 문제

> **상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.**

#### 예시: Stack과 Properties

- 퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위해 상속을 이용하는 것은 **위험**하다
- 객체지향의 핵심은 **객체들의 협력**이다
- 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안 된다

---

### 🚨 상속을 위한 경고 3: 메서드 오버라이딩의 오작용 문제

> **자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우, 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.**

#### 예시: InstrumentedHashSet의 addAll 메서드

#### 트레이드오프

| 선택 | 결과 |
|------|------|
| 상속 사용 | 코드 재사용 ✅ / 캡슐화 희생 ❌ |
| 완벽한 캡슐화 | 코드 재사용 포기 또는 다른 방법 사용 |

---

### 🚨 상속을 위한 경고 4: 부모-자식 클래스의 동시 수정 문제

> **클래스를 상속하면 결합도로 인해:**
> - 자식/부모 클래스의 구현을 **영원히 변경하지 않거나**
> - 자식/부모 클래스를 **동시에 변경하거나**
>
> 둘 중 하나를 선택할 수밖에 없다.

#### 왜 동시 수정이 필요한가?

- **결합도** = 다른 대상에 대해 알고 있는 지식의 양
- 상속은 자식 클래스가 부모 클래스의 내부에 대해 **속속들이 알도록 강요**한다
- 따라서 함께 수정해야 하는 상황이 **빈번하게 발생**한다

---

## 3. Phone 다시 살펴보기

### 3.1 추상화에 의존하자

#### 문제 해결 방법

> 자식 클래스가 부모 클래스의 **구현이 아닌 추상화에 의존**하도록 만든다.
>
> 정확하게 말하면, **부모 클래스와 자식 클래스 모두** 추상화에 의존하도록 수정해야 한다.

#### 두 가지 원칙

| 원칙 | 설명 |
|------|------|
| **차이점을 메서드로 추출** | 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라 [Feathers04] |
| **코드를 상위로 올려라** | 부모 클래스의 코드를 하위로 내리지 말고, 자식 클래스의 코드를 상위로 올려라 [Metz12] |

> 💡 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다,
> 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 **재사용성과 응집도** 측면에서 더 뛰어나다.

---

### 3.2 차이를 메서드로 추출하라

> **"변하는 것으로부터 변하지 않는 것을 분리하라"**
>
> **"변하는 부분을 찾고 이를 캡슐화하라"**

이 조언을 **메서드 수준**에서 적용한 것이다.

**할 일**: 두 클래스의 메서드에서 **다른 부분**을 별도의 메서드로 추출

---

### 3.3 중복 코드를 부모 클래스로 올려라

#### 목표

모든 클래스들이 **추상화에 의존**하도록 만드는 것

→ 부모 클래스는 **추상 클래스**로 구현하는 것이 적합

#### 이동 순서

```
1. 메서드를 먼저 이동
    ↓
2. 컴파일 에러 발생
    ↓
3. 필요한 메서드/인스턴스 변수 파악
    ↓
4. 필요한 것만 이동
```

> 💡 인스턴스 변수보다 **메서드를 먼저 이동**시키면, 컴파일 에러를 통해 필요한 것을 자동으로 알 수 있다.

#### '위로 올리기' vs '아래로 내리기'

| 전략 | 실수했을 때 |
|------|------------|
| **위로 올리기** ✅ | 문제를 쉽게 찾고 쉽게 고칠 수 있다 |
| **아래로 내리기** ❌ | 작은 실수로도 구체적인 행동이 상위 클래스에 남게 된다 |

---

### 3.4 추상화가 핵심이다

> 부모 클래스 역시 자신의 내부에 구현된 **추상 메서드를 호출**하기 때문에 추상화에 의존한다.
>
> → **의존성 역전 원칙(DIP)** 준수

#### 핵심 메시지

상속 계층이 코드 진화에 걸림돌이 된다면:

```
1. 추상화를 찾아내라
2. 상속 계층 안의 클래스들이 그 추상화에 의존하도록 리팩터링하라
3. 차이점을 메서드로 추출하라
4. 공통적인 부분은 부모 클래스로 이동하라
```

#### 인스턴스 변수의 문제

| 상황 | 결과 |
|------|------|
| 인스턴스 변수 목록 불변 + 행동만 변경 | 각 클래스를 독립적으로 진화 가능 ✅ |
| 인스턴스 변수 추가 | 상속 계층 전반에 걸친 변경 유발 ❌ |

**이유**: 자식 클래스는 인스턴스 생성 시 부모 클래스의 인스턴스 변수를 초기화해야 함

#### 그럼에도 불구하고...

> 인스턴스 초기화 로직을 변경하는 것이 두 클래스에 **동일한 핵심 로직을 중복**시키는 것보다 현명하다.

- 객체 생성 로직 변경에 유연하게 대응할 수 있는 다양한 방법이 존재한다 (8장 참고)
- **핵심 로직의 중복을 막아라**
- 핵심 로직은 한 곳에 모아 놓고 **조심스럽게 캡슐화**해야 한다
- 공통적인 핵심 로직은 **최대한 추상화**해야 한다

#### 상속의 한계

- 상속으로 인한 클래스 사이의 결합을 **완전히 피할 수는 없다**
- **메서드 구현**에 대한 결합: 추상 메서드로 어느 정도 완화 가능
- **인스턴스 변수**에 대한 잠재적 결합: 제거 방법 없음

> 🎯 **목표**: 인스턴스 변수를 추가하더라도 상속 계층 전체에 걸쳐 **부작용이 퍼지지 않게** 막는 것

---

## 4. 차이에 의한 프로그래밍

### 4.1 개념

> **차이에 의한 프로그래밍 (Programming by Difference)** [Feathers04]
>
> 기존 코드와 **다른 부분만을 추가**함으로써 애플리케이션의 기능을 확장하는 방법

```
이미 존재하는 클래스의 코드
    + 다른 부분 구현
    = 새로운 기능을 쉽고 빠르게 추가
```

→ 애플리케이션의 **점진적인 정의(incremental definition)** 가 가능해진다 [Taivalsaari96]

---

### 4.2 목표

> **중복 코드를 제거**하고 **코드를 재사용**하는 것

| 중복 제거 | 코드 재사용 |
|-----------|------------|
| 코드를 재사용 가능한 단위로 분해하고 재구성 | 중복 코드를 제거해서 하나의 모듈로 모음 |

**두 개념은 동일한 행동을 가리키는 서로 다른 단어다.**

---

### 4.3 코드 재사용의 가치

> 재사용 가능한 코드란 **심각한 버그가 존재하지 않는 코드**다.

코드를 재사용하면:
- ✅ 코드의 품질 유지
- ✅ 코드 작성 노력 감소
- ✅ 테스트 부담 감소

---

### 4.4 상속을 통한 코드 재사용

#### 기본 아이디어

```
여러 클래스의 중복 코드
    ↓ 하나의 클래스로 모음
원래 클래스들에서 중복 코드 제거
    ↓ 상속 관계로 연결
컴파일 시 코드들이 하나로 합쳐짐
```

#### 상속의 매력과 위험

| 장점 | 위험 |
|------|------|
| 새로운 기능 추가를 위한 코드 양 최소화 | 맹목적 사용 시 오용과 남용 |
| 익숙한 개념으로 새로운 개념 빠르게 추가 | 애플리케이션 이해와 확장이 어려워짐 |

---

### 4.5 결론

> ⚠️ **정말로 필요한 경우에만 상속을 사용하라.**

상속은 코드 재사용과 관련된 대부분의 경우에 **우아한 해결 방법이 아니다**.

객체지향에 능숙한 개발자들은 상속의 단점을 피하면서도 코드를 재사용할 수 있는 더 좋은 방법을 알고 있다.

> 🎯 **바로 합성(Composition)이다.**

---

## 📌 핵심 요약

### 상속을 위한 4가지 경고

| # | 경고 |
|---|------|
| 1 | super 참조로 부모 메서드 직접 호출 → 강한 결합 |
| 2 | 상속받은 메서드가 자식의 내부 구조 규칙을 깨트릴 수 있음 |
| 3 | 메서드 오버라이딩 시 부모의 메서드 사용 방법에 결합될 수 있음 |
| 4 | 상속하면 영원히 변경 안 하거나 동시에 변경해야 함 |

### 해결 방법

1. **추상화에 의존**하도록 만들어라
2. **차이점을 메서드로 추출**하라
3. 코드를 **상위로 올려라** (하위로 내리지 말고)
4. **핵심 로직의 중복**을 막아라
5. 정말 필요한 경우가 아니면 **합성을 사용**하라