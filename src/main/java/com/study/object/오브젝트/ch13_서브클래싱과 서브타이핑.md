* 상속의 첫 번째 용도는 타입 계층을 구현하는 것이다. 
타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다. <br>
타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화이고 자식 클래스는 부모 클래스의 특수화다.
* 상속의 두 번째 용도는 코드 재사용이다. <br>
상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있는 마법의 주문과도 같다.
상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다.
하지만 재사용을 위해 상속을 사요할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다.
* 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다.
타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.
* 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.
* 객체지향 프로그래밍과 객체기반 프로그래밍
  * 객체기반 프로그래밍이랑 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식을 가리킨다.
  * 객체지향 프로그래밍 역시 객체기반 프로그래밍의 한 종류다.
  * 객체지향은 객체들을 조합해서 개발하지만 상속과 다형성을 지원한다는 점에서 객체기반 프로그래밍과 차별화된다.

## 타입
### 개념 관점의 타입
* 개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다.

### 프로그래밍 언어 관점의 타입
* 프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다.
* 하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합을 취급한다.
* 비트 자체에는 타입이라는 개념이 존재하지 않는다.
* 두 가지 목적을 위해 사용된다.
  * 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
  * 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.

### 객체지향 패러다임 관점의 타입
* 객체지향 프로그래밍에서 타입을 정희하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다.
* 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
* 객체에게 중요한 것은 속성이 아니라 행동이라는 사실이다.
* 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르다면 이들은 서로 다른 타입으로 분류된다.
* 반대로 어떤 객체들이 내부 상태는 다르지만 동일한 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류된다.

## 타입 계층
### 타입 사이의 포함관계
* 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입이라고 부르고 더 특수한 타입을 서브타입이라고 부른다.

### 객체지향 프로그래밍과 타입 계층
* 특수한 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
* 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넒은 의미로 정의한 것이다.
* 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.
* 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 퍼블릭 인터페이스라는 사실만 알고 있어도 무방하다.
* 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다. (이 사실이 이번장의 핵심이다.)

## 서블클래싱과 서브타이핑
### 언제 상속을 사용해야 하는가?
* 마틴 오더스키는 다음과 같은 질문을 해보고 두 질문에 모두 예라고 답할 수 있는 경우에만 상속을 사용하라고 조언한다.
  * 상속 관계가 is-a 관계를 모델링하는가?
    * 이것은 애플리케이션을 구성하는 어휘에 대한 우리의 관점에 기반한다. 일반적으로 자식클래스는 부모 클래스다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
  * 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    * 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야한다. 이를 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.

### is-a 관계
* 어떤 두 대상을 언어적으로 is-a라고 표현할 수 있더라도 일단을 상속을 사용할 예비 후보 정도로만 생각하라.
* 애플리케이션 안에서 두 가지 후보 개념이 어떤 방식으로 사용되고 협력하는지 살펴본 후에 상속의 적용 여부를 결정해도 늦지 않다.
* 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
* 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다.

### 행동 호환성
* 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.
* 펭귄과 새
* 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이라는 것이다.
* 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.
* instanceof는 new 연산자와 마찬가지로 구체적인 클래스에 대한 결합도를 높인다. 개방-폐쇄 원칙을 위반한다.

### 클라이언트의 기대에 따라 계층 분리하기
* 인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다
* 하나의 클라이언트가 오직 fly메시지만 전송하기를 원한다면 이 클라이언트에게는 fly메시지만 보여야 한다.
* 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙이라고 부른다.
  * 비대한 인터페이스의 단점을 해결한다.
  * 비대한 인터페이스를 가지는 클래스는 응집성이 없는 인터페이스를 가지는 클래스다.
  * 즉, 이런 클래스의 인터페이스는 메서드의 그룹으로 분해될 수 있고, 각 그룹을 가기 다른 클라이언트 집합을 지원한다.
  * 한 클라이언트가 비대한 클래스에 변경을 가하면, 나머지 모든 클래스가 영향을 받게 된다.
  * 분리하면 호출하지 않는 메서드에 대한 클라이언트의 의존성을 끊고 클라이언트가 서로에 대해 독립적이 되게 만들 수 있다.
* 최고의 설계는 제작하려는 소프트웨어 시스템이 기대하는 바에 따라 달라진다.
* 설계가 꼭 현실 세계를 반영할 필요는 없다는 것이다.
* 중요한 것은 설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에게 요구하는 행동이다.

### 서브클래싱과 서브타이핑
* 서브클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킨다.
  * 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
  구현 상속 또는 클래스 상속이라고 부른다.
* 서브타이핑 : 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다.
  * 자식클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
  인터페이스 상속이라고 부른다.
* 둘을 나누는 기준은 상속을 사용하는 목적이다.
* 행동 호환성과 대체 가능성은 올바른 상속 관계를 구축하기 위해 따라야 할 지침이라고 할 수 있다.

## 리스코프 치환 원칙
* 올바른 상속 관계의 특징을 정의하기 위해 리스코프 치환 원칙을 발표했다.
* 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다는 것으로 클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다는 것이다.
* 정사각형과 직사각형은 서브 클래싱 관계

### 클라이언트와 대체 가능성
* 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.
* 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다
* 어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능하다는 것이다.
* 행동 호환성과 리스코프 치환 원칙에서 한가지만 기억해야 한다면 이것을 기억하라 대체 가능성을 결정하는 것은 클라이언트다.

### is-a 관계 다시 살펴보기
* 일반적으로 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게 될 확률이 높다.
* 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다. 서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 말할 수 없다.
* 클라이언트 입장에서 is-a 관계다라는 문장이 성립해야 한다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다.
* 클라이언트의 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다는 것이다.
* 리스코프 치환 원칙을 따르는 설계는 유연할뿐만 아니라 확장성이 높다.
* 새로운 자식 클래스를 추가하더라도 클라이언트의 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.

### 계약에 의한 설계와 서브타이핑
* 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.

### 서브타입과 계약
* 계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것이다.
* 서브타입에 더 강력한 사전조건을 정의할 수 없다.
* 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
* 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
* 서브타입에 더 약한 사후조건을 정의할 수 없다.


