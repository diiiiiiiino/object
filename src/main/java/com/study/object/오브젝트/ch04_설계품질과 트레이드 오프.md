* 역할, 책임, 협력 중에서 가장 중요한 것은 책임이다.
 객체들이 수행할 책임이 적적하게 할당되지 못한 상황에서는 원활한 협력도 기대할 수 없을 것이다. <br>
 역할은 책임의 집합이기 때문에 책임 적절하지 못하면 역시 협력과 조화를 이루지 못한다. <br>
 결국 책임 객체지향 애플리케이션 전체의 품질을 결정하는 것이다.
* 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다. <br>
이 정의에는 두 가지 관점이 섞여있다.<br>
  * 첫번째. 객체지향 설계의 핵심은 책임이다.
  * 두번째. 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다.
* 설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다.
* 훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.
  * 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다.
* 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙
  * 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다.
  * 객체의 책임에 초점을 맞추는 것이다.
    * 객체를 데이터의 집합으로 보면 내부 구현을 퍼블릭 인터페이스에 노출시키기 때문에 설계가 변경에 취약해진다.
* 책임은 객체의 상태에서 행동으로, 나아가 객체와 객체 사이의 상호작용으로 설계 중심을 이동시키고, 결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반을 제공한다.
* 객체지향 설계에서는 객체를 분할하는 방법이 두가지 있다.
  * 상태로 분할
  * 책임으로 분할
* 훌륭한 객체 지향 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다. 이유는 변경과 관련이 있다.
* 객체의 상태는 구현에 속한다.
* 구현은 불안정하기 때문에 변하기 쉽다.
* 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게 된다. <br>
따라서 데이터에 초점을 맞추는 설계는 변경에 취약할 수 밖에 없다.
* 객체의 책임은 인터페이스에 속한다. 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. <br>
따라서 책임에 초점을 맞추면 상대적으로 변경에 안정적인 설계를 얻을 수 있게 된다.

### 데이터 중심 설계
* 데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중한다.
* 이 객체가 포함해야 하는 데이터는 무엇인가? 객체의 책임을 결정하기 전에 이런 질문의 반복에 휩쓸려 있다면 데이터 중심의 설계에 매몰돼 있을 확률이 높다.
* 객체의 종류를 저장하는 인스턴스 변수와 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수를 포함시키는 방식은 데이터 중심의 설계 안에서 흔히 볼 수 있는 패턴이다.
    ```
    public class Movie {
        private String title;
        private Duration runningTime;
        private Money fee;
        private List<DiscountCondition> discountConditions;
        
        private MovieType movieType;
        private Money discountAmount;
        private double discountPercent;
    }
    ```
  
### 설계 트레이드오프
* 캡슐화
  * 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.
  * 변경될 가능성이 높은 부분을 구현이라고 부른다.
  * 상대적으로 안정적인 부분을 인터페이스라고 부른다.
  * 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다.
  * 객체지향에서 가장 중요한 원리는 캡슐화다.
  * 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.
  * 변경의 관점에서 설계의 품질을 판단하기 위해 캡슐화를 기준으로 삼을 수 있다.
  * 변경될 수 있는 어떤 것이라도 캡슐화해야 한다. (이것이 객체지향 설계의 핵심이다.)
* 응집도와 결합도
  * 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.
    * 객체지향 관점에서 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.
  * 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타낸다.
    * 객체지향 관점에서 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.
  * 두 개념을 이해하기 위해서는 설계와 관련 있다
  * 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.
    * 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계
  * 응집도와 결합도는 변경과 관련된 것이다.
  * 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.
  * 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높다, 다수의 모듈이 함께 변경된다면 응집도가 낮은 것이다.
  * 변경의 관점에서 결합도란 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.
    * 다시 말해 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지를 나타낸다.
    * 결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.
  * 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.
    * 내부 구현을 변경했을 대 다른 모듈에 영향을 미치면 결합도가 높다, 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향이 미치는 경우는 결합도가 낮다.
  * 캡슐화의 정도가 응집도와 결합도에 영향을 미친다.
    * 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.

### 데이터 중심의 설계의 문제점
* 캡슐화 위반
  * 설계할때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다.
  * 추측에 의한 설계 전략
    * 객체가 사용될 문맥을 추측할 수 밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는것이다.
    * 객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을것이라는 막연한 추측을 기반으로 설계를 진행한다.
    * 결과적으로 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수 밖에 없는 것이다.
  ```
  public class DiscountCondition {
      private DiscountConditionType type;
      private int sequence;
      private DayOfWeek dayOfWeek;
      private LocalTime startTime;
      private LocalTime endTime;
      
      //내부에 DiscountConditionType을 포함하고 있다는 정보 역시 노출시킨다.
      public DiscountConditionType getType() {}
  
      //객체 내부에 DayOfWeek타입의 요일과 LocalTime 타입의 시간 정보가 인스턴스 변수로 포함돼 있다는 사실을 인터페이스를 통해 외부에 노출하고 있는 것이다.
      public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {}
  
      //객체 내부에 int 타입의 순번 정보를 포함하고 있음을 외부에 노출한다.
      public boolean isDiscountable(int sequence) {}
  }
  
  public class Movie {
      private String title;
      private Duration runningTime;
      private Money fee;
      private List<DiscountCondition> discountConditions;
  
      private MovieType movieType;
      private Money discountAmount;
      private double discountPercent;
  
      public MovieType getMovieType() {}
      // 아래 메서드도 캡슐화를 위한 한 메서드 들이다.
      // 내부 구현을 인터페이스에 노출시킨다. 할인 정책 노출, 할인 정책이 추가되거나 제거되면 이 메서드에 의존하는 모든 클라이언트가 영향을 받는다.
      public Money calculateAmountDiscountedFee() {}
      public Money calculatePercentDiscountedFee() {}
      public Money calculateNoneDiscountedFee() {}
  }
  ```
* 높은 결합도
  * 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다.
  * 더 나쁜 소식은 단지 객체의 내부 구현을 변경했음에도 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다는 것이다.
  * getter 메서드를 사용하는 것은 인스턴스 변수의 가시성을 private에서 public으로 변경하는 것과 거의 동일하다.
  * 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동칠 수 밖에 없다.
* 낮은 응집도
  * 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.
    * 어떤 코드를 수정한 후에 아무런 상관도 없더 코드에 문제가 발생하는 것은 모듈의 응집도가 낮을 때 발생하는 대표적인 증상이다.
  * 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.
  * 단일 책임 원칙의 책임은 변경의 이유라는 의미로 사용되었다.

### 자율적인 객체를 향해
* 캡슐화를 지켜라
  * 캡슐화는 설계의 제1원리다.
  * 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.
  * 속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다.
* 스스로 자신의 데이터를 책임지는 객체
  * 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다.
  * 객체는 단순한 데이터 제공자가 아니다.
  * 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.
  * 이 객체가 어떤 데이터를 포함해야 하는가? 라는 질문은 다음과 같은 두 개의 개별적인 질문으로 분리해야 한다.
    * 이 객체가 어떤 데이터를 포함해야 하는가
    * 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
    * 두 질문을 조합하면 객체의 내부 상태를 저장하는 방식과 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다. <br>
    다시 말해 새로운 데이터 타입을 만들 수 있는 것이다.

### 하지만 여전히 부족하다
* 내부 구현의 변경이 외부로 퍼져나가는 파급 효과는 캡슐화가 부족하다는 명백한 증거다.
* 캡슐화의 진정한 의미
  * 캡슐화가 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 가진다는 것을 잘 보여준다.
  * 사실 캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다.
  * 내부 속성을 외부로 부터 감추는 것은 **데이터 캡슐화**라고 불리는 캡슐화의 한 종류일 뿐이다.
  * 속성의 타입이건 할인 정책의 종류건 상관없이 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다.
  * 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다, 이것이 캡슐화라는 용어를 통해 말하고자 하는 진정한 의미다.

### 데이터 중심 설계의 문제점
* 데이터 중심의 설계가 변경에 취약한 이유는 두 가지다
  * 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
  * 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.
* 데이터를 처리하는 작업과 데이터를 같은 객체 안에 두더라도 데이터에 초점이 맞춰져 있다면 만족스러운 캡슐화를 얻기 어렵다.
* 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다. <br>
결과적으로 객체의 인터페이스는 구현을 캡슐화하는 데 실패하고 코드는 변경에 취약해진다.

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레인션을 정의하도록 만든다.
* 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.
* 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는가는 부가적인 문제다. 중요한 것은 객체가 다른 객체와 협력하는 방법이다.
* 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다. <br>
실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다. <br>
객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수밖에 없다.
  