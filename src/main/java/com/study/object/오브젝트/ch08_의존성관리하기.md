## 의존성 관리하기
### 의존성 이해하기
* 변경과 의존성
  * 어떤객체가협력하기위해디른객체를필요로할때두객체사이에의존성이존재하게된다.의존성 은실행시점과구현시점에서로디른의미를가진다.
  * 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다 
  * 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도
  * 함께 변경된다.
  * 이처럼 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체사이에의존성이존재한다고말한다.
  * 의존성은방향성을가지며힝상단방향이다
  * 두 요소 사이의 의존성은 의존되는 요소가 변경 될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다
  * 따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.
* 의존성 전이
  * 의존성은 함께 변경될 수 있는 >/능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다. 
  * 의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다. 
  * 의존성전이는변경에의해영향이널리전피될수도있디는경고일뿐이다.
  * 의존성은 전이될 수 있기 때문에 의존성의 종류를 직접 의존성(direct dependency)과 간접 의존성 (indirect dependency)으로 니누기도 한다. 직
    * 직접 의존성이란 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우울 가리킨다.
    * 간접 의존성이란 직접적인 관계는 존재하지 않 지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다
    * 여기서는 클래스를 예로 들어 설명했지만 변경과 관련이 있는 어떤 것에도 의존성이라는 개념을 적용 할수있다. 
    * 의존성의대싱은객체일수도있고모듈이나더큰규모의실행시스템일수도있다.
    * 하지만 의존성의본질은변하지않는다.의존성이란의존하고있는대상의변경에영향을받을수있는가 능성이다.
* 런타임 의존성과 컴파일타임 의존성
  * 런타임은간단하다.말그대로애플리케이션이실행되는시점을가리킨다.
  * 컴파일타임이란작성된코드를컴파일히는시점을가리키지만문맥에따라서는코드 그자체를가리키기도한다
  * 객체지향 애플리케이션에서 런타임의 주인공은 객체다. 따라서 런타임 의존성이 디루는 주제는 객체 사이의 의존성이다.
  * 반면 코드 관점에서 주인공은 클래스다. 따라서 컴파일타임 의존성이 다루는 주제 는 클래스 사이의 의존성이다.
  * 여기서 중요한 것은 런타임 의존성과 컴파일타임 의존성이 디를 수 있디는 것이다. 사실 유연하고 재사 용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.
  * 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적 인 클래스를 알아서는 안 된다. 
  * 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다. 
  * 클래스 가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자 체가 없어진다. 
  * 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.
* 컨텍스트 독립성
  * 클래스는자신과협력할객체의구체적인클래스에대해알아서는안된 다.
  * 구체적인 클래스를 알면 일수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.
  * 구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될 것인지를 구체적으로 명시하는것과같다
  * 클래스가특정한문맥에강하게결합될수록다른문맥에서사용하기는더어려워진다.
  * 클래스가사용 될특정한문맥에대해최소한의가정만으로이뤄져있다면다른문맥에서재사용하기가더수월해진 다. 이를 컨텍스트 독립성이라고 부른다.
  * 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다. 컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재시용될 수 있기 때문 이다. 결과적으로 설계는 더 유연해지고 변경에 탄력적으로 대응할 수 있게 될 것이다.
  * 시스템을 구성하는 객체가 컨텍스트 목립적이라면 해당 시스템은 변경하기 쉽다 여기서 컨텍스트 독립적이라 는말은각객체가해당객체를실행하는시스템에관해아무것도일지못한다는의미다.이렇게되면행위의 단위(객체)를 가지고 새로운 싱횡에 적용할 수 있다. ... 컨텍스트 독립성을 따르면 ⊂많한 컨텍스트에 적용할 수있는응집력있는객체를만들수있고객체구성빙법을재설정해서변경가능한시스템으로나아갈수있 다
* 의존성 해결하기
  * 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다
  * 이처럼 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이리고 부른다.
  * 의존성을 해결하기 위해서는 일반적으로 디음과 같은 세 가지 방법을 시용한다.
    * 객체를 생성하는 시점에 생성자를 통해 의존성 해결 
    * 객체 생성 후 5etter 메서드를 통해 의존성 해결 
      * setter 메서드를 이용하는 방식은 객체를 생성한 이후에도 의존히고 있는 대싱을 변경할 수 있는 가능 성을열어놓고싶은경우에유용히다
      * 단점은객체가생성된후에협력에필요한의존대싱을설정하기때문에객체를생 성하고의존대싱을설정하기전까지는객체의싱태가불완전할수있디는점이다.
      * 더좋은방법은생성자방식과Setter방식을혼합히는것이다.힝상객체를생성할때의존성을해결해 서 완전한 상태의 객체를 생성한 후, 필요에 따라 setter 메서드를 이용해 의존 대싱을 변경할 수 있게 할수있다.이방법은시스템의상태를안정적으로유지하면서도유연성을향상시킬수있기때문에 의존성 해결을 위해 가장 선호되는 방법이다.
    * 메서드인자를시용하는방식은협력대상에대해지속적으로의존관계를맺을필요없이메서드가실 행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나. 
      * 메서드가 실행될 때마다 의존 대상이 매 번 달라져야 하는 경우에 유용하다.
      * 하지만 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객 체 를인 자 로전 딜 하 고있 다 면생 성 자 를이 용 하 는방 식 이 나s e t t 메e r 서 드 를이 용 해의 존 성 을지 속 적
        으로 유지하는 방식으로 변경하는 것이 좋다.
* 유연한 설계
  * 의존성과 결합도
    * 객체지향 패러다임의 근간은 협력이다. 객체들은 협력을 통해 애플리케이션에 생명력을 불어넣는다. 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 한다. 
    * 이런 지식들이 객체 사이 의 의존성을 낳는다. 따라서 모든 의존성이 나쁜 것은 아니다. 의존성은 객체들의 협력을 가능하게 만 드는 매개체리는 관점에서는 바람직한 것이다. 하지만 의존성이 과하면 문제가 될 수 있다.
    * 문제는 의존성의 존재가 아니라 의존성의 정도다
    * 해결 방법은 의존성을 바람직하게 만드는 것이다.
    * 의존성은협력을위해반드시필요한 것 이 다, 단 지바 람 직 하 지못 한의 존 성 이문 제 일뿐 이 다 P
    * 비람직한의존성은재사용성과관련이있다어. 떤의존성이 다양한환경에서클래스를재시용할수없도록제한한다면그의존성은비람직하지못한것이다.어떤 의존성이다양한환경에서재시용할수있다면그의존성은바람직한것이다.
    * 다시말해컨텍스트에독립적인의존성은바람직한의존성이고특정한컨텍스트에깅히케결힙된의존성은비람직하지않은 의존성이다.
    * 특정한 컨텍스트에 강하게 의존하는 클래스를 디른 컨텍스트에서 재시용할 수 있는 유일한 방법 은 구현을 변경하는 것뿐이다. 
    * 다른환경에서재사용하기위해내부구현을변경하게만드는모든의존성은바람직하지않은의존성 이다.
    * 비람직한의존성이란컨텍스트에독립적인의존성을의미하며다양한환경에서재사용될수있 는 기능성을 열어놓는 의존성을 의미한다.
    * 개발커뮤니티가힝상그런것처􏰀바람직한의존성과바람직하지못한의존성을가리키는좀더세련 된용어가존재한다.결합도가바로그것이다
    * 어떤두요소시이에존재히는의존성이바람직할때두 요소가느슨한결합도(loosecoupling)또는약한결합도(weakcoupling)를가진디고말한다.반 대로두요소사이의의존성이바람직하지못할때단단한결합도(tightcoupling)또는강한결힘도 (strong coupling)를 가진디고 말한다.
    * 일반적으로의존성과결합도틀동의어로사용5防l만사실두용어는서로다른관점에서관계의특성을설명하는용어다. 의존성은 두 요소 사이의 관계 유무를 설명한다. 따라서 의존성의 관점에서는興의존성이 존재한다” 또는 “의존성이 존재하지않는다”라고표현해야한다.그에반해결힙도는두요소사이에존재하는의존성의정도를상대적으로 표현한다따리서결합도의관점에서는혈힙도가강하다’또' 는“ 결합도가느슨 하다라고표현한다
    * 비람직한의존성이란설계를재사용하기쉽게만드는의존성이다바. 람직하지못한의존성이란설계를 재사용하기어렵게만드는의존성이다
    * 어떤의존성이재시용을빙해한다면결힘도가깅하다고표현한 다.어떤의존성이재시용울쉽게허용한다면결힘도가느슨하디코표현한다.
* 지식이 결합을 낳는다
  * 결힙도의정도는한요소가자 신이의존히고있는디른요소에대해알고있는정보의양으로결정된다.
  * 한요소가디른요소에대해 더많은정보를일고있을수록두요소는깅히케결합된다.반대로한요소가디른요소에대해더적은 정보를 알고 있을수록 두 요소는 약하게 결힙된다.
  * 더많이일수록더많이결힘된다.더많이일고있디는것은더적은컨텍스트에서재시용가능하디는 것을의미한다
  * 기존지식에어울리지않는컨텍스트에서클래스의인스턴스를시용하기위해서할수 있는유일한방법은클래스를수정하는것뿐이다.
  * 결합도를느슨하게유지하려면협력하는대상에대 해더적게알이야한다.결합도를느슨하게만들기위해서는협력히는대상에대해필요한정보외에 는 최대한 감추는 것이 중요하다.
  * 디행스러운점은이목적을달성할수있는기장효괴적인방법에대해이미일고있디는것이다.추상 회카 바로 그것이 다.
* 추싱화에 의존하라
  * 추싱회란어떤양상,세부시항,구조를좀더명확하게이해하기위해특정절차나물체를의도적으로 생략하거나감춤으로써복잡도를극복하는방법이다
  * 추상회를사용하면현재디루고있 는문제를해결히는데불필요한정보를김출수있다.따라서대상에대해일이야하는지식의양을줄 일수있기때문에결힘도를느슨하게유지할수있다.
  * 일반적으로추싱회와결힘도의관점에서의존대싱을디음과같이구분히는것이유용히다.목록에서 아래쪽으로갈수록클라이언트가알이야히는지식의양이적어지기때문에결합도가느슨해진다.
  * 구체 클래스 의존성(concrete class dependency) 
  * 추상 클래스 의존성(abstract class dependency)
  * 인터페이스 의존성(interface dependency)
  * 구체클래스에비해추상클래스는메서드의내부구현과자식클래스의종류에대한지식을클라기언 트에게숨길수있다.따라서클라이언트가알이야하는지식의양이더적기때문에구체클래스보다 추상클래스에의존히는것이결힘도가더낮다.하지만추상클래스의클표舶l언트는여전히협력히는 대상이속한클래스싱속계층이무엇인지에대해서는일고있어야한다.
  * 인터페이스에의존하면싱속계층을모르더리도협력이가능해진다,인터페이스의존성은협력히는객 체가어떤메시지를수신할수있는지에대한지식만을남기기때문에추상클래스의존성보다결힘도 가낮다.이것은다양한클래스싱속계층에속한객체들이동일한메시지를수신할수있도록컨텍스 트를 확장히는 것을 기능하게 한다.
  * 여기서중요한것은실행컨텍스트에대해일이야히는정보를줄일수록결합도가벎}진디는것이다. 결힙도를느슨하게만들기위해서는구체적인클래스보다추상클래스에추, 상클래스보다인터페이 스에의존히도록만드는것이더효과적이다.다시말해의존하는대상이더추상적일수록결힘도는더 낮이진디는것이다.이것이핵심이다
  * 명시적인 의존성
    * 클래스안에서구체클래스에대한모든의존성을 제거해야만한다
    * 모든경우에의존성은명시적으로퍼블릭인터페이스에노출된다. 를명시적인의존성 (explicitdependency)이리고부른다.
    * 의존성이명시적이지않으면의존성을파악하기위해내부구현을직접살펴볼수밖에없다.커다란클 래스에정의된긴메서드내부어딘7볘서인스턴스를생성하는코드를파악히는것은쉽지않올뿐더
      러 심지어 고통스러울 수도 있다.
    * 더커다란문제는의존성이명시적이지않으면클래스를디른컨텍스트에서재시용하기위해내부구 현을직접변경해야한디는것이다.코드수정은언제나짐채적으로버그의발생기능성을내포한다. 의존성을명시적으로드러내면코드를직접수정해야히는위험을피할수있다.실행컨텍스트에적절
      한 의존성을 선택할 수 있기 때문이다.
    * 의존성은명시적으로표현돼야한다.의존성을구현내부에숨겨두지마라.유연하고재시용가능한설 계란퍼블릭인터페이스를통해의존성이명시적으로드러니는설계다.명시적인의존성을시용해야만
      퍼블릭인터페이스를통해컴파일타임의존성을적절한런타임의존성으로교체할수있다.
    * 클래스가디른클래스에의존히는것은부끄러운일이아니다.의존성은디른객체외의협력을가능하 게해주기때문에바람직한것이다,경계해야할것은의존성자체가아니라의존성을감추는것이다. 숨겨져있는의존성을밝은곳으로드러내서널리알려라.그렇게하면설계가유연히고재사용가능해
      질 것이다.
  * new는 해톱다
    * new 를잘못사용하면클래스艸I의결합도가극단적으로높아진다.결힘도측면에서new가해로운이 유는크게두가지다.
    * new연산자를사용하기위해서는구체클래스의이름을직접기술해야한다따라서new를 사용하는클라이언트는추싱화 가아닌구체클래스에의존할수밖에없기때문에결합도가높아진다.
      new연산자는생성하려는구체클래스뿐만아니라어떤인자를이용해클래스의생성자를호출해야하는지도 알아야 한다. 따라서new를사용하면클라이언트가알아야하는지식의양이늘어나기때문에결합도가높아진다.
    * 구체클래스에직접의존하면결힘도가높아진디는사실을기억히라.결합도의관점에서구체클래스는협력지에게너무많은지식을알도록강요힌다.여기에new는문제를더크게만든다.클라이언트는
      구체클래스를생성히는데어떤정보가필요한지에대해서도 알아야 하기때문이다.
    * new는 결합도를 높이기 때문에 해롭다. new는 여러분의 클래스를 구체 클래스에 결합시키는 것만으로 끝나지 않는다. 협력할 클래스의 인스틴스를 생성하기 위해 어떤 인자들이 필요하고 그 인지들을 어떤 순서로 시용해야 히는지에 대한 정보도 노출시킬뿐만 아니라 인지로 시용되는 구체 클래스에 대한 의
      존성을 추기한다.
    * 해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 시응하는 로직을 분리하는 것이다.
    * 시용과생성의책임을분리히고,의존성을생성자에명시적으로드러내고,구체클래스가아닌추상클 래스에 의존하게 함으로써 설계를 유연하게 만들 수 있다. 그리고 그 출발은 객체를 생성하는 책임을 객체 내부가 아니라 클리이언트로 옮기는 것에서 시직했다는 점을 기억하라 이 예제는 올비른 객체가 올바른책임을수행하게히는것이홀륭한설계를칭조히는기반이리는사실을잘보여준다.
  * 가끔은 생성해도 무방하다
    * 클래스안에서객체의인스턴스룰직접생성하는방식이유옹한경우도있다.주로협력히는기본객체 를설정히고싶은경우가여기에속한다.
    * 이 문제를 해결히는 방법은 기본 객체를 생성히는 생성지를 추기하고 이 생성자에서 DiscountPolicy의 인스턴스를인지로받는생성지를체이닝히는것이다
    * 이방법은메서드를오버로딩히는경우에도시용할수있다. 인지로받는메서드와기본값을생성히는메서드를함끼l시용한다면클래스의사용성을향상시키면서 도다양한컨텍스트에서유연하게사용될수있는여지를제공할수있다.
    * 이예는설계가트레이드오프활동이리는시실을다시한번상기시킨다.여기서트레이드오프의대상 은결힘도와시용성이다
    * 구체클래스에의존하게되더리도클래스의시용성이더중요하다면결힘도 를높이는방향으로코드를작성할수있다.
    * 그럼에도가급적구체클래스에대한의존성을제거할수 있는 방법을 찾아보기 바란다.
    * 종종 모든 결합도가 모이는 새로운 클래스를 추기힘으로써 시용성과 유 연성이리는 두 마리 토끼를 집울 수 있는 경우도 있다. 이어지는 9장에서 살펴볼 FACTORY가 바로 그런 경우다.
  * 표준 클래스에 대한 의존은 해롭지 않다
    * 의존성이 불편한 이유는 그것이 힝상 변경에 대한 영향을 암시하기 때문이다. 따리서 변경될 획률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다
    * 자바라면 JDK에 포힘된 표준 클래스가 이 부류에 속한다. 이런 클래스들에 대해서는 구체 클래스에 의존하거나 직접 인스턴스를 생성하더리도 문제가 없다.
    * 비록클래스를직접생성하더리도기능한한추상적인타입을시용하는것이확장성측면에서유리하 다
      * 이렇게 하면 다 양한 List 타입의 객체로 Conditions를 대체할 수 있게 설계의 유연성을 높일 수 있다.
    * 의존성 에 의한 영향이 적은 경우에도 추싱회에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습 관이다.
  * 컨텍스트 확장하기
    * 어떤경우든코드내부를직접수정히는것은버그의발생기능성을높이는 것이리는점을기억하라.
    * 해결책은 할인 정책이 존재하지 않는다는 사실을 예외 케이스로 처리하지 말고 기존에 Movie와 DiscountPolicy가 협력히던 방식울 따르도록 만드는 것이다.
      * 할인 정책이 존재하지 않는다 는사실을할인정책의한종류로간주히는것이다.
    * 결합도를 낮춤으로써얻게되는컨텍스트의획장이리는개념이유연히고재시용가능한설계를만드는핵 심이다.
  * 조합 가능한 행동
    * 어떤객체와협력히느냐에따라객체의행동이달라지는것은유연히고재시용가능한설계가가진특 징이다.유연하고재사용7浩한설계는응집도높은책임들을가진작은객체들을다양한방식으로연 결함으로써 애플리케이션의 기능을 쉽게 확징할 수 있다.
    * 유연히고재시용기능한설계는객체가어떻게(how)히는지를징힁윤셔I나열하지않고도객체들의조 힘을통해무엇(what)을히는지를표현히는클래스들로구성된다.따리서클래스의인스턴스를생성 하는코드를보는것만으로객체가어떤일을히는지를쉽게파악할수있다.코드에드러난로직을해 석할필요없이객체가어떤객체와연결됐는지를보는것만으로도객체의행동을쉽게예싱히고이해 할수있기때문이다.디시말해선언적으로객체의행동을정의할수있는것이다.
    * 유연하고재사용7浩한설계는작은객체들의행동을조합함으로써새로운행동을이끌어낼수있는 설계다.홀륭한객체지향설계란객체가어떻게하는지를표현히는것이아니라객체들의조합을선언 적으로표현함으로써객체들이무엇을하는지를표현하는설계다.그리고지금까지설명한것처􏰀이 런 설계를 칭조하는 데 있어서의 핵심은 의존성을 관리히는 것이다.
    * 객체지향시스템은협력하는객체들의네트워크로구성돼있다시. 스템은객체를생성해서로메시지를주고 받을수있게조립하는과정을거쳐만들어진다.시스템의행위는객체의조합(객체의선택과연결방식)을통 해 나타나는 특성이다.
      따라서시스템에포함된객체의구성을변경해(절차적인코드를작성하기보다는인스턴스추가나제거또는조 합을달리해서)시스템의작동방식을바꿀수있다.이러한객체구성을괸리할목적으로작성하는코드를객 체네트워크의행위에대한선언적인정의라고한다시. 스템을이런방식으로구축하면방법(how)이이니라목 적(what)에집중할수있어시스템의행위를변경하기가더쉽다.



