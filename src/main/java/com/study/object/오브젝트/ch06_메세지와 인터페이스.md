## 협력과 메세지
### 클라이언트-서버 모델
* 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.
* 협력의 관점에서 객체는 두 가지 종류의 메세지 집합으로 구성된다.
  * 객체가 수신하는 메세지의 집합
  * 외부의 객체에게 전송하는 메세지의 집합
* 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것이다.
* 두 객첵 아시의 협력을 가능하게 해주는 매개체가 메시지다.

### 메세지와 메세지 전송
* 메세지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
* 메세지는 오퍼레이션명과 인자로 구성되며 메세지 전송은 여기에 메세지 수신자를 추가한 것이다.

### 메세지와 메서드
* 메세지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다.
* 메세지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
* 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.
* 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 얇고 가는 끈을 통해 연결된다.
* 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.

### 퍼블릭 인터페이스와 오퍼레이션
* 객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다.
* 외부에서 볼때 객체의 안쪽은 검은 장막으로 가려진 미지의 영역이다.
* 외부의 객체를 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
* 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부른다.
* 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.
* 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.
* 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.
* 프로그래밍 언어의 관점에서 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.
* 따라서 퍼블릭 인터페이스와 메시지의 관점에서 보면 메서드 호출보다는 오퍼레이션 호출이라는 용어를 사용하는 것이 더 적절하다.

### 시그니처
* 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다.
* 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.

## 인터페이스와 설계 품질
* 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.
* 꼭 필요한 오퍼레이션만 포함한다.
* 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.
* 조건을 만족하기 위해서는 책임 주도 설계 방법을 따르면 메세지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다.
* 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게 한다. <br>
따라서 추상적인 오퍼레이션이 인터페이스에 자연스롭게 스며들게 된다.

### 디미터 법칙
* 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것이다.
* 낯선 자에게 말하지 말라 또는 오직 인접한 이웃하고만 말하라로 요약할 수 있다.
* 아래 조건을 만족하는 인스턴스에만 메세지를 전송하도록 프로그래밍해야한다.
  * this 객체
  * 메서드의 매개변수
  * this의 속성
  * this의 속성인 컬렉션의 요소
  * 메서드 내에서 생성된 지역 객체
* 디미터 법칙을 따르면 부끄럼 타는 코드를 작성할 수 있다.
  * 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.
  * 메시지 수산자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신사의 내부 구현에 결합되지 않는다.
  * 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.
* 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
  * 따라서 메시지 수신자의 캡슐화는 무너지고, 메시지 전송자가 메시지 수신자의 내부 구현에 강하게 결합된다.
* 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조한다.

### 묻지 말고 시켜라
* 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.
* 이 원칙을 따르면 밀접하게 연관된 정보와 행동을 함꼐 가지는 객체를 만들 수 있다.
* 객체지향의 기본은 함꼐 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.
* 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해보라.
* 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라

### 의도를 드러내는 인터페이스
* 켄트 벡의 메서드를 명명하는 두 가지 방법
  * 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는것이다.
    * 내부 구현을 설명하는 이름이다.
  * 무엇을 하는지를 드러내는것 -> 이거이 좋다
    * 의도를 드러내는 선택자라고 부른다.
    * 매우 다른 두번째 구현을 상상하라, 그러고는 해당 메서드에 동일한 이름을 붙인다고 상상해보라
    * 그렇게 하면 아마도 그 순간에 가장 추상적인 이름을 메서드에 붙일것이다.
    * 의도를 드러내는 인터페이스는 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는것이다.

### 함께 모으기
* 오퍼레이션의 이름은 협력이라는 문맥을 반영해야 한다.
* 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 한다.

## 원칙의 함정
### 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다
* 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.
* 하나 이상의 도트를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다.
* 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.

### 결합도와 응집도의 충돌
* 디미터 법칙과 묻지 말고 시켜라 원칙을 무작정 따르면 응집도가 낮은 객체로 넘쳐날 것이다.
* 컬렉션에 포함된 객체들을 처리하는 유일한 방법은 객체에게 물어보는 것이다.
* 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려있다고 설명한다.
* 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.
* 원칙을 맹신하지 말고 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라.
* 설계는 트레이드오프의 산물이다.
* 소프트웨어 설계에 법칙이란 존재하지 않는다.
* 몇 안되는 법칙 중 하나는 경우에 따라 다르다라는 사실을 명심하라

## 명령-쿼리 분리 원칙
* 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
* 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
* 객체의 상태를 수정하는 오퍼레이션을 명령이라고 부른다.
* 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.
* 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.

### 반복 일정의 명령과 쿼리 분리하기
* 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.
* 퍼블릭 인터페이스를 설계할 때 부수효과를 가지는 대신 값을 반환하지 않는 명령과 부수효과를 가지지 않는 대신 값을 반환하는 쿼리르 분리하기 바란다.
* 그 결과 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것이다.

### 명령-쿼리 분리와 참조 투명성
* 참조 투명성이란 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성
* 어떤 값이 불변한다는 말은 부수효과가 발생하지 않는다는 말과 동일하다.
* 불변성은 부수효과의 발생은 방지하고 참조 투명성을 만족시킨다.
* 명령-쿼리 분리 원칙을 사용하면 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.

### 책임에 초점을 맞춰라
* 디미터 법칙을 준수하고 묻지말고 시켜라 스타일을 따르면서도 의도를 드러내는 인터페이스를 설계하는 아주 쉬운 방법이 있다.
  * 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것이다.
* 명령과 쿼리를 분리하고 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적으로 드러낼 수 있는 방법이 있다.
  * 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것이다.
* 이 모든 방식의 중심에는 객체가 수행할 책임이 위치한다.
* 메세지를 먼저 선택하는 방식의 긍정적인 영향
  * 디미터 법칙 : 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다. <br>
    수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다. <br>
    따라서 메시지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화 할 수 있다.
  * 묻지 말고 시켜라 : 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다. <br>
    클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.
  * 의도를 드러내는 인터페이스 : 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다. <br>
    당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수 밖에 없다.
  * 명령-쿼리 분리 원칙 : 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다. <br>
    객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. <br>
    따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리르 분리하게 될 것이다.
* 책임 주도 설계 방법에 따라 메시지가 객체를 결정하게 해라. 그러면 설계가 아름답고 깔끔해지며 심지어 우아해진다는 사실을 실감하게 될 것이다.
