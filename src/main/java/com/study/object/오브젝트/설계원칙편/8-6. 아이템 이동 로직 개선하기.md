---

# 테스트 어드벤처 게임 리팩터링 핵심 요약

*(LSP + OCP + DIP + SRP + 합성으로 구조 개선)*

---

## 1. 출발점 — 기존 게임 설계의 문제

### 구현 내용 요약

* `TakeItem`, `DropItem` 추가
* 중복 로직을 `Transfer` 메서드로 통합
* Player / Room 모두 아이템 이동 책임 보유
* 상속으로 중복 코드 제거 시도

### 하지만 발생한 문제

* **Room이 Player를 대체하지 못함**
* `NullPointerException` 발생
* **LSP(리스코프 치환 원칙) 위반**
* Game이 **구체 클래스(Player)에 직접 의존**

---

## 2. 핵심 문제 — Room은 Player를 대체할 수 없다 (LSP 위반)

### 원인

* Player는 `worldMap` 필요
* Room은 이동 개념이 없어 `worldMap = null`
* 업캐스팅(Room → Player) 시 `canMove()` 호출 → NPE 발생

### 결론

> **Room은 Player의 서브타입이 될 수 없다**
> → 상속 구조가 잘못됨

---

## 3. 잘못된 해결 시도들

### ❌ 타입 체크 추가 (`if Room`)

* Game 수정 필요 → **OCP 위반**

### ❌ 빈 구현 오버라이딩

* 기능 무력화 → **LSP 위반**

### ❌ Player 메서드 override로 회피

* 클라이언트 기대 깨짐

---

## 4. 해결 전략 — “역할(Role)”을 추상화하라

### Game이 실제로 원하는 건 Player가 아니라:

> **“아이템을 보관·검색·추가·삭제할 수 있는 대상”**

---

## 5. 해결 — Carrier 인터페이스 도입 (행동 기반 추상화)

### Carrier가 제공하는 책임

* `items()`
* `find()`
* `add()`
* `remove()`

### 효과

* Game은 Player/Room 대신 **Carrier에 의존**
* Player와 Room 모두 Carrier 구현 가능
* **LSP 만족** (서로 대체 가능)

---

## 6. Transfer 책임 분리 — SRP 적용

### 기존 문제

* Game이 아이템 이동 로직을 직접 수행 → 테스트 어려움

### 개선

* `TransferService` / `Transfer` 클래스로 이동 로직 분리
* Game은 Transfer에만 의존

### 결과

* **테스트 용이**
* 책임 명확
* Game 단순화

---

## 7. CQS 적용 — 명령과 조회 분리

### Transfer 문제

* 상태 변경 + boolean 반환 (명령+쿼리 혼합)

### 개선

* `isPossible()` → Query
* `perform()` → Command

> **결과 예측 가능 + 테스트 안정성 증가**

---

## 8. DIP 적용 — Game은 구체 클래스가 아니라 추상화에 의존

### 변경 전

```
Game → Player
```

### 변경 후

```
Game → Carrier (Interface)
Game → Transfer (Service)
```

> **고수준 정책(Game)은 저수준 구현(Player/Room)에 의존하지 않음**

---

## 9. 중복 제거 전략 — 상속 대신 합성(Composition)

### 문제

* `AbstractCarrier` 상속 → 재사용 목적 상속 → 강결합

### 해결

* `Inventory` 클래스로 아이템 관리 책임 분리
* Player / Room → Inventory를 **합성**

### 효과

* 상속 제거
* 재사용 가능
* 결합도 감소

---

## 10. 포워딩(Forwarding)으로 중복 제거

### 문제

* Carrier 메서드마다 위임 로직 중복

### 해결

* `ForwardingCarrier` 도입
* 공통 포워딩 로직을 한 클래스에 집중

> **DRY + 유지보수성 개선**

---

## 11. 상속 vs 합성 — 최종 원칙

### 상속을 쓰지 말아야 할 때

* 코드 재사용 목적
* 변경 이유가 다른 경우
* 역할이 완전히 동일하지 않을 때

### 합성을 써야 할 때

* 재사용 목적일 때
* 기능을 조합해야 할 때
* 결합도를 낮추고 싶을 때

---

## 12. 최종 구조 개요

```
Game
 └─ Transfer (아이템 이동 정책)

Carrier (Interface)
 ├─ Player
 └─ Room

Inventory (아이템 관리 책임)
 └─ 합성됨

ForwardingCarrier (중복 위임 로직)
```

---

## 13. SOLID 원칙 충족 현황

| 원칙  | 어떻게 만족                    |
| --- | ------------------------- |
| SRP | Transfer, Inventory 책임 분리 |
| OCP | Carrier 구현 추가로 확장         |
| LSP | Player/Room 상호 대체 가능      |
| DIP | Game → Interface 의존       |
| ISP | Carrier 역할만 노출            |

---

## 14. 핵심 통찰 모음

* **상속으로 재사용하려 하면 구조가 깨진다**
* **LSP는 “타입”이 아니라 “행동 호환성” 문제다**
* **Game은 Player가 아니라 “역할(Interface)”에 의존해야 한다**
* **중복 제거 목적이면 상속보다 합성이 안전하다**
* **명령과 조회를 섞으면 테스트가 어려워진다**

---

## 15. 초압축 기억 버전

```
문제:
Room이 Player를 대체 못함 → LSP 위반

해결:
Player/Room 공통 역할 = Carrier 인터페이스
아이템 이동 = Transfer 서비스 분리
아이템 관리 = Inventory 합성

결론:
구체 타입 의존 제거 → LSP/OCP/DIP 충족
상속 대신 합성 + 포워딩으로 구조 안정화
```

---