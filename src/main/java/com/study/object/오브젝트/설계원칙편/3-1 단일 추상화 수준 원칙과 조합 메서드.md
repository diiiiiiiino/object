---

# 🧠 메서드 설계와 추상화 수준 — 완전 숙지 노트

---

## 1. 메서드 이름은 왜 중요한가

> **메서드 이름은
> ‘어떻게 구현했는지’가 아니라
> ‘무엇을 하는지’를 표현해야 한다**

* 내부 구현 방식은 바뀔 수 있다
* 메서드가 하는 일(의도)은 쉽게 바뀌지 않는다
* 이름에 구현 방식이 드러나면 변경에 취약해진다

---

## 2. 좋은 메서드 이름의 기준

### ❌ 나쁜 예

* `linearSearch`
* `hashedSearch`
* `binarySearch`

👉 내부 구현 방식을 그대로 노출
👉 클라이언트가 구현에 **묶이게 됨**

### ⭕ 좋은 예

* `find`

👉 클라이언트의 **의도**를 표현
👉 내부 구현은 자유롭게 변경 가능

> **이름은 구현을 숨기고, 의도를 드러내야 한다**

---

## 3. 메서드 길이보다 더 중요한 것

종종 이런 논쟁이 생긴다:

> “메서드는 짧아야 한다 vs 길어도 된다”

하지만 핵심은 길이가 아니다.

> **중요한 건
> 메서드 내부 코드와
> 메서드 이름 사이의 ‘의미 차이’다**

---

## 4. 메서드 추출의 기준 (핵심)

| 상황        | 판단         |
| --------- | ---------- |
| 의미 차이가 크다 | 👉 메서드로 추출 |
| 의미 차이가 작다 | 👉 그대로 둔다  |

👉 **의미 차이가 크면
그 자체로 ‘이름을 붙일 가치’가 있다**

---

## 5. 메서드 추출의 가장 큰 목적

메서드 추출은 단순한 코드 쪼개기가 아니다.

### 메서드 추출의 핵심 목적

1. **코드의 의도를 명확히 드러내기**
2. **가독성 향상**
3. **중복 제거**
4. **의존성 분리**

그중 가장 중요한 하나는:

> **읽기 쉬운 코드 만들기**

---

## 6. 단일 추상화 수준 원칙 (Single Level of Abstraction)

> **하나의 메서드 안에는
> 동일한 추상화 수준의 코드만 존재해야 한다**

### 추상화 수준이 섞이면 생기는 문제

* 메서드를 이해하기 어렵다
* 코드를 위아래로 왔다 갔다 하며 읽게 된다
* 머릿속에 여러 수준의 정보를 동시에 기억해야 한다

👉 **이해 비용이 급격히 증가**

---

## 7. 고수준 vs 저수준 코드

### 고수준 코드 (WHAT)

* 목표
* 의도
* 역할

예:

* `showRoom()`
* `play()`
* `welcome()`

👉 *무엇을 하는지*에 집중

---

### 저수준 코드 (HOW)

* 구체적인 구현 방법
* API 호출
* 출력 방식

예:

* `System.out.println(...)`
* 좌표 계산
* 입력 처리

👉 *어떻게 하는지*에 집중

---

## 8. 추상화 수준이 섞였을 때의 문제 (run 메서드 예시)

* `run()` 안에

  * `System.out.println()` 같은 저수준 코드와
  * `showRoom()` 같은 고수준 코드가 섞여 있음

### 결과

* `run()`을 이해하려면

  * 전체 흐름도 이해해야 하고
  * 내부 구현도 같이 기억해야 한다

👉 **코드를 읽는 사람이 불필요하게 고생한다**

---

## 9. 해결 방법: 추상화 수준을 맞춘다

> **메서드 안의 모든 코드를
> 같은 추상화 수준으로 맞춘다**

### before

* 고수준 + 저수준 혼합

### after

* `run()` → 고수준 코드만
* 저수준 구현 → 하위 메서드로 이동

---

## 10. 메서드 추출이 가져오는 변화

* 메서드가 **무슨 일을 하는지 한눈에 보인다**
* 세부 구현은 궁금할 때만 내려가서 보면 된다
* 코드 읽기가 위에서 아래로 자연스럽다

> **상위 메서드는 ‘스토리’를 읽는 느낌**
> **하위 메서드는 ‘디테일’을 확인하는 느낌**

---

## 11. 조합 메서드 패턴 (Composed Method)

> **동일한 추상화 수준의 메서드들을
> 조합해서 하나의 메서드를 구성하는 방식**

* `run()`은

  * `welcome()`
  * `play()`
  * `printResult()`
* 처럼 **의도가 드러나는 메서드들로만 구성**

👉 단일 추상화 수준 원칙을 자연스럽게 만족

---

## 12. 메서드 추출의 또 다른 이유들

### 1️⃣ 중복 제거

* 같은 코드가 반복되면
* 의미 있는 이름의 메서드로 추출
* 중복 제거 + 의도 명확화

---

### 2️⃣ 의존성 분리

* 외부 시스템(`System.in`, `System.out`)에 대한 의존
* 한곳으로 모아서 관리
* 나중에 변경·테스트가 쉬워짐

---

## 13. 작은 메서드의 장점

* 이해하기 쉽다
* 수정하기 쉽다
* 재사용하기 쉽다
* 오버라이딩하기 쉽다
* 다른 클래스로 옮기기 쉽다

👉 **설계 리팩터링의 출발점**

---

## 14. 리팩터링은 어디서 시작하는가

> **가장 먼저 할 일은
> 긴 메서드를 작은 메서드로 나누는 것**

* 길이가 짧아지면 이해가 쉬워진다
* 이해가 쉬워지면 수정이 쉬워진다
* 수정이 쉬워지면 설계 개선이 가능해진다

---

## 15. 메서드 추출 리팩터링의 본질

> **의도를 이름으로 드러내는 작업**

* 메서드는 호출되기 위해 존재한다
* 호출자의 관점에서 이름을 짓는다
* 이름만 보고도 역할이 보여야 한다

---

## 16. 반드시 기억할 문장들 (암기용)

* 메서드 이름은 **무엇을 하는지**를 표현한다
* 구현 방식은 **이름에 드러내지 않는다**
* 메서드 길이보다 **의미 차이**가 중요하다
* 하나의 메서드에는 **하나의 추상화 수준**
* 메서드 추출은 **가독성 리팩터링의 시작**

---

## 17. 코드 볼 때 스스로에게 던질 질문

* 이 메서드는 무슨 일을 하나?
* 이름만 보고 이해되는가?
* 구현 방식이 이름에 드러나지 않았는가?
* 서로 다른 추상화 수준이 섞여 있지 않은가?
* 이 코드는 메서드로 추출할 ‘의미’가 있는가?

---