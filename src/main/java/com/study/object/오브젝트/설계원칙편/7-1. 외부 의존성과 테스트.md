
# 🎮 게임 클래스 테스트가 어려운 이유 — 장기 기억용 정리

## 1. 문제의 핵심 한 문장 요약

> **입출력(키보드·콘솔)에 대한 의존성이 게임 클래스 내부에 숨겨져 있어 테스트가 어렵고 변경에 취약한 설계다.**

---

## 2. 현재 게임 클래스에서 발생하는 문제

### 2.1 테스트 관점의 문제

* 테스트 코드에서 **문자열 명령**이

    * 어떤 의미인지
    * 게임 상태에 어떤 영향을 주는지
    * 테스트 결과와 어떻게 연결되는지
      👉 **전혀 드러나지 않음**
* `System.out` 출력 역시

    * 테스트와 어떤 관계인지
    * 어떤 상태를 검증해야 하는지
      👉 **추적 불가능**

### 2.2 테스트 코드의 한계

* 게임 인스턴스를 생성 후 `run()` 같은 메서드만 호출
* 입력과 출력이 **암묵적으로 처리**
* 테스트 케이스에서 얻을 수 있는 정보가 거의 없음
  → “정보가 숨겨져 있다”

---

## 3. 근본 원인

### 3.1 숨겨진 의존성 (Hidden Dependency)

게임 클래스 내부에서:

* `Scanner` 직접 생성
* `System.out` 직접 사용

➡️ **외부 의존성이 클래스 내부에 감춰져 있음**

---

### 3.2 의존성 전이 (Dependency Transitivity)

```
Game → Console → Scanner → 키보드
                 System.out → 콘솔 화면
```

* 게임은 콘솔에 의존
* 콘솔은 스캐너와 시스템에 의존
* 결과적으로 **게임이 키보드·콘솔 환경에 간접 의존**

---

### 3.3 구체 클래스에 대한 의존

* Game → Console (구체 클래스)
* Console → Scanner, System (구체 클래스)

📌 문제점

* 교체 어려움
* 변경 영향 범위 큼
* 결합도 높음

---

## 4. 단일 책임 원칙(SRP) 관점에서 본 문제

### 책임이 섞여 있음

| 클래스     | 실제 책임                 |
| ------- | --------------------- |
| Game    | 게임 규칙 + 입력 처리 + 출력 처리 |
| Console | 키보드 입력 + 화면 출력        |

➡️ **고수준 정책(게임 규칙)** 과
➡️ **저수준 메커니즘(입출력)** 이 뒤섞임

---

## 5. 1차 개선: Console 클래스로 분리

### 5.1 변경 내용

* `Scanner`, `System.out`을 `Console` 내부로 이동
* Game은 Console에만 의존

```java
class Console {
    String input();
    void showLine(String text);
}
```

### 5.2 효과

✅ 입출력 테스트는 Console 테스트에서만 검증
❌ 게임 테스트는 여전히 어려움

---

## 6. 왜 여전히 테스트가 어려운가?

### 6.1 의존성 전이가 여전히 존재

* Game → Console → Scanner/System
* **의존성이 간접적으로 여전히 게임까지 전파**

### 6.2 의존성이 인터페이스에 드러나지 않음

* Game 생성자에서 Console을 **직접 생성**
* 외부에서 대체 불가
* 내부 구현을 봐야만 의존성을 알 수 있음

---

## 7. 변경 관점에서 드러나는 치명적 문제

### 예시: 출력 대상을 콘솔 → 파일로 변경한다면?

❌ 현재 설계

* Game 클래스를 직접 수정해야 함
* 핵심 정책이 저수준 변경에 영향 받음

➡️ **변경 방향이 잘못됨**

---

## 8. 이상적인 변경 방향

### 바람직한 흐름

```
고수준 정책(Game)이 바뀔 때
→ 저수준 메커니즘(Console, File)이 바뀌도록
```

### 현재 흐름 (문제)

```
저수준 메커니즘(Console)이 바뀌면
→ 고수준 정책(Game)이 바뀜 ❌
```

---

## 9. 해결 원칙: 의존성 역전 원칙 (DIP)

### 정의

> **고수준 모듈은 저수준 모듈에 의존하면 안 된다.
> 둘 다 추상화에 의존해야 한다.**

---

## 10. 최종 구조 (이상적인 설계)

```
          ┌─────────────┐
          │   Game      │  ← 고수준 정책
          └─────▲───────┘
                │
        ┌───────┴────────┐
        │ Input / Output │  ← 추상화
        └───────▲────────┘
                │
      ┌─────────┴───────────┐
      │ Console / File / Mock│ ← 저수준 구현
      └─────────────────────┘
```

---

## 11. 테스트가 쉬워지는 이유

* 게임 테스트

    * 입력: Mock Input
    * 출력: Fake Output
* 키보드/콘솔 없이도 테스트 가능
* 자동화 테스트 가능
* 변경 영향 최소화

---

## 12. 기억해야 할 핵심 문장들 ⭐

* **테스트가 어려운 설계는 변경에도 약하다**
* **숨겨진 의존성은 설계를 망친다**
* **구체 클래스에 의존하면 교체가 어렵다**
* **고수준 정책은 저수준 메커니즘을 몰라야 한다**
* **의존성 방향이 설계 품질을 결정한다**

---

## 13. 한 줄 결론

> **이 문제의 본질은 “입출력”이 아니라
> 의존성 방향이 잘못된 설계다.**

---