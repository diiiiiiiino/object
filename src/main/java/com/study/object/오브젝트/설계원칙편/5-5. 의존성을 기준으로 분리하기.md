---

# 🧠 SRP · 테스트 · 캡슐화로 Player 리팩터링 완성하기

## ― “콘솔 출력 의존성”은 설계가 잘못됐다는 신호다

---

## 1. 이번 시간의 출발 문제

### 테스트가 어려운 이유

* `System.out` 같은 **정적 콘솔 출력** 사용
* 테스트에서 출력 결과를 가로채야 함
* 결과적으로 **모호하고 깨지기 쉬운 테스트**

👉 문제는 테스트 코드가 아니라 **설계**

---

## 2. 관찰: Player 클래스 안의 서로 다른 의존성

Player 클래스를 자세히 보면:

| 메서드           | 의존 대상              | 변경 이유         |
| ------------- | ------------------ | ------------- |
| `tryMove`     | WorldMap, Position | **이동 규칙 변경**  |
| `showBlocked` | Console            | **출력 방식 변경**  |
| `showRoom`    | Console            | **출력 메시지 변경** |

👉 **의존 대상이 다름 = 변경 이유가 다름**
👉 **SRP 위반 신호**

---

## 3. 가이드 6 적용: 외부 의존성 분리

### 핵심 질문

> “이 클래스는 몇 개의 외부 시스템에 의존하고 있는가?”

* Player는 **이동 로직**과 **출력 로직**을 동시에 가짐
* 콘솔 출력은 불안정한 외부 메커니즘

👉 출력 책임을 **한 클래스에 캡슐화**해야 함

---

## 4. 콘솔 의존성은 어디로 가야 할까?

### 현재 콘솔 의존 클래스

* Game
* Player

### 선택

* **Game이 콘솔 입출력을 담당**
* Player는 **콘솔을 전혀 모르게**

👉 이유:

* Game은 흐름 제어자
* Player는 도메인 객체 → **출력 알 필요 없음**

---

## 5. 책임 재배치 ①: 출력 로직 이동

### 이동 대상

* `showBlocked`
* `showRoom`

### 결과

* Player → **순수 이동 로직만 보유**
* Game → 이동 결과를 받아 출력 담당

---

## 6. 새로운 문제: tryMove 안에 섞여 있던 두 책임

### tryMove 내부 로직 분석

1️⃣ 이동 성공 / 실패에 따른 **흐름 제어**
2️⃣ 실제 플레이어 위치 변경 (**도메인 로직**)

👉 서로 다른 책임이 한 메서드에 섞여 있음

---

## 7. SRP 핵심 분리: “무엇을 할지” vs “어떻게 할지”

### 분리 전략

* Player:

    * **좌표를 이동시키는 책임**
* Game:

    * 이동 결과에 따라 **무엇을 출력할지 결정**

👉 tryMove에서 **flow 로직 제거**

---

## 8. 최종 Player 클래스의 책임

### Player가 하는 일

* 자신의 위치를 이동한다
* WorldMap과 Position을 사용
* **콘솔 출력 ❌**
* **게임 흐름 판단 ❌**

👉 **완전한 도메인 객체**

---

## 9. 테스트 관점에서의 결정적 변화

### Before

* Player 테스트 시:

    * 콘솔 출력 검증 필요
    * 테스트 대상과 결과의 관계 불명확

### After

* Player 테스트:

    * 위치 변화만 검증
    * 출력 없음
    * **명확한 입력 → 명확한 결과**

👉 **좋은 테스트 = 좋은 설계의 결과**

---

## 10. 더 큰 문제 발견: Game ↔ Player 결합도

### 문제

* Game이 Player 내부 구조를 너무 잘 알고 있음

    * Player → WorldMap
    * Player → Position

👉 Player 내부 구조 변경 시
👉 Game도 함께 변경될 가능성 ↑
👉 **결합도 높음**

---

## 11. 해결 전략: 캡슐화의 본질

### 캡슐화란?

> “변경되는 것을 내부로 감추고
> 안정적인 것만 외부에 드러내는 것”

### 적용

* Game은 Player의 내부 구조를 모르게
* Game은 Player에게 **요청만 전달**

👉 Player가 **데이터 제공자**, Game이 **프로세스 관리자**

---

## 12. 객체지향 원칙 2가지로 정리

### 1️⃣ 묻지 말고 시켜라 (Tell, Don’t Ask)

* Player의 상태를 꺼내 판단 ❌
* Player에게 행동을 요청 ⭕

### 2️⃣ 디미터 법칙

* `game.player.worldMap.isBlocked()` ❌
* `player.tryMove()` ⭕

---

## 13. TryMove 메서드 이동 (마지막 단계)

### 결정

* `tryMove` → Player 클래스로 이동
* Game에서는 Player의 public API만 호출

### 결과

* Player: 이동 책임만 가짐
* Game: 흐름과 출력만 담당

👉 **SRP + 캡슐화 완성**

---

## 14. 테스트로 설계 품질 검증

### 테스트 기준

> “테스트를 쉽게 설계할 수 있는가?”

* Player 테스트:

    * WorldMap + Position만 준비
    * move 실행
    * 위치 검증

❌ 콘솔 출력 검증 없음
❌ 복잡한 픽스처 없음

---

## 15. 테스트가 주는 강력한 신호

### 테스트 냄새 정리

| 증상             | 의미           |
| -------------- | ------------ |
| 콘솔 출력 검증       | 책임 과다        |
| 픽스처 많음         | 결합도 높음       |
| 실행 경로 많음       | 클래스가 너무 많은 일 |
| private 테스트 욕구 | 책임 잘못 배치     |

---

## 16. 이번 파트의 핵심 문장 (암기용)

> 콘솔 출력에 의존하는 도메인 객체는
> 이미 SRP를 위반하고 있다
>
> 테스트가 어렵다면
> 설계가 잘못된 것이다
>
> 좋은 객체는
> **데이터를 감추고 행동만 드러낸다**

---

## 17. 한 줄 요약

> **SRP를 테스트 관점에서 끝까지 적용하면
> “출력 없는 도메인 객체”가 남는다**

---

## 18. 지금까지의 결과

* WorldMap: 지도 책임
* CommandParser: 파싱 책임
* Player: 이동 책임
* Game: 흐름 + 출력 책임

👉 **응집도 ↑ / 결합도 ↓ / 테스트 용이성 ↑**

---