---

# LSP 적용 가이드 & 상속의 한계 핵심 요약

*(정규화된 상속 → 조합 폭발 → 합성으로 전환)*

---

## 1. LSP 적용 1번 가이드 — **구현된 메서드를 오버라이드하지 말 것**

> **부모 클래스의 “구현된 구체 메서드”를 오버라이드하면 LSP 위반 가능성이 높다.**

### 왜 위험한가?

* 부모가 보장한 **행동 의미를 자식이 변경**
* 클라이언트의 기대가 깨짐
* 런타임 동작이 달라짐 → **대체 불가능**

### LSP 위반 예

* 부모 메서드의 결과를 변경
* 일부 기능을 제거
* 예외를 던지도록 변경
* 아무 동작도 하지 않게 변경

---

## 2. 올바른 상속 구조 — **정규화된 계층 (Refined Hierarchy)**

> **구체 메서드 오버라이딩이 필요 없는 상속 구조**

### 정규화된 계층 조건

* 각 책임은 **한 번만 구현**
* 자식은 **구현을 재정의하지 않음**
* 공통 로직은 부모에, 변하는 부분은 추상 메서드에

---

## 3. Reader 예시 — 정규화된 상속 구조

### 역할 분리

* **AbstractReader** → 읽기 로직 (read)
* **CsvReader / JsonReader** → 파싱 로직 (parse)
* 구체 구현은 **한 번만 존재**

### 장점

* LSP 만족
* 중복 제거
* 확장 시 기존 코드 수정 없음

---

## 4. 하지만… 상속 기반 확장은 한계가 있다

### RedisReader / FileReader 확장 시 문제

> **상속으로 “저장소 종류 × 포맷 종류”를 조합하면 클래스 수가 폭발**

### 예시 조합 폭발

| 저장소                | 포맷   | 필요한 클래스         |
| ------------------ | ---- | --------------- |
| File               | CSV  | CsvFileReader   |
| File               | JSON | JsonFileReader  |
| Redis              | CSV  | CsvRedisReader  |
| Redis              | JSON | JsonRedisReader |
| DB                 | XML  | XmlDbReader     |
| → **N × M 클래스 폭증** |      |                 |

---

## 5. 문제 1 — **중복 코드 증가**

* Redis 읽기 로직이 여러 Reader에 복사됨
* 저장소 로직이 포맷별로 반복 구현됨
* 기능 추가할수록 **중복 가속**

---

## 6. 문제 2 — **조합 폭발 (Combinatorial Explosion)**

> 기능이 2축(저장소, 포맷)으로 변하면
> 상속 구조는 **모든 조합을 개별 클래스로 만들어야 한다**

### 결과

* 클래스 수 기하급수적 증가
* 유지보수 난이도 급상승

---

## 7. 근본 원인 — **서로 다른 변경 이유를 하나의 상속 축에 묶음**

### 변경 축 (Axis of Change)

* 저장소 변경 (File / Redis / DB)
* 포맷 변경 (CSV / JSON / XML)

> **변경 이유가 다른데 같은 계층에 넣음 → 폭발 발생**

---

## 8. 해결 전략 — **상속 대신 합성(Composition)**

### 핵심 아이디어

> **변경 축을 “서로 다른 인터페이스”로 분리하고 합성으로 조립**

---

## 9. 책임 분리 — Reader & Parser

### Reader (저장소 책임)

* FileReader
* RedisReader
* DbReader

### Parser (포맷 책임)

* CsvParser
* JsonParser
* XmlParser

---

## 10. 구조 — 합성 기반 설계

```
Reader  ---> 데이터 읽기 (저장소)
Parser  ---> 데이터 파싱 (포맷)

AppSetReader = Reader + Parser (합성)
```

> **저장소와 포맷을 곱이 아닌 “조합”으로 연결**

---

## 11. 확장 시 효과

### 저장소 추가 (예: S3)

* Reader만 추가

### 포맷 추가 (예: YAML)

* Parser만 추가

### 기존 코드 수정?

> ❌ 없음
> ✅ 새 클래스 추가만

---

## 12. OCP + LSP + SRP를 동시에 만족

| 원칙  | 어떻게 만족?         |
| --- | --------------- |
| SRP | 저장소 / 파싱 책임 분리  |
| OCP | 새 타입 추가로 확장     |
| LSP | 대체 가능, 행동 계약 유지 |

---

## 13. 정리 — 상속은 재사용 수단이 아니라 **변경 모델링 수단**

> 상속은 “코드 재사용”이 아니라
> **“동일한 행동 계약을 공유할 때만” 사용해야 한다**

---

## 14. 핵심 결론

* **구체 메서드 오버라이딩은 LSP 위반 위험**
* 정규화된 상속 계층이 가장 안전
* 변경 축이 여러 개면 **상속이 아니라 합성**
* 조합 폭발은 **설계 신호**
* **“다형성 확장 = 상속”이라는 생각을 버려야 한다**

---

## 15. 초압축 기억 버전

```
LSP 가이드:
부모의 구현된 메서드를 오버라이드하지 말 것

상속 한계:
저장소 × 포맷 = 클래스 폭발 + 중복

해결:
변경 축 분리 → Reader + Parser 합성

결론:
상속은 신중히, 확장은 합성으로
```

---