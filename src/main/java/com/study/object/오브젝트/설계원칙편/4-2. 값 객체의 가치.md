---

# 🧠 값 객체(Value Object) — 왜 단순하고 강력한가

> **핵심 문장**
> 👉 *값 객체는 ‘정체성’이 아니라 ‘의미’를 표현한다*
> 👉 *상태를 추적하지 않아도 되는 객체가 가장 안전하다*

---

## 1. 값 객체란 무엇인가?

### 값 객체 정의

* 색상, 숫자, 금액처럼 **속성 자체가 의미인 객체**
* **식별자(ID)가 없다**
* 값이 같으면 **같은 객체로 취급**

📌 참조 객체와의 결정적 차이

* 참조 객체 → *누구냐*
* 값 객체 → *얼마냐 / 무엇이냐*

---

## 2. 값 객체의 핵심 특징

### ① 불변성 (Immutable)

* 생성 시 상태 결정
* 이후 변경 ❌

### ② 값 기반 동등성

* 객체 식별자가 아니라 **모든 속성 비교**
* `equals()`는 속성 비교로 구현

### ③ 연산 결과는 새 객체

* 상태 변경 대신 **새 값 생성**

---

## 3. Money 값 객체 예제 (개념 중심)

### Money 설계 의도

* `long`이 아니라 **“금액”이라는 개념**을 표현

### 핵심 설계 포인트

* `amount`는 `final`
* 생성자에서만 초기화
* `plus()`는 새로운 Money 반환

```text
Money(10000) + Money(20000)
→ Money(30000)
```

👉 기존 Money는 절대 변하지 않음

---

## 4. 가변 객체 vs 불변 객체 비교

### ❌ 가변 객체 Money

* 내부 상태가 누적 변경됨
* 실행 흐름을 처음부터 끝까지 따라가야 최종 값 예측 가능
* 별칭 문제 발생 가능

👉 **상태 추적 비용이 매우 큼**

---

### ✅ 불변 객체 Money

* 상태 변경 없음
* 결과 예측 시 **최종 값만 보면 됨**
* 중간 과정 무시 가능

👉 **이해 비용 급감**

---

## 5. 별칭 문제를 다시 보자

### 가변 참조 객체의 위험

* Client1, Client2가 같은 객체 참조
* 한쪽에서 변경 → 다른 쪽도 영향

📌 예기치 않은 상태 전파 = 버그

---

### 값 객체의 해결 방식

* 변경 시 **새 객체 생성**
* 다른 클라이언트에는 영향 없음

👉 **부수 효과(Side Effect) 제거**

---

## 6. 값 객체가 참조 객체보다 단순한 이유

```text
참조 객체:
- 상태 변경 가능
- 별칭 문제 발생
- 상태 추적 필요

값 객체:
- 상태 불변
- 별칭 문제 없음
- 결과만 보면 됨
```

👉 **단순함의 본질 = 추적할 상태가 없다**

---

## 7. 값 객체를 사용하는 이유 ①

### 👉 개념을 코드로 명확히 표현

### 문제

* `long price`
* `long totalPrice`

👉 읽는 사람은 매번
“이게 금액이지?”를 **머릿속에서 변환해야 함**

---

### 해결

* `Money price`
* `Money totalPrice`

👉 코드 자체가 **개념을 설명**

📌 더 이상 “long = 금액” 변환 불필요

---

## 8. 값 객체를 사용하는 이유 ②

### 👉 중복 로직 제거 (DRY)

### 중복 예시

* 금액 올림 처리
* 금액 계산 규칙

📌 여러 곳에 흩어져 있으면

* 규칙 변경 시 수정 지옥

---

### 해결

* 금액 연산을 Money로 이동
* `plus`, `minus`, `times`로 캡슐화

👉 **중복 제거 + 변경 안전성 확보**

---

## 9. DRY 원칙과 값 객체

### DRY 원칙 정의

> **중복 개념은 시스템 안에 단 하나의 표현만 가져야 한다**

* 모양이 같은 코드 ❌
* **함께 변경되는 코드**가 중복

👉 값 객체는 **개념 중복 제거 도구**

---

## 10. 값 객체와 합성 관계 (Composition)

### 합성 관계란?

* 포함된 객체의 생명주기가
* 포함하는 객체에 종속됨

📌 예

* `Sales`가 사라지면
* 내부의 `Money`도 함께 사라짐

👉 값 객체는 **속성으로 표현되는 게 자연스러움**

---

## 11. 값 객체는 언제 식별하는가?

### 접근 방식

* 미리 “값 객체를 만들어야지” ❌
* **리팩토링 과정에서 발견** ⭕

---

### 값 객체 후보 신호 ⭐

* 항상 함께 초기화됨
* 함께 변경됨
* 여러 메서드에 함께 전달됨
* 함께 검증됨
* 의미상 하나의 개념임

👉 이런 변수 묶음 = 값 객체 후보

---

## 12. 참조 객체 리팩토링의 보조 도구

### 전략

1. 참조 객체 리팩토링 중
2. 숨겨진 개념 발견
3. 값 객체로 분리

👉 참조 객체의 **복잡성 감소**

---

## 13. 전체 흐름 요약 (기억 구조)

```text
문제
- 참조 객체는 복잡하다
- 상태 추적이 어렵다
- 별칭 문제가 있다

해결
- 상태를 값 객체로 분리
- 불변으로 만든다
- 개념을 코드로 표현한다

결과
- 이해 쉬움
- 변경 안전
- 부수 효과 제거
```

---

## ⭐ 반드시 기억해야 할 문장

> **“값 객체는 상태를 관리하지 않는다.
> 의미만 표현한다.”**

---

## 🔑 한 문장 트리거 요약

> **별칭이 걱정되면 → 값 객체
> 개념이 흐릿하면 → 값 객체
> 중복이 보이면 → 값 객체**

---
