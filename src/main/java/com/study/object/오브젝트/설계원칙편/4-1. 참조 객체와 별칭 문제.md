---

# 🧠 작은 클래스 설계 & 값 객체 / 참조 객체 정리

> **핵심 문장**
> 👉 *작은 클래스는 목적을 좁히는 일이다*
> 👉 *공유가 필요하면 참조 객체, 안전이 필요하면 값 객체*

---

## 1. 문제 제기: 클래스는 얼마나 작아야 할까?

### 클래스 크기 딜레마

* ❌ 너무 작으면

    * 클래스 수 폭증
    * 관리·이해 비용 증가
* ❌ 너무 크면

    * 수정, 재사용 어려움
    * 책임이 섞임

👉 **“적절한 클래스 크기”는 감각 문제가 아니라 설계 기준 문제**

---

## 2. 작은 클래스를 만드는 두 가지 방법

### ① 값 객체로 책임 분리

* 클래스의 **일부 로직을 값 객체로 분리**
* 상태가 아닌 **개념 자체를 표현**

### ② 단일 책임 원칙(SRP)

* 클래스가 **한 가지 이유로만 변경되도록 유지**

📌 이번 내용의 초점: **① 값 객체**

---

## 3. 예제 도메인: 게임 매출 관리

### 요구사항 요약

* 게임은 판매 가능한 상품
* 게임마다:

    * 정가
    * 할인율
* 판매 시:

    * 누적 판매 수량
    * 누적 매출 금액
* 영업이익 = 누적 매출의 20%

---

## 4. 1차 설계: Game + Sales

### Game 클래스 (개념 중심)

* title
* price
* discountRate
* `calculateSellPrice()`

👉 **게임 하나의 가격 계산 책임**

---

### Sales 클래스 (상태 중심)

* game
* totalQuantity
* totalPrice
* `addSale(quantity)`
* `profit()`

👉 **누적 판매 상태 관리 책임**

---

## 5. 테스트 시나리오로 드러나는 문제

### 시나리오

* 같은 Game으로

    * `sales` 객체 생성 → 3개 판매
    * `anotherSales` 객체 생성 → 2개 판매

### 결과

* sales.profit() = 5,400원
* anotherSales.profit() = 3,600원

❓ 전체 영업이익은?

👉 **어느 것도 정답이 아님**

---

## 6. 문제의 본질: 상태가 분산됨

### 핵심 문제

* Sales 인스턴스가 **여러 개**
* 각 인스턴스가 **전체 판매 중 일부만 알고 있음**

👉 영업이익은 **부분 상태로는 계산할 수 없는 개념**

---

## 7. 해결 방향: Sales는 하나여야 한다

### 올바른 모델

* Sales 인스턴스는 **오직 하나**
* 모든 판매는 **같은 Sales 객체에 누적**

👉 여러 클라이언트가 **하나의 Sales를 공유**

---

## 8. 참조 객체 (Reference Object)

### 정의

> 여러 클라이언트가 **같은 객체를 공유하며 상태를 변경하는 객체**

### 특징

* 상태가 변한다
* 공유된다
* 시스템 전체 일관성을 유지한다

📌 이 예제에서 `Sales`는 **참조 객체**

---

## 9. 별칭(Alias) 개념 ⭐

### 상황

```java
Sales sales = new Sales(game);
Sales anotherSales = sales;
```

* sales ≠ anotherSales (이름)
* 👉 **같은 객체를 가리킴**

### 결과

* 한 쪽에서 상태 변경
* 다른 쪽에서도 변경된 상태 확인됨

📌 이것을 **별칭(alias)** 이라고 한다

---

## 10. 별칭의 양면성

### 장점

* 여러 클라이언트가 상태 공유 가능
* 중앙 집중적 상태 관리에 유리

### 단점 ⚠️

* 예상치 못한 변경 전파
* 디버깅 난이도 증가
* 객체 간 결합도 상승

👉 **참조 객체의 숙명적인 위험**

---

## 11. 문제의 근본 해결: 값 객체(Value Object)

### 값 객체란?

> 상태가 변하지 않는 객체
> “값 자체”를 표현하는 작은 객체

### 특징

* 불변(Immutable)
* 공유해도 안전
* 변경 시 새 객체 생성

---

## 12. 값 객체 vs 참조 객체 정리

| 구분    | 값 객체         | 참조 객체 |
| ----- | ------------ | ----- |
| 상태 변경 | ❌ 없음         | ⭕ 있음  |
| 공유    | 안전           | 위험    |
| 목적    | 개념 표현        | 상태 누적 |
| 예제    | Price, Money | Sales |

---

## 13. 이번 장의 핵심 결론

```text
Sales는 참조 객체다
→ 상태가 하나로 모여야 한다

참조 객체는 별칭 문제를 만든다
→ 설계 난이도를 높인다

이 복잡성을 낮추는 방법
→ 상태를 값 객체로 분리한다
```

---

## 14. 기억을 위한 핵심 문장

> **“공유가 필요하면 참조 객체,
> 안전이 필요하면 값 객체.”**

---

## 15. 다음 내용 예고 (자연스러운 연결)

* ✔️ 값 객체로 참조 객체의 복잡성 줄이기
* ✔️ Money / Quantity 같은 값 객체 도입
* ✔️ 별칭 문제를 설계로 제거하는 방법

---

### ⭐ 이 내용을 떠올리는 트리거 문장

> **“왜 Sales는 하나여야 하지?” → 참조 객체 → 별칭 → 값 객체**
