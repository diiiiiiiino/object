---

# 🎮 SRP 가이드로 게임 클래스 분리하기

## ― 책임을 “느낌”이 아니라 “근거”로 나누는 방법

---

## 1. 이번 시간의 핵심 목표

* 단일 책임 원칙(SRP)을 **이론이 아닌 절차**로 적용
* 마이클 페더스의 *Working Effectively with Legacy Code* 기반
* **가이드 → 실제 게임 클래스 분리**까지 전 과정을 경험

> 핵심 질문
> **“이 클래스는 왜 변경되는가?”**

---

## 2. SRP 적용 전략 요약 (큰 그림)

1. **가이드 1, 2**
   → *방향 잡기* (책임의 윤곽)
2. **가이드 3, 4**
   → *실제 분리 기준* (핵심)
3. **가이드 5, 6**
   → *설계 품질 개선* (유연성)

👉 실제 분리는 **가이드 3·4가 결정적**

---

## 3. SRP 6가지 가이드 한눈에 정리

### 가이드 1️⃣ 책임을 한 문장으로 써보기

* 메서드 ❌
* **목적 수준 ⭕**

> “이 클래스는 무엇을 위해 존재하는가?”

✔ 문장에 **‘그리고’**가 들어가면 SRP 위반 의심

---

### 가이드 2️⃣ 이름·목적이 비슷한 메서드 묶기

* 정확할 필요 없음
* **초안 수준의 그룹화면 충분**

✔ “이 메서드들은 같은 일을 하고 있는가?”

---

### 가이드 3️⃣ 인스턴스 변수 ↔ 메서드 관계 분석 (**가장 중요**)

* 특정 변수는 특정 메서드 그룹에서만 사용됨
* **함께 사용되는 변수 + 메서드 = 하나의 책임**

✔ 클래스 분리의 **가장 신뢰도 높은 기준**

---

### 가이드 4️⃣ 배타적으로 초기화되는 인스턴스 변수 찾기

* A 상황에서만 초기화되는 변수
* B 상황에서는 사용되지 않음

✔ 초기화 시점이 다르면 **책임도 다르다**

---

### 가이드 5️⃣ 테스트하고 싶은데 private 메서드인가?

* 접근제어자 변경 ❌
* **새 클래스로 이동 + public 메서드 ⭕**

✔ 테스트 요구 = 새로운 책임의 신호

---

### 가이드 6️⃣ 외부 의존성(DB, API, 라이브러리) 확인

* Jackson, DB, 외부 API
* 내가 수정할 수 없는 코드

✔ 외부 변경 → 핵심 로직 영향 = 위험
✔ **의존성 격리 필수**

---

## 4. 분리 전 준비: 단일 추상화 수준 원칙

> ❗ **SRP 적용 전 반드시 선행**

* 모든 메서드를 **조합 메서드**로 리팩터링
* 로직이 잘게 나뉘어 있어야

    * 변수 + 메서드 이동이 쉬움
    * 책임 분리가 가능

👉 “정리되지 않은 클래스는 나눌 수 없다”

---

## 5. 게임 클래스 책임 한 문장으로 써보기 (가이드 1)

> **Game 클래스는**
>
> * 게임 루프를 실행하고
> * 사용자 입력을 받고
> * 입력을 파싱해 명령을 처리하고
> * 플레이어를 이동시키고
> * 지도를 검사하고
> * 화면을 출력한다

✔ 문장만 써도 알 수 있음
👉 **책임이 너무 많다**

---

## 6. 메서드 기준 1차 책임 분류 (가이드 2)

게임 클래스의 메서드를 **6개 카테고리**로 분류

### 1️⃣ 흐름 제어

* `Run`, `Play`, `Start`, `Stop`, `IsRunning`

### 2️⃣ 플레이어 이동

* `TryMove`

### 3️⃣ 지도 구조 관리

* `IsBlocked`, `IsExcluded`, `RoomAt`

### 4️⃣ 사용자 입력

* `Input`, `InputKey`

### 5️⃣ 명령 파싱

* `PassCommand`

### 6️⃣ 화면 출력

* 출력 관련 메서드

> ❗ 정확성보다 **“책임 덩어리가 보이기 시작하는 것”**이 목적

---

## 7. 인스턴스 변수 중심 분석 (가이드 3)

### Game 클래스의 주요 인스턴스 변수

* `running`
* `position`
* `size`
* `rooms`

### 기능 스케치로 관계 시각화

* 메서드 → 사용하는 인스턴스 변수에 선 연결
* 메서드 → 호출하는 메서드도 연결

✔ 결과:

* **같은 변수에 접근하는 메서드들이 자연스럽게 묶임**
* 책임 경계가 눈에 보이기 시작

---

## 8. 지도 관리 책임 발견

### 관찰 결과

* `IsBlocked`, `IsExcluded`, `RoomAt`
* 공통으로 사용하는 변수: `size`, `rooms`

👉 메서드 분류 카테고리
👉 인스턴스 변수 사용 패턴
👉 **완전히 일치**

---

## 9. 책임 이동 결정: WorldMap 클래스

### 왜 분리하는가?

* 지도는 **스스로 구조를 관리하는 객체**가 되는 것이 자연스럽다
* Game이 직접 관리할 이유 없음

### 이동 내용

* 변수: `size`, `rooms`
* 메서드: `IsBlocked`, `IsExcluded`, `RoomAt`

### 변경 후

* Game → `worldMap.isBlocked(...)` 메시지 전송
* 메서드 가시성: `public`

---

## 10. 분리 결과 요약

### Before

```
Game
 ├─ 게임 흐름
 ├─ 입력
 ├─ 명령 파싱
 ├─ 이동
 ├─ 지도 관리
 └─ 출력
```

### After (1차 분리)

```
Game
 ├─ 게임 흐름
 ├─ 입력
 ├─ 명령 파싱
 ├─ 이동
 └─ 출력

WorldMap
 └─ 지도 구조 관리
```

✔ Game 클래스 책임 감소
✔ WorldMap은 **작고 명확한 책임**
✔ SRP 충족

---

## 11. 이번 파트에서 반드시 기억할 포인트

### 🧠 핵심 문장

> SRP는 “잘 나누는 감각”이 아니라 **근거 있는 절차**다
>
> 메서드보다 **인스턴스 변수와 초기화 시점**이 더 중요하다
>
> 책임은 코드가 아니라 **변경 이유로 정의한다**
>
> 정리되지 않은 클래스는 나눌 수 없다

---

## 12. 한 줄 요약

> **SRP는
> “메서드를 나누는 원칙”이 아니라
> “변경의 이유를 따라 클래스를 이동시키는 원칙”이다**

---