---

# 다형적 개방-폐쇄 원칙(OCP) 핵심 요약

## 1. 문제의 출발점

> **전통적인 OCP(상속 기반 코드 재사용)는 런타임 오류를 유발할 수 있다.**

* 상속을 통해 기능을 확장하면
* **업캐스팅 / 잘못된 클라이언트 사용 / 의미 붕괴**가 발생 가능
* 결과적으로 **예상하지 못한 런타임 오류**로 이어짐

---

## 2. 다형적 개방-폐쇄 원칙이란?

> **“수정 없이 확장하되, 다형성을 전제로 안정적으로 동작해야 한다.”**

### 핵심 차이

| 전통적 OCP      | 다형적 OCP          |
| ------------ | ---------------- |
| 코드 재사용 목적    | **다형성 보장 목적**    |
| 상속 = 재사용     | **상속 = 대체 가능성**  |
| 컴파일 타임 확장 중심 | **런타임 안전성까지 고려** |

---

## 3. OCP 재정의 (로버트 C. 마틴 관점)

### Open (개방)

* **기존 코드 수정 없이**
* **새 클래스를 추가해 기능 확장 가능**

### Closed (폐쇄)

* 기존 클래스는 **변경하지 않음**
* **안정적인 추상화에 고정**

> **확장은 “추가”, 수정은 “금지”**

---

## 4. 핵심 수단 = 안정적인 추상화

### 결론

> **“OCP는 상속이 아니라 ‘안정적인 추상화’를 중심으로 성립한다.”**

* Reader Interface
* Abstract Reader
* CallCollector Interface
  → **변하지 않는 계약(Contract)** 이 핵심

---

## 5. 예제 요약 — Reader 확장 (CSV → JSON → XML)

### 구조

* Reader Interface / Abstract Reader = **안정적**
* CSVReader, JSONReader, XMLReader = **확장 포인트**

### 효과

* 기존 코드 수정 없음
* 새로운 Reader만 추가하여 기능 확장

> **개방 = 새 구현 추가**
> **폐쇄 = 기존 코드 변경 없음**

---

## 6. 전통적 OCP의 문제 — 상속 기반 재사용

### BillingCallCollector 사례

* CallCollector를 상속해 필터 기능 추가
* 업캐스팅 시 **의도치 않은 동작 발생**
* LongestCallSelector가 기대한 결과와 불일치

### 문제 본질

> **“상속이 다형성을 깨뜨릴 수 있다.”**

---

## 7. 왜 단순 인터페이스 상속만으로는 부족한가?

### 문제

* 인터페이스를 공유해도
* **동작 의미(계약)가 동일하지 않으면**
* 런타임에서 오류 발생

> **타입은 같지만, 의미가 다름**

---

## 8. 다형적 OCP의 진짜 목표

> **“어떤 구현이 와도 기존 클라이언트가 깨지지 않게 한다.”**

* 새로운 클래스가 추가되어도
* 기존 코드가 **동일하게 동작한다고 믿을 수 있어야 함**

---

## 9. 전통적 OCP vs 다형적 OCP — 본질 비교

| 항목    | 전통적 OCP | 다형적 OCP        |
| ----- | ------- | -------------- |
| 목적    | 코드 재사용  | **다형적 대체 가능성** |
| 확장 방식 | 상속      | **추상화 기반 확장**  |
| 위험    | 업캐스팅 오류 | **계약 위반 방지**   |
| 초점    | 컴파일 타임  | **런타임 안전성 포함** |

---

## 10. 상속에는 두 가지 다른 목적이 있다

### ① 구현 상속 (Implementation Inheritance)

* 목적 = **코드 재사용**
* 위험 = 의미 붕괴, 런타임 오류

### ② 인터페이스 상속 (Interface Inheritance)

* 목적 = **다형성 보장**
* 안정적 계약 중심

> **“재사용을 위한 상속”과 “대체를 위한 상속”은 다르다.**

---

## 11. 재사용은 상속이 아니라 합성(Composition)

### 교훈

> **코드를 재사용하고 싶다면 상속이 아니라 합성을 사용하라.**

* BillingCallCollector → CallCollector를 **참조**
* 상속 제거 → 업캐스팅 문제 제거
* OCP 안정성 확보

---

## 12. 핵심 결론 — OCP만으로는 충분하지 않다

### 문제

* 다형적 OCP는 **컴파일 타임 확장만 보장**
* **런타임 안전성은 보장하지 않음**

### 필요

> **“확장된 타입이 부모 타입을 안전하게 대체할 수 있는가?”**

→ 여기서 **LSP(리스코프 치환 원칙)** 등장

---

## 13. 최종 교훈 요약

* OCP의 핵심은 **상속이 아니라 안정적인 추상화**
* 확장은 **기존 코드를 수정하지 않고 추가로 수행**
* 상속 기반 재사용은 **다형성을 깨뜨릴 수 있음**
* 재사용 목적이라면 **합성이 더 안전**
* **다형적 OCP만으로는 부족 → LSP가 필요**

---

## 14. 초압축 기억 버전

```
전통적 OCP = 상속으로 재사용 → 런타임 위험
다형적 OCP = 추상화로 확장 → 대체 가능성 요구

핵심:
확장은 "추가"
수정은 "금지"
상속 목적 = 다형성 보장, 재사용은 합성

결론:
OCP만으로 부족 → LSP로 이어짐
```

---