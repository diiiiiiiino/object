---

# 🧠 run 메서드 리팩토링 — 오래 기억하는 정리

> **핵심 문장**
> 👉 `run()`은 구현이 아니라 **시나리오**다
> 👉 같은 추상화 수준의 메서드로 **문장처럼 읽히게** 만들어라

---

## 1. 문제 인식: run 메서드는 왜 항상 문제인가?

### run 메서드의 전형적인 특징

* 이해하기 어렵다
* 수정하기 어렵다
* 테스트하기 어렵다
* **여러 추상화 수준의 코드가 한 메서드에 섞여 있다**

📌 run 메서드는
👉 **God Method**
👉 **단일 추상화 수준 원칙(SLAP)을 어긴 대표 사례**

---

## 2. 핵심 원칙: 단일 추상화 수준 원칙 (SLAP)

### 원칙 요약

* 한 메서드 안에서는 **같은 수준의 일만** 해야 한다
* “무엇을 한다”와 “어떻게 한다”를 섞지 않는다

```text
❌ 고수준 흐름 + 저수준 구현 섞임
⭕ 고수준은 위로, 세부 구현은 아래로
```

---

## 3. 1단계 리팩토링: 주석으로 역할 나누기

### run 메서드에서 발견되는 3가지 역할

1. 환영 메시지 출력
2. 게임 플레이 진행
3. 종료 메시지 출력

📌 아직 메서드를 뽑지 않는다
👉 **먼저 의미를 드러낸다**

```text
run = welcome → play → farewell
```

---

## 4. 2단계 리팩토링: 주석 → 메서드 이름

### 가장 중요한 기준

> **좋은 메서드 이름은 “호출하는 쪽(클라이언트)의 의도”를 드러낸다**

### 추출된 메서드

* `welcome()`
* `play()`
* `farewell()`

📌 주석은 제거
📌 `run()`은 이제 **조합 메서드(Composition Method)**

```java
run() {
  welcome();
  play();
  farewell();
}
```

👉 문장처럼 읽힌다

---

## 5. 메서드는 언제까지 추출해야 할까?

### 판단 기준 ⭐

> **메서드가 “한 가지 이유”로만 변경될 때까지**

* 한 메서드 = 하나의 목적
* 하나의 목적 = 하나의 변경 이유

📌 예시

* `showRoom()`

    * 방 이름 + 방 설명 출력
      → 클라이언트 관점에서는 **하나의 이유**
      → 더 쪼갤 필요 ❌

---

## 6. 응집도 관점에서 본 리팩토링 효과

### 리팩토링 전 (응집도 낮음)

* welcome 메서드가 변경되는 이유

    * 인삿말 변경
    * 방 정보 변경
    * 도움말 변경

### 리팩토링 후 (응집도 높음)

* `printGreeting()`
* `showRoom()`
* `showHelp()`

👉 각 메서드는 **한 이유로만 변경됨**

---

## 7. 기능 확장에 강해지는 구조 (look / help)

### 리팩토링 덕분에 가능해진 것

* `look` 명령 → `showRoom()` 재사용
* `help` 명령 → `showHelp()` 재사용

📌 만약 메서드 추출이 없었다면?

* 중복 코드 증가
* 기능 추가 시 수정 범위 폭발

---

## 8. play 메서드 리팩토링 핵심

### 1️⃣ 이동 로직 추출

* `moveNorth()`
* `moveSouth()`
* `moveEast()`
* `moveWest()`

👉 “플레이어가 동서남북으로 이동한다”는 사실이 **한눈에 보임**

---

### 2️⃣ 상태 관리 의도 드러내기

* `start()`
* `isRunning()`
* `stop()`

📌 boolean 플래그가 아니라
👉 **의도를 가진 메시지**

---

## 9. 중복 코드는 “추출 신호”다

### 발견된 중복 → 추출

* 방 정보 출력 → `showRoom()`
* 좌표로 방 찾기 → `roomAt(x, y)`
* 이동 불가 메시지 → `showBlocked()`

📌 중복을 보면 이렇게 질문한다:

> “이건 이름을 가질 수 있지 않을까?”

---

## 10. 이동 로직 일반화 (tryMove)

### 문제

* `moveNorth / South / East / West` 형태가 거의 동일

### 해결

* 공통 흐름 → `tryMove(dx, dy)`

```text
공통 흐름:
1. 이동 가능 여부 판단
2. 좌표 변경
3. 방 정보 출력
```

---

## 11. 조건문도 의도를 기준으로 쪼갠다

### 추출된 메서드

* `blocked()`
* `roomAt()`
* `excluded()` (좌표 범위 체크)

📌 조건문의 목적이 이름으로 드러나면
👉 이해 비용이 급감한다

---

## 12. 저수준 로직은 아래로 내린다

### 추상화 수준 정리

* 입력 프롬프트 출력 → `showPrompt()`
* 키보드 입력 → `input()`
* 명령 파싱 → `parseCommand()`

👉 `play()`는 이제
**게임 규칙만 표현하는 고수준 메서드**

---

## 13. 진짜 리팩토링의 완성: 책임 이동

### 핵심 개념

> **메서드를 뽑는 것은 시작일 뿐
> 진짜 리팩토링은 “어디로 옮길 것인가”다**

* 단일 책임 원칙 (SRP)
* 객체는 자기 책임만 갖는다

📌 객체지향에서 이것을 **책임 이동**이라 부른다

---

## 14. 기억을 위한 최종 구조 요약

```text
문제
- run 메서드는 항상 복잡하다

원인
- 여러 추상화 수준이 섞여 있음

해결 흐름
1. 주석으로 역할 구분
2. 주석 → 메서드 이름
3. run → 조합 메서드
4. 한 메서드 = 한 이유
5. 중복은 추출 신호
6. 의도는 이름으로
7. 책임은 객체로
```

---

## ⭐ 이 내용을 기억하게 만드는 문장

> **“run은 구현이 아니라 시나리오다.
> 세부는 아래로, 의도는 이름으로.”**

---
