
# 🧠 명령–쿼리 분리 원칙 (CQS) — 오래 기억하는 정리

## 1. 루틴과 메서드의 기본 개념

* **루틴(Routine)**
  호출 가능한 로직의 묶음
  모든 프로그래밍 언어는 루틴을 이름으로 호출하는 문법을 제공함

* **메서드(Method)**
  객체지향 언어에서 **객체에 연결된 루틴**

## 2. 프로시저 vs 함수

### 🔸 프로시저 (Procedure)

* **부수 효과 있음**
* **값을 반환하지 않음**
* 예:

    * 메모리 상태 변경
    * 파일 내용 수정

### 🔸 함수 (Function)

* **부수 효과 없음**
* **값을 반환함**
* 예:

    * 입력 → 계산 → 결과 반환
    * 객체/파일 상태는 변경하지 않음

---

## 3. 명령(Command) vs 쿼리(Query)

> 프로시저/함수를 객체 관점으로 확장한 개념

### 🔸 명령 (Command)

* 객체의 **상태를 변경**
* **값을 반환하지 않음**

### 🔸 쿼리 (Query)

* 객체의 **상태를 변경하지 않음**
* **값을 반환함**

---

## 4. 명령–쿼리 분리 원칙 (CQS)

> **한 메서드는 명령이거나 쿼리 중 하나여야 한다**

### 핵심 규칙

* ❌ 상태 변경 + 값 반환 → **금지**
* ✅ 상태 변경만 → 명령
* ✅ 값 반환만 → 쿼리

### 이유

* 동작을 **이해·예측**하기 어려워짐
* 호출 순서에 따라 결과가 달라짐
* 테스트와 추론이 어려워짐

---

## 5. 시그니처로 의도를 드러내라

| 메서드 시그니처 | 의미 |
| -------- | -- |
| 반환값 있음   | 쿼리 |
| 반환값 없음   | 명령 |

👉 **구현을 보지 않고도 부수 효과를 예측 가능**

---

## 6. 반복 일정(Recurring Plan) 예제로 보는 문제

### 기존 구조

* `include(date)`

    * 날짜 포함 여부를 반환
    * ❌ 내부에서 일정 조정까지 수행

### 문제점

* 같은 메서드를 두 번 호출하면 결과가 달라짐
* 파라미터에 따라 객체 상태가 암묘하게 변경됨
* 실행 결과가 직관적이지 않음

---

## 7. 문제의 본질

> **include 메서드가**

* 쿼리처럼 보이지만
* 실제로는 **명령 역할도 수행**

➡️ **명령 + 쿼리 혼합**

---

## 8. 해결 1️⃣ : 메서드 수준 분리

### 분리 후 구조

* `include(date)`

    * ✅ **쿼리**
    * 상태 변경 ❌
    * 여러 번 호출해도 결과 동일

* `adjust(date)`

    * ✅ **명령**
    * 상태 변경 전담

### 효과

* 실행 결과 예측 가능
* 코드 읽기 쉬워짐
* 테스트 안정성 증가

---

## 9. 해결 2️⃣ : 값 객체(Value Object) 도입

### 핵심 아이디어

* **RecurringPlan을 불변 객체**로 만든다
* 상태 변경 ❌
* 변경이 필요하면 **새 객체를 반환**

### 변경 전

* `reschedule()` → 내부 상태 변경

### 변경 후

* `reschedule()` → **새 RecurringPlan 반환**

---

## 10. 책임의 이동 (Side Effect 격리)

| 책임       | 위치            |
| -------- | ------------- |
| 일정 규칙 계산 | RecurringPlan |
| 실제 상태 변경 | Schedule      |

➡️ **부수 효과는 메시지를 받는 객체 안에서만 발생**

---

## 11. 게임 예제로 보는 명령–쿼리 분리

### 문제 상황

* `move()` 메서드

    * 이동 가능 여부 반환 (쿼리처럼 보임)
    * 실제 위치 변경 (명령)

➡️ 호출 결과 예측 불가

---

## 12. 게임 예제 해결

### 메서드 분리

* `canMove()`

    * 쿼리
    * 이동 가능 여부만 반환

* `move()`

    * 명령
    * 실제 위치 변경

* `tryMove()`

    * 흐름 제어용 메서드
    * 내부에서 `canMove → move` 순서로 호출

---

## 13. 시카프 원칙(SRP)과의 관계

* 플레이어가

    * 스스로 판단 (`canMove`)
    * 스스로 상태 변경 (`move`)

👉 **SRP 위반 아님**

---

## 14. 명령–쿼리 분리의 진짜 이점

### ✅ 장점 요약

* 실행 결과 예측 가능
* 메서드 시그니처만 보고 이해 가능
* 테스트 용이
* 부수 효과 분석 범위 축소
* 클래스 간 결합도 감소

---

## 15. 핵심 한 줄 요약 🧩

> **부수 효과가 있는 로직과 없는 로직을
> 메서드 수준에서 명확히 분리하라**

> **가능하면 상태 변경은 값 객체 교체로 표현하라**

---

## 16. 기억을 돕는 체크리스트 ✅

* [ ] 이 메서드는 상태를 바꾸는가?
* [ ] 값을 반환하는가?
* [ ] 둘 다 하고 있다면 분리했는가?
* [ ] 여러 번 호출해도 결과가 같은가?
* [ ] 시그니처만 보고 의도가 드러나는가?

---