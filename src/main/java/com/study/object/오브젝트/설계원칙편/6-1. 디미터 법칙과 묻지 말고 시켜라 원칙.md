---

# 🔐 캡슐화를 지키는 두 가지 원칙

## ― 디미터 법칙 & 묻지 말고 시켜라

---

## 1. 왜 캡슐화가 깨졌는가?

### 문제 상황

* 콘솔 출력(`System.out`)에 직접 의존
* 테스트에서 출력 결과를 가로채야 함
* Player, Game 모두 콘솔에 의존

👉 **테스트가 어렵다 = 설계가 잘못됐다**

---

## 2. 관찰: Player 클래스 안의 서로 다른 책임

Player 안의 메서드들을 보면:

| 메서드           | 의존 대상              | 변경 이유     |
| ------------- | ------------------ | --------- |
| `tryMove`     | WorldMap, Position | 이동 규칙 변경  |
| `showBlocked` | Console            | 출력 메시지 변경 |
| `showRoom`    | Console            | 출력 포맷 변경  |

👉 **의존 대상이 다르다 = 변경 이유가 다르다**
👉 **SRP + 캡슐화 위반**

---

## 3. 외부 의존성은 한 곳으로 모아라

### 판단

* 콘솔 출력은 **불안정한 외부 메커니즘**
* 여러 클래스가 콘솔에 의존하면 변경 영향이 전파됨

### 결정

* **Game만 콘솔에 의존**
* Player는 콘솔을 전혀 모르게 만든다

👉 의존성 **집중(encapsulation)**

---

## 4. 출력 로직 이동

### 이동 대상

* `showBlocked`
* `showRoom`

### 결과

* Player → 순수 도메인 객체
* Game → 출력 책임 담당

👉 Player 테스트에서 콘솔 검증 제거 가능

---

## 5. 새로운 문제: tryMove 안의 이중 책임

`tryMove`에는 두 가지가 섞여 있음:

1. **플로우 제어**

    * 성공 / 실패에 따라 출력 결정
2. **도메인 로직**

    * 실제 위치 이동

👉 서로 다른 책임 → 분리 대상

---

## 6. 책임 재배치의 핵심 결정

| 역할     | 책임                     |
| ------ | ---------------------- |
| Player | “나는 이동할 수 있는가? → 이동한다” |
| Game   | 이동 결과에 따라 무엇을 보여줄지 결정  |

👉 Player는 **결정 + 상태 변경**
👉 Game은 **조율자**

---

## 7. 디미터 법칙 (Law of Demeter)

### 핵심 개념

> **협력 객체의 내부 구조를 알지 말라**
> **오직 가까운 이웃에게만 메시지를 보내라**

### 허용되는 메시지 대상

* `this`
* 메서드의 파라미터
* 인스턴스 변수
* 메서드 내부에서 생성한 지역 객체
* 인스턴스 변수로 선언된 컬렉션의 요소

---

### 왜 필요한가?

* 객체 사이 구조 변경 시
* 변경 영향이 연쇄적으로 전파되는 걸 방지

👉 **결합도 감소**

---

## 8. 디미터 법칙 위반의 전형적 냄새

```java
game.player.worldMap.isBlocked(...)
```

* “기차 충돌(train wreck)” 코드
* 내부 구조를 너무 많이 앎

👉 Player 내부 구조에 Game이 결합됨

---

## 9. 해결 방향: 내부 구조를 감춘 인터페이스

### 잘못된 방식

* Game이 Player에게 묻는다
* Player의 내부 객체(WorldMap, Position)를 꺼내 쓴다

### 올바른 방식

* Game은 Player에게 **시킨다**
* Player가 내부에서 판단하고 처리

---

## 10. 묻지 말고 시켜라 (Tell, Don’t Ask)

### 원칙

> 객체의 상태를 묻지 말고
> **원하는 행동을 요청하라**

---

### 위반 예

```java
if (player.canMove(worldMap)) {
    player.move();
}
```

### 준수 예

```java
player.move(worldMap);
```

* 판단 + 상태 변경은 **Player 책임**

---

## 11. Player를 자율적인 객체로 만들기

### 변경 전

* Game이 Player 상태를 묻고
* Game이 Player 상태를 바꿈

### 변경 후

* Player가 스스로 판단
* Player가 스스로 상태 변경
* 결과만 반환 (`true / false`)

👉 **자율 객체 완성**

---

## 12. currentRoom 메서드와 디미터 법칙

### 의문

> `player.currentRoom()`도 내부 구조 노출 아닌가?

### 답

* **아니다**
* 내부 구조(WorldMap, Room 관계)를 드러내지 않음
* “현재 방”이라는 **의미만 제공**

👉 디미터 법칙은
**“구조 노출”을 막는 원칙이지
“모든 정보 접근”을 막는 원칙이 아니다**

---

## 13. 테스트 관점에서의 변화

### Before

* Player 테스트 시 콘솔 출력 검증 필요
* 테스트가 길고 모호

### After

* Player 테스트:

    * `move()` 호출
    * 위치 변화만 검증
* 출력 없음
* **명확한 입력 → 명확한 결과**

👉 테스트가 곧 설계 품질 지표

---

## 14. 책임 재배치의 최종 결과

| 클래스      | 책임            |
| -------- | ------------- |
| Player   | 이동 판단 + 상태 변경 |
| Game     | 흐름 제어 + 출력    |
| WorldMap | 지도 구조 관리      |

* Player는 더 이상 콘솔 의존 ❌
* Game은 Player 내부 구조 모름 ❌
* 디미터 법칙 충족
* 묻지 말고 시켜라 충족

---

## 15. 꼭 기억할 문장들 (암기용)

> 디미터 법칙은
> **객체 사이 구조 결합을 끊는 원칙이다**
>
> 묻지 말고 시켜라는
> **자율적인 객체를 만드는 원칙이다**
>
> 테스트가 어렵다면
> 캡슐화가 깨졌을 가능성이 높다

---

## 16. 한 줄 요약

> **캡슐화를 지키는 설계란
> “구조를 숨기고 행동만 드러내는 설계”다**

---

## 17. 지금까지 얻은 설계 상태

* SRP: 변경 이유 기준으로 책임 분리
* 테스트: 도메인 객체는 출력 없음
* 디미터 법칙: 내부 구조 차단
* 묻지 말고 시켜라: 자율 객체

👉 **변경에 강하고 테스트하기 쉬운 구조**

---