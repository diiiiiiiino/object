---

# 🧪 SRP를 테스트 관점에서 완성하기

## ― private 메서드는 “테스트 불가”가 아니라 “책임 과다”의 신호다

---

## 1. 이번 시간의 출발점

### 문제 인식

* Game 클래스 안에 **테스트가 꼭 필요한 private 메서드**들이 있음

    * `tryMove` : 플레이어 이동 핵심 로직
    * `parseCommand / passCommand` : 명령 파싱 핵심 로직
* 하지만 private이라 **직접 테스트 불가능**

👉 단순히 `public`으로 바꾸는 건 **캡슐화 파괴**
👉 **SRP 관점에서 문제를 다시 봐야 함**

---

## 2. 핵심 관점 전환

> ❌ “private 메서드를 어떻게 테스트할까?”
> ✅ “왜 이 메서드는 private일까?”

### 중요한 통찰

* **테스트가 필요한 로직인데 private**
  → 이 메서드는 **현재 클래스의 책임이 아닐 가능성**이 높다

---

## 3. 첫 번째 대상: tryMove 메서드

### tryMove의 특징

* 플레이어 이동은 **게임의 핵심 규칙**
* 버그가 나면 정상 플레이 불가
* 반드시 **자동화 테스트 필요**

### 결론

* `tryMove`는 Game의 보조 로직이 아님
* **독립된 책임을 가져야 함**
* → 다른 클래스로 이동해야 함

(※ 이번 파트에서는 개념 소개 위주, 실제 이동은 이후 단계)

---

## 4. 두 번째 대상: parse / passCommand 메서드

### 원래 상태

* Game 클래스 내부 private 메서드
* 역할이 섞여 있음:

    1. 명령 문자열 파싱
    2. 파싱 결과에 따라 Game 메서드 실행

👉 **파싱 + 실행 = 서로 다른 책임**

---

## 5. 첫 번째 시도: CommandParser 클래스로 이동

### 시도 내용

* `PassCommand` → `CommandParser` 클래스로 이동
* 테스트 가능해짐 ❌ (문제 발생)

### 발생한 문제

* CommandParser가 Game을 참조
* Game이 다시 CommandParser를 참조

👉 **양방향 참조 발생**

---

## 6. 양방향 참조의 위험성

### 왜 문제인가?

* 두 클래스가 **함께 변경될 가능성** ↑
* 테스트 시:

    * CommandParser 테스트하려면
    * Game 인스턴스도 필요

👉 **결합도 급증**
👉 사실상 **하나의 클래스처럼 움직임**

---

## 7. 문제의 진짜 원인

### 다시 질문

> parseCommand를 테스트하려는 이유는?

* 사용자가 입력한 문자열이
* **정상적으로 파싱되는지 확인**하고 싶을 뿐

👉 **명령 실행 로직은 테스트 대상이 아님**

---

## 8. 책임 재정의: 파싱과 실행 분리

### 핵심 결정

* ❌ “파싱 + 실행”을 한 메서드에 두지 말자
* ✅ “파싱”만 CommandParser의 책임으로 한정

---

## 9. 새로운 설계 방향

### 역할 분리

| 역할            | 책임               |
| ------------- | ---------------- |
| CommandParser | 문자열 → Command 객체 |
| Game          | Command 실행       |

👉 CommandParser는 **Game을 몰라도 됨**

---

## 10. Command 객체 도입 (핵심 전환점)

### 설계

* CommandParser는 **Command를 반환**
* Game은 반환된 Command를 실행

### Command 설계

* 처리 가능한 명령이 정해져 있음
* `sealed interface Command` 사용
* 구현체:

    * `Move`
    * `Loop`
    * `Help`
    * `Quit`
    * `Unknown`

---

## 11. 실행 흐름 (Before / After)

### Before

```
Game
 └─ passCommand()
     ├─ parse
     └─ execute
```

### After

```
CommandParser
 └─ parse() → Command

Game
 └─ execute(Command)
```

👉 **의존성 단방향 유지**
👉 테스트 대상 완전히 분리

---

## 12. 테스트 관점에서의 변화

### Before

* CommandParser 테스트하려면

    * Game 생성 필요
    * 콘솔 출력 검증 필요
    * 테스트 복잡도 ↑

### After

* CommandParser 테스트:

    * 문자열 입력
    * 반환된 Command 타입만 검증
* Game 테스트:

    * Command를 직접 전달
    * 실행 결과 검증

👉 **테스트 단순 + 명확**

---

## 13. SRP와 테스트의 관계 (핵심 정리)

> 테스트가 어려운 클래스는
> **대부분 책임이 너무 많다**

### 테스트 냄새 체크리스트

* 픽스처가 너무 많다
* mock이 과도하다
* 실행 경로가 너무 많다
* private 메서드를 테스트하고 싶다

👉 **SRP 위반 가능성 높음**

---

## 14. WorldMap 분리와의 연결

### 이전 시간

* `isBlocked` → WorldMap 클래스로 이동
* private → public
* 테스트 가능해짐

### 공통 패턴

* 테스트해야 할 중요한 로직
* private에 숨겨져 있음
* → **책임을 다른 클래스로 이동**

---

## 15. 이번 파트의 결정적 문장들 (암기용)

> private인데 테스트하고 싶다면
> 그 메서드는 잘못된 클래스에 있다
>
> 테스트는 설계를 평가하는 도구다
>
> 테스트하기 쉬운 클래스는
> 대부분 SRP를 잘 지킨 클래스다
>
> 파싱과 실행은 절대 같은 책임이 아니다

---

## 16. 한 줄 요약

> **SRP를 테스트 관점에서 적용하면
> “테스트가 쉬운 구조 = 책임이 명확한 구조”가 된다**

---

## 17. 지금까지 분리된 핵심 클래스들

* `WorldMap` : 지도 구조 관리
* `CommandParser` : 명령 파싱
* `Command` (sealed) : 명령 표현
* `Game` : 명령 실행 + 게임 흐름

👉 **응집도 ↑ / 결합도 ↓**

---

## 18. 마지막 메시지

> 테스트를 어렵게 만드는 설계는
> 언젠가 변경을 어렵게 만든다
>
> **SRP는 테스트를 위한 가장 현실적인 원칙이다**

---