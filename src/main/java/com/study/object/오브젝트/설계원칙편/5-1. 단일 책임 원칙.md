---

# 🧭 단일 책임 원칙(SRP)로 클래스 나누기

## ― 변경의 이유로 책임을 정의하라

---

## 1. 이번 시간의 주제 요약

* 지난 시간: **값 객체(Value Object)** 로 클래스를 작게 만드는 방법
* 이번 시간: **단일 책임 원칙(SRP)** 으로 클래스를 분리하는 방법
* 핵심 질문:

  > “이 클래스는 **왜** 변경되는가?”

---

## 2. 예제 도메인: 반복 일정 관리 프로그램

### 📌 요구사항

* 매달 반복되는 일정 등록
* 예:

    * 매달 **두 번째 월요일**
    * 오후 **2시**
    * **1시간** 동안 진행

### 📌 주요 기능

* 특정 날짜에 일정이 열리는지 확인 (`includes`)
* 일정 정보를 JSON 문자열로 변환 (`toJSON`)

---

## 3. 초기 Schedule 클래스의 책임

Schedule 클래스는 다음을 모두 포함:

1. 반복 일정의 **규칙 관리**

    * 요일
    * 주차
    * 시작 시간
    * 기간
2. 특정 날짜에 일정이 열리는지 판단 (`includes`)
3. 일정 정보를 JSON으로 직렬화 (`toJSON`)

    * Jackson `ObjectMapper` 사용

👉 겉보기엔 “하나의 클래스”
👉 하지만 **변경 이유는 여러 개**

---

## 4. 클래스 크기를 판단하는 기준

### ❌ “라인 수가 많다 / 적다”는 기준이 아님

### ✅ 올바른 기준

> **이 클래스는 몇 가지 이유로 변경되는가?**

이 기준이 바로 **단일 책임 원칙(SRP)**

---

## 5. 단일 책임 원칙(SRP)의 정확한 의미

### 📌 SRP 정의

> **클래스는 단 하나의 변경 이유만 가져야 한다**

* “기능이 하나” ❌
* “메서드가 하나” ❌
* **“변경의 이유가 하나”** ⭕

---

## 6. GRASP 책임과 SRP 책임의 차이

| 구분       | 의미                      |
| -------- | ----------------------- |
| GRASP 책임 | 객체가 **외부에 제공하는 역할/서비스** |
| SRP 책임   | 클래스가 **변경되는 이유**        |

👉 SRP의 책임이 **더 큰 개념**
👉 SRP는 **응집도, 결합도와 직접 연결**

---

## 7. 응집도(Cohesion) 관점에서 본 SRP

### 📌 응집도란?

* **함께 변경되는 코드들의 밀집도**

### 판단 기준

* 같은 이유로 변경되면 → **응집도 높음**
* 다른 이유로 변경되면 → **응집도 낮음**

👉 SRP를 지키면 응집도가 자연스럽게 높아짐

---

## 8. 문제 상황: 서로 다른 변경 이유가 섞인 클래스

### 예시 (비유)

* 원, 삼각형, 사각형 코드가 **한 클래스에 섞여 있음**
* 각각 **다른 개발자**, **다른 이유**로 수정

### 발생하는 문제

* 한 부분 수정 → 다른 부분까지 영향
* 예상 못 한 부수 효과(side effect)
* 동시 수정 시 충돌 위험 증가

👉 **변경 단위가 너무 큼**

---

## 9. 결합도(Coupling) 관점에서 본 문제

### 📌 결합도란?

* **외부 변경이 나에게 영향을 주는 정도**

Schedule 클래스는:

* Jackson 라이브러리에 직접 의존
* JSON 포맷 변경 시 클래스 전체 영향

👉 외부 변경 → 관련 없는 로직까지 흔들림
👉 **결합도 높음**

---

## 10. Schedule 클래스의 실제 변경 이유 분석

| 코드         | 변경 이유              |
| ---------- | ------------------ |
| `includes` | 일정 계산 방식 변경        |
| `toJSON`   | JSON 포맷 / 라이브러리 변경 |

👉 **변경 이유가 2개**
👉 SRP 위반

---

## 11. SRP에 따른 해결 방법

### 핵심 전략

> **변경 이유가 다른 코드를 서로 다른 클래스로 분리한다**

---

## 12. 리팩터링 결과

### 분리 전

```
Schedule
 ├─ includes()
 └─ toJSON()  ← Jackson 의존
```

### 분리 후

```
Schedule
 └─ includes()  ← 일정 판단 책임

ScheduleJson
 └─ toJSON()    ← JSON 변환 책임
```

---

## 13. 분리 후 얻는 효과

### ✅ Schedule 클래스

* “일정이 열리는지 판단”만 책임
* JSON 포맷 변경과 무관
* 응집도 ↑

### ✅ ScheduleJson 클래스

* JSON 포맷 변경 시 여기만 수정
* Jackson 의존성 격리
* 결합도 ↓

---

## 14. SRP의 진짜 목적

> **클래스를 작게 만들어
> 안전하게 수정할 수 있게 만드는 것**

* 수정 시 읽어야 할 코드 ↓
* 영향 범위 ↓
* 협업 시 충돌 ↓
* 버그 발생 확률 ↓

---

## 15. SRP는 “한 번” 적용하는 원칙이 아니다

* 요구사항이 바뀌면
* 변경 이유도 바뀜
* ⇒ **다시 분리해야 할 수도 있음**

👉 SRP는 **지속적인 리팩터링 기준**

---

## 16. 기억을 위한 핵심 문장

### 🧠 반드시 기억할 문장들

> 클래스는 **하나의 이유로만** 변경되어야 한다
>
> SRP의 책임은 **기능이 아니라 변경의 이유**다
>
> SRP는 **응집도를 높이고 결합도를 낮춘다**
>
> 큰 클래스는 **여러 이유로 변경되기 때문에 위험하다**

---

## 17. 한 줄 요약

> **단일 책임 원칙이란
> “변경의 이유를 기준으로 클래스를 나누는 원칙”이다**

---