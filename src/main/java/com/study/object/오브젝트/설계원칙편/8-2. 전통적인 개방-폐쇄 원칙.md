---

# 개방-폐쇄 원칙(OCP) & 상속의 함정 — 핵심 요약

## 1. OCP(개방-폐쇄 원칙) 한 줄 정의

> **기존 코드를 수정하지 않고, 확장을 통해 새로운 기능을 추가할 수 있어야 한다.**

* **확장에는 열려 있고(Open)**
* **수정에는 닫혀 있어야(Closed)** 함

---

## 2. 문제 상황 — 통화 기록 기능 확장

### 요구사항 추가

* **발신번호별 통화 요금 계산**
* **10초 이상 통화만 필터링**
* **특정 번호의 가장 긴 통화 찾기**

### 목표

> 기존 `CallCollector` 코드를 **수정하지 않고 재사용**하여 기능 확장

---

## 3. 1차 확장 — 상속으로 BillingCallCollector 추가

### 전략

* `CallCollector`를 상속
* `collect()`를 오버라이드
* 부모 결과를 가져와 **10초 이상 통화만 필터링**

### 장점

* 기존 코드 수정 없음
* 새로운 요구사항을 **자식 클래스에서 확장**

> → 겉보기엔 OCP를 잘 만족

---

## 4. 2차 확장 — LongestCallSelector 추가

### 기능

* 특정 번호의 **가장 긴 통화 기록 선택**
* 내부에서 `CallCollector`를 사용

### 구조

```
LongestCallSelector → CallCollector
```

> Collector를 재사용하여 **새 기능 추가**

---

## 5. 숨겨진 문제 — 상속 + 업캐스팅(Upcasting)

### 문제 시나리오

* `BillingCallCollector`가 `CallCollector`로 **업캐스팅**됨
* `LongestCallSelector`는 **자식 존재를 모름**
* 필터링된 데이터 대신 **예상과 다른 결과 반환**

### 결과

* 테스트 실패
* 동작이 **맥락에 따라 달라짐**
* 상속 계층이 **의도치 않게 깨짐**

---

## 6. 문제의 본질

### 상속 기반 재사용의 위험

* **부모-자식 관계가 의미적으로 불완전**
* 부모 타입으로 다루면 자식의 **확장 의미가 사라짐**
* **확장 코드가 호출자 모르게 무력화됨**

> **“코드 재사용만을 위한 상속은 설계를 깨뜨린다.”**

---

## 7. OCP를 지키려다 OCP를 깨는 역설

### 겉보기

* 수정 없이 기능 확장 → OCP 준수

### 실제

* 새로운 클라이언트(`LongestCallSelector`)에서 **기존 동작 가정 붕괴**
* 확장이 **다른 기능의 전제를 깨뜨림**

> → **형식적으로는 OCP, 의미적으로는 OCP 위반**

---

## 8. 교훈 — 상속은 OCP의 안전한 도구가 아니다

### 상속의 위험 요약

* 업캐스팅 시 의미 손실
* 예기치 않은 런타임 동작
* 부모가 자식 확장을 **전혀 인지하지 못함**
* 새로운 클라이언트가 추가될수록 **오류 가능성 증가**

---

## 9. 해결 방향 — 상속 대신 합성(Composition)

### 핵심 전략

> **“재사용은 상속이 아니라 합성으로 한다.”**

### 구조 변경

```
BillingCallCollector ──has a── CallCollector
```

* 상속 관계 제거
* 내부에 Collector를 **참조로 포함**
* 기능 확장은 **위임(Delegation)** 으로 수행

---

## 10. 합성의 장점

### 구조적 개선

* 업캐스팅 문제 제거
* 부모-자식 의미 왜곡 없음
* 호출자가 **구현 확장을 오해하지 않음**
* 확장 책임이 **명확하게 분리됨**

> **“합성은 OCP를 안전하게 만든다.”**

---

## 11. OCP에 대한 핵심 재정의

### 진짜 OCP란?

* **기존 코드를 고치지 않는 것**이 핵심이 아니라
* **새 기능이 기존 사용자의 가정을 깨지 않는 것**

> **“확장은 기존 동작을 배신하면 안 된다.”**

---

## 12. 이번 내용의 최종 교훈

* OCP는 **상속만으로 달성되지 않는다**
* 상속 기반 재사용은 **업캐스팅·의미 붕괴 위험**이 있다
* **합성(Composition)이 더 안전한 확장 전략**이다
* 코드 재사용 목적의 상속은 **불안정한 설계를 만든다**

---

## 13. 초압축 기억 버전

```
목표: OCP로 기능 확장

1) 상속으로 Collector 확장 → 겉보기 성공
2) 업캐스팅으로 의미 붕괴 → 테스트 실패
3) 원인 = “재사용을 위한 상속”
4) 해결 = 상속 제거 + 합성으로 위임

결론:
OCP = “확장하되, 기존 의미를 깨지 말 것”
재사용은 상속보다 합성이 안전
```

---