---

# 리스코프 치환 원칙(LSP) 핵심 요약

*(다형적 OCP의 한계를 해결하는 원칙)*

---

## 1. 출발점 — 다형적 OCP의 한계

> **컴파일 타임에 확장 가능하다고 해서, 런타임에서도 안전하게 동작하는 것은 아니다.**

* 추상화를 확장하고 인터페이스를 구현해도
* **실제 동작 의미가 달라지면 런타임 오류 발생 가능**

---

## 2. 문제 사례 — CallCollector vs BillingCallCollector

### 정상 동작

* `LongestCallSelector + CallCollector`
* 모든 통화 내역 반환 → **가장 긴 통화 정상 선택**

### 실패 동작

* `LongestCallSelector + BillingCallCollector`
* BillingCollector가 **10초 이상 통화만 필터링**
* 클라이언트(LongestCallSelector)의 기대와 **동작 불일치**

> **타입은 같지만, “행동 의미”가 다름**

---

## 3. 문제의 본질 — “계약 위반”

### LongestCallSelector의 기대

> **Collector는 모든 통화 기록을 반환해야 한다**

### BillingCallCollector의 실제 동작

> **일부 통화만 반환 (필터링)**

→ **인터페이스 시그니처는 지켰지만, 의미(계약)는 깨짐**

---

## 4. 다형성의 핵심 조건

> **“부모 타입을 기대하는 모든 곳에서 자식 타입이 문제없이 대체 가능해야 한다.”**

* 컴파일 OK ≠ 런타임 OK
* **행동 의미까지 동일해야 진짜 다형성**

---

## 5. LSP (리스코프 치환 원칙) 정의

### Barbara Liskov의 정의 요약

> **S가 T의 서브타입이라면,
> T 대신 S를 사용해도 프로그램의 의미는 변하지 않아야 한다.**

---

## 6. LSP의 핵심 기준 — “클라이언트 관점”

### 서브타입이 되려면?

> **클라이언트가 기대하는 동작을 깨지 않아야 한다**

* 서브타입 판단 기준 = **부모가 아니라 “사용자(클라이언트)”**
* **is-a 관계 = 행동 호환성**

---

## 7. BillingCallCollector는 왜 LSP를 위반했는가?

| 항목                        | CallCollector | BillingCallCollector |
| ------------------------- | ------------- | -------------------- |
| 모든 통화 반환                  | O             | ❌ (필터링)              |
| LongestCallSelector 기대 충족 | O             | ❌                    |
| 부모 타입 대체 가능               | O             | ❌                    |

> **“BillingCallCollector는 CallCollector의 진짜 서브타입이 아니다.”**

---

## 8. LSP 위반이 가져오는 실제 문제

### 증상

* 런타임 예외
* 예상과 다른 결과
* 타입 체크 (`instanceof`) 증가
* 클라이언트 수정 필요

### 결과

> **OCP까지 함께 붕괴**
> (새 타입 추가 → 기존 코드 수정 필요)

---

## 9. RTTI / instanceof = LSP 위반 신호

### 문제 코드 패턴

```java
if (collector instanceof CsvReader) ...
else if (collector instanceof JsonReader) ...
```

> **타입 분기 = “대체 가능하지 않다”는 증거**

---

## 10. 올바른 설계 방향 — 계약을 명확히 하라

### 해결 원칙

* **인터페이스는 클라이언트 기대를 기준으로 정의**
* “모든 통화를 반환” vs “필터된 통화를 반환”
  → **서로 다른 역할이면 다른 인터페이스로 분리**

> **하나의 타입에 서로 다른 의미를 억지로 담지 말 것**

---

## 11. LSP는 “상속 설계 검증 도구”다

> **상속 구조가 올바른지 판단하는 기준 = LSP**

### 올바른 상속 계층 조건

* 모든 자식이 부모를 **문제없이 대체 가능**
* 클라이언트 코드 **수정 없이 동작**

---

## 12. LSP 검증 방법 — “모든 자식으로 테스트”

### 전략

* 부모 타입을 기대하는 테스트를 작성
* **모든 자식 타입을 파라미터로 주입**
* 결과가 동일하면 → **LSP 만족**

> **“모든 서브타입을 넣어도 테스트가 깨지지 않는가?”**

---

## 13. 핵심 통찰 정리

* 다형성은 **“타입 호환”이 아니라 “행동 호환”**
* 인터페이스 구현만으로는 충분하지 않음
* **서브타입은 클라이언트 기대를 절대 깨면 안 됨**
* LSP 위반 시 → OCP, DIP까지 연쇄 붕괴

---

## 14. 한 줄 요약 모음

* **“서브타입은 부모 타입을 완전히 대체 가능해야 한다.”**
* **“다형성의 본질은 행동의 호환성이다.”**
* **“LSP는 상속 설계를 검증하는 원칙이다.”**
* **“타입 체크가 필요하다면 상속 구조가 잘못된 것이다.”**

---

## 15. 초압축 기억 버전

```
문제:
BillingCallCollector가 부모 계약을 깨서 런타임 오류 발생

원인:
타입은 같지만, 행동 의미가 다름

해결 기준:
“부모 타입 대신 써도 결과가 변하지 않는가?” (LSP)

결론:
서브타입 = 클라이언트 기대를 깨지 않는 타입
```

---