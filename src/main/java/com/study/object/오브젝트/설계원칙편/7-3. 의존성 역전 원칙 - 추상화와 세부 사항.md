---

# 의존성 역전 원칙(DIP) 핵심 정리

## 1. DIP 한 문장 정의

> **자주 변하는 세부 구현이, 변하지 않아야 할 추상화에 의존하도록 설계한다.**

---

## 2. 추상화 vs 세부사항

### 추상화 (Stable)

* 비즈니스의 **본질**
* **자주 변하지 않음**
* 시스템의 **핵심 규칙**

### 세부사항 (Volatile)

* CSV, JSON, DB, API 등 **구현 디테일**
* **자주 변함**
* 교체 가능해야 함

> **안정적인 것 = 추상화**
> **불안정한 것 = 세부 구현**

---

## 3. DIP의 핵심 규칙

### ❌ 잘못된 의존성

```
핵심 로직 → CSVReader / JSONReader
```

* 핵심이 구현에 종속됨
* 변경에 취약

### ✅ 올바른 의존성

```
CSVReader / JSONReader → Reader Interface ← 핵심 로직
```

* 구현이 추상화에 종속됨
* 핵심 로직은 안정적 유지

---

## 4. 왜 인터페이스가 중요한가?

* 구현을 숨기고 **계약만 노출**
* 변경 영향을 최소화
* 가장 **순수한 추상화**

> **인터페이스 = 변하지 않는 약속**

---

## 5. 패키지/모듈 관점 DIP

### 상위 수준 모듈 (High-Level)

* 핵심 비즈니스 로직
* **안정적이어야 함**

### 하위 수준 모듈 (Low-Level)

* 파일, DB, 외부 시스템
* **자주 변경됨**

### 원칙

> **하위 모듈이 상위 모듈의 추상화에 의존해야 한다.**

---

## 6. “역전”이라는 이름의 이유

| 구분                | 방향          |
| ----------------- | ----------- |
| 실행 흐름(Runtime)    | 상위 → 하위     |
| 의존성(Compile-time) | **하위 → 상위** |

> **실행 방향과 의존성 방향이 반대이기 때문에 ‘역전’**

---

## 7. DIP가 해결하는 문제

* 핵심 로직이 구현 변경에 흔들림
* 패키지 간 결합도 증가
* 기능 확장 시 코드 수정 범위 확대

---

## 8. DIP + DI(의존성 주입)의 효과

### Before

* 내부에서 구현 객체 직접 생성
* 테스트 데이터 제어 불가

### After

* 인터페이스 의존
* 구현을 외부에서 주입
* Fake 구현으로 테스트 가능

> **DIP = 구조 안정화**
> **DI = 테스트 가능성 확보**

---

## 9. 테스트 관점 핵심

### 문제

* 테스트 데이터가 클래스 내부에 숨겨짐
* 결과 원인 파악 어려움

### 개선

* FakeReader 주입 가능
* 테스트 입력이 코드에 명시됨
* 테스트 결과 해석이 쉬워짐

> **DIP는 “테스트 가능한 설계”를 만든다**

---

## 10. DIP 적용 절차 (압축)

1. 상위 모듈이 하위 구현에 의존하는지 확인
2. **인터페이스 추출**
3. 인터페이스를 **상위 모듈 쪽으로 이동**
4. 양쪽 모두 인터페이스에 의존하게 변경
5. 구현 객체는 **DI로 주입**

---

## 11. 최종 핵심 문장 모음

* **“안정적인 것은 불안정한 것에 의존하면 안 된다.”**
* **“구현이 아니라 추상화에 의존하라.”**
* **“의존성 방향은 실행 흐름과 반대로 설계한다.”**
* **“DIP는 변경에 강한 구조를 만든다.”**
* **“DIP는 테스트 가능성을 높인다.”**

---
