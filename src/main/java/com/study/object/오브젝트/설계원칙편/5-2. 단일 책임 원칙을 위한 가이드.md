---

# 🧩 단일 책임 원칙(SRP) 실전 가이드 정리

## ― “변경의 이유”를 찾는 6가지 질문

---

## 1. 이번 시간의 목표

* SRP를 **이론이 아니라 실무에서 쓰는 기준**으로 이해
* “클래스를 언제, 어떻게 나눠야 하는가?”에 대한 **구체적 가이드 확보**
* Schedule 예제를 통해 **가이드 → 실제 분리 과정**을 끝까지 따라가기

> 기반 서적: *Working Effectively with Legacy Code* (마이클 페더스)

---

## 2. SRP 적용을 위한 6가지 가이드 (핵심)

### ✅ 가이드 1. 클래스의 책임을 한 문장으로 써보기

* **메서드 수준 ❌**
* **목적 수준 ⭕**

예:

> “이 클래스는 **반복 일정을 확인**하고
> **일정 정보를 JSON으로 변환**하는 데 사용된다”

👉 문장에 **‘그리고(and)’** 가 들어가면
👉 **책임이 둘 이상**일 가능성이 높다

---

### ✅ 가이드 2. 비슷한 이름·목적의 메서드 그룹화

* 이름이나 목적이 유사한 메서드를 묶어본다
* 정확한 분류보다 **“나중에 나눌 수 있을 정도”면 충분**

👉 메서드 그룹 = 잠재적인 새로운 클래스

---

### ✅ 가이드 3. 인스턴스 변수 ↔ 메서드 관계 살펴보기

* 특정 인스턴스 변수가 **특정 메서드 그룹에서만** 사용된다면
* 그 변수 + 메서드 그룹은 **같이 이동할 후보**

👉 “같이 쓰인다” = “같이 변경될 가능성 높음”

---

### ✅ 가이드 4. 배타적으로 초기화되는 인스턴스 변수 찾기

* 어떤 변수는 A 로직에서만 초기화
* 어떤 변수는 B 로직에서만 초기화

👉 **서로 다른 시점·이유로 초기화**된다면
👉 **책임이 다르다**

---

### ✅ 가이드 5. 테스트하고 싶은데 private 메서드인가?

* 테스트가 필요한 로직이:

    * private 메서드
    * 복잡한 조건 분기

👉 접근 제어자를 바꾸기보다
👉 **새 클래스로 이동 + public 메서드로 노출**

---

### ✅ 가이드 6. 외부 의존성(DB, API, 라이브러리) 확인

* Jackson, DB, 외부 API 등
* **내가 수정할 수 없는 코드**

👉 외부 변경이 **핵심 로직에 영향** 주면 위험
👉 의존성은 **별도 클래스로 격리**

---

## 3. Schedule 클래스에 가이드 적용하기 (1단계)

### 🔍 책임 한 문장으로 정리

> Schedule은
> 1️⃣ 반복 일정이 특정 날짜에 열리는지 확인하고
> 2️⃣ 일정 정보를 JSON으로 변환한다

👉 **변경 이유가 2개**

* 일정 계산 방식 변경
* JSON 포맷 / Jackson 변경

👉 **SRP 위반 신호**

---

## 4. 첫 번째 분리: JSON 책임 분리

### 문제

* Schedule이 Jackson 라이브러리에 직접 의존
* JSON 포맷 변경 → Schedule 수정 필요

### 해결

```
Schedule        → 일정 판단 책임
ScheduleJson    → JSON 변환 책임
```

### 효과

* Jackson 변경에도 Schedule은 영향 없음
* 외부 의존성 격리 성공

---

## 5. 요구사항 추가로 SRP가 다시 깨지는 순간

### 새로운 요구사항

* **Daily Scrum** 일정 추가

    * 매주 월/화
    * 오전 9시
    * 15분
* 월간 회의와 달리:

    * week ordinal ❌
    * multiple dayOfWeeks ⭕
* 하지만 “특정 날짜에 일정이 열리는지 확인” 기능은 동일

👉 **요구사항 변경 → 책임 의미 변화**

---

## 6. 배타적으로 초기화되는 인스턴스 변수 발견 (가이드 4)

| 일정 종류   | 사용하는 변수            |
| ------- | ------------------ |
| 월간 회의   | dayOfWeek, ordinal |
| 데일리 스크럼 | dayOfWeeks (컬렉션)   |

* 함께 존재하지만 **같이 초기화되지 않음**
* **같이 사용되지도 않음**

👉 서로 다른 책임이 한 클래스에 공존

---

## 7. 메서드 분해 후 책임 가시화 (가이드 3)

### includes 메서드 리팩터링

* checkMonthly()
* checkWeekly()

### 변수 사용 관계

* checkMonthly → dayOfWeek, ordinal
* checkWeekly → dayOfWeeks

👉 변수 + 메서드 관계가 명확히 갈라짐
👉 **분리 타이밍 도달**

---

## 8. 책임 단위로 클래스 분리

### 분리 결과

```
RecurringPlan (interface)
 ├─ MonthlyPlan
 │   └─ 월간 일정 판단 책임
 └─ WeeklyPlan
     └─ 데일리 스크럼 일정 판단 책임

Schedule
 └─ 기본 일정 정보 관리 (title, time, duration)
```

### 역할 정리

* Schedule: 일정의 **공통 정보**
* MonthlyPlan / WeeklyPlan: **반복 규칙**
* 변경 이유가 명확히 분리됨

---

## 9. SRP 적용 후 얻은 상태

### ✔ 변경 이유 정리

| 클래스          | 변경 이유         |
| ------------ | ------------- |
| Schedule     | 일정 기본 정보 변경   |
| MonthlyPlan  | 월간 일정 규칙 변경   |
| WeeklyPlan   | 데일리 스크럼 규칙 변경 |
| ScheduleJson | JSON 포맷 변경    |

👉 **모든 클래스가 하나의 이유로만 변경**

---

## 10. 가장 중요한 기억 포인트

### 🧠 반드시 기억할 문장들

> SRP는 “기능 수”가 아니라 **변경 이유 수**다
>
> 요구사항이 바뀌면 **책임의 의미도 바뀐다**
>
> SRP는 한 번 적용하고 끝나는 원칙이 아니다
>
> 좋은 설계는 **요구사항 변화를 예민하게 관찰**할 때 만들어진다

---

## 11. 한 줄 요약

> **단일 책임 원칙은
> “변경의 이유가 생길 때마다
> 클래스를 다시 바라보게 만드는 기준”이다**

---

## 12. 다음을 위한 연결 포인트

다음 단계로 자연스럽게 이어집니다:

* SRP + **의존성 역전 원칙(DIP)**
* 인터페이스를 도입하는 이유
* “변경 방향”과 “의존 방향”을 분리하는 설계