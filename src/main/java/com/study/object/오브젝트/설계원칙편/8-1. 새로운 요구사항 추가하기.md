---

# 아이템 처리 기능 & 리팩터링 핵심 요약

## 1. 추가된 아이템 명령 3가지

### ① `take` — 아이템 줍기

* 방(Room)에 있는 아이템을 **플레이어 인벤토리로 이동**
* 성공 시: 아이템 제거 + 플레이어에 추가 + 메시지 출력
* 실패 시: 아이템 없음 메시지 출력

### ② `drop` — 아이템 버리기

* 플레이어가 가진 아이템을 **방(Room)에 추가**
* 플레이어 인벤토리에서 제거 후 Room에 추가

### ③ `inventory` — 인벤토리 출력

* 플레이어가 가진 아이템 목록을 화면에 출력

---

## 2. 아이템 모델링 구조

### Item

* 아이템 이름만 가진 단순 클래스

### Room

* `List<Item>` 보유
* 아이템 `find`, `add`, `remove` 지원

### Player

* 인벤토리(`List<Item>`) 보유
* 아이템 추가/삭제 기능 포함

> **Room과 Player 모두 “아이템 보관자” 역할**

---

## 3. Take / Drop 구현 흐름

### Take (Room → Player)

1. Room에서 아이템 찾기
2. 존재하면 Room에서 제거
3. Player에 추가
4. 성공 메시지 출력

### Drop (Player → Room)

1. Player 인벤토리에서 아이템 찾기
2. 존재하면 Player에서 제거
3. Room에 추가
4. 성공 메시지 출력

> **두 로직의 구조가 거의 동일**

---

## 4. 문제: Take / Drop 로직 중복

### 중복 내용

* 아이템 찾기
* 제거
* 대상에 추가
* 메시지 출력

### 본질

> **“소스(Player) → 타겟(Room)으로 아이템을 이동”하는 동일한 패턴**

---

## 5. 중복 제거 방향 — “아이템 이동”을 공통 행위로 추상화

### 핵심 아이디어

> **아이템을 옮기는 로직을 별도 메서드(Transfer)로 분리**

### Source / Target 개념 도입

* Source = 아이템을 **제거**하는 쪽
* Target = 아이템을 **추가**하는 쪽

---

## 6. Room과 Player의 역할이 동일하다는 통찰

### 공통 책임

* `items` 리스트 보유
* `add(Item)`
* `remove(Item)`
* `find(Item)`
* `position()`

> **Room과 Player는 구조적으로 같은 책임을 수행**

---

## 7. 리팩터링: 상속으로 중복 제거

### 구조 변경

```
Player (부모)
  ↑
Room (자식)
```

### Player에 공통 기능 집중

* items 관리
* add / remove / find
* position

### Room은 Player를 상속받아 재사용

> **중복 코드 제거 + 역할 통합**

---

## 8. 업캐스팅(Upcasting) 활용

### 개념

> **자식(Room)을 부모(Player) 타입으로 다루기**

### 효과

* Transfer 메서드에서 Source / Target 타입을 Player로 통일
* Room과 Player를 동일한 인터페이스처럼 사용 가능

---

## 9. Transfer 메서드 도입 (핵심 구조)

### 역할

* Source에서 아이템 제거
* Target에 아이템 추가

### Take / Drop = Transfer 호출 방향만 다름

| 명령   | Source | Target |
| ---- | ------ | ------ |
| take | Room   | Player |
| drop | Player | Room   |

> **동일 로직, 방향만 반대**

---

## 10. 상속의 장점 (이번 단계 기준)

* 중복 코드 제거
* Room / Player 공통 행위 재사용
* 코드 길이 감소
* 로직 흐름 단순화

---

## 11. 그러나 상속의 한계와 문제점 발생

### 문제 1 — 타입 오염

* Player가 Room의 존재를 알게 됨
* 부모가 자식 타입을 인지 → **결합 증가**

### 문제 2 — 의미적 부자연스러움

> **“Room은 Player다” 라는 관계는 개념적으로 부자연**

---

## 12. NullPointerException 문제 (상속 부작용)

### 원인

* Player.move()가 `worldMap` 의존
* Room은 `worldMap`이 필요 없음
* Room 인스턴스에 Player 로직 적용 → `null` 참조 발생

### 본질

> **부모 클래스가 자식의 맥락을 고려하지 않은 설계**

---

## 13. 문제 해결 시도 (그러나 한계 존재)

### 방법 1 — 타입 체크 (Room인지 검사)

* OCP 위반
* 새로운 타입 추가 시 수정 필요

### 방법 2 — 자식이 메서드 오버라이드

* 자식이 부모 구현에 강하게 종속됨

> **둘 다 유지보수에 불리**

---

## 14. 핵심 교훈 — 상속은 만능이 아니다

### 깨달음

* **“동일한 역할” ≠ “상속 관계가 적절”**
* 상속은 코드 재사용 도구이지 **모델링 도구가 아님**

### 위험

* 강한 결합
* 의미 왜곡
* 변경 전파 위험
* 런타임 오류(NPE)

---

## 15. 이번 내용 한 줄 요약

* **아이템 이동 로직은 공통화할 수 있다**
* **Room과 Player는 행위가 유사하지만 상속이 최선은 아니다**
* **상속은 중복을 줄일 수 있지만 구조를 망칠 수 있다**
* **다음 단계는 “상속 대신 합성(Composition)”이 더 적절한 설계**

---

## 16. 초압축 기억 버전

```
기능:
take / drop / inventory 추가

리팩터링:
Room ↔ Player 아이템 이동 로직 공통화
Transfer 추출
상속으로 중복 제거

문제:
의미 왜곡 + 결합 증가 + NPE 발생

교훈:
“중복 제거 = 상속”은 위험
→ 합성이 더 나은 선택일 가능성
```

---