## 유연한 설계
### 개방-폐쇄 원칙
* 소프트웨어개체(클래스모, 듈.합수등등)는확장어대l 해열려있어야하고수, 정에대해서는딛혀있어야한다
  * 여기서키워드는‘확쟝과‘수정’이다이. 둘은순서대로애플리케이션의동쟉과‘코드,의관점을반영한다
    * 확장에대해열려있다:애플리케이션의요구사항이변경될때이변경에맞게새로운‘동작'을추가해서애플리케이션의 기능을 확장할 수 있다.
    * 수정에대해닫혀있다:기존의‘코드'를수정하지않고도애플리케이션의동직을추가하거나변경할수있다
* 컴파일타임의존성을고정시키고런타임의존성을변경하라
  * 시실개방-폐쇄원칙은런타임의존성과컴파일타임의존성에괸한이야기다.
  * 런타임의존성은실행 시에협력에참여히는객체들사이의관계다.
  * 컴파일타임의존성은코드에서드러나는클래스들사이 의관계다.
  * 그리고앞장에서살펴본것처􏰀유연하고재시용가능한설계에서런타임의존성와컴파일 타임 의존성은 서로 디른 구조를 가진다.
  * 개방-폐쇄원칙을수용하는코드는컴파일타임의존성을수정하지않고도런타임의존성을쉽게변경 할수있다.
  * 의존성관점에서개방-폐쇄원칙을따르는설계란컴파 일타임의존성은유지하면서런타임의존성의기능성을확장하고수정할수있는구조라고할수있다.
* 추싱화가 핵심이다
  * 개방-폐쇄원칙의핵심은추싱화에의존히는것이다.여기서추상화와.의존’이리는두개념모두가 중요하다.
  * 추상화란핵심적인부분만남기고불필요한부분은생귿넓으로써복잡성을극복하는기법이다.추상화 과정을거치면문맥이바뀌더리도변하지않는부분만남게되고문맥에따라변하는부분은생략된다. 추싱회를시용하면생략된부분을문맥에적합한내용으로채워넣음으로써각문맥에적합하게기능을 구체화하고 획장할 수 있다.
  * 개방-폐쇄원칙의관점에서생략되지않고남겨지는부분은다양한상황에서의공통점을반영한추상 화의결괴물이다.공통적인부분은문맥이바뀌더라도변하지않o뺘한다.다시밀해서수정할필요가 없어야한다따. 라서추싱화부분은수정에대해닫혀있다추. 싱회를통해생략된부분은획장의여지 를남긴다.이것이추싱화가개방-폐쇄원칙을가능하게만드는이유다.
  * 올바른추싱회를설계하고 추싱회에대해서만의존하도록관계를제힌힘으로써설계를유연하게획장할수있다.
  * 여기서주의할점은추상화를했다고해서모든수정에대해설계가폐쇄되는것은아니리는것이다. 수정에대해닫혀있고확장에대해열려있는설계는공짜로얻어지지않는다변. 경에의한피급효과 를최대한피하기위해서는변하는것과변하지않는것이무엇인지를이해하고이를추상화의목적으 로심c샤만한다추. 싱화가수정에대해닫혀있을수있는이유는변경되지않을부분을신중하게결 정하고올바른추상회를주의깊게선택했기때문이라는사실을기억하라.

### 생성 사용 분리
* 결합도가높아질수록개방-폐쇄원칙을따르는구조를설계하기가어려워진다.알이야하는지식이많 으면결합도도높아진다.특히객체생성에대한지식은괴도한결합도를초래히는경향이있다.객체 의타입과생성자에전달해야하는인자에대한괴도한지식은코드를특정한컨텍스트에강하게결합 시킨다.컨텍스트를바꾸기위한유일한방법은코드안에명시돼있는컨텍스트에대한정보를직접 수정하는 것뿐이다.
* 물론객체생성을피할수는없다.어딘가에서는반드시객체를생성해야한다.문제는객체생성이아 니다.부적절한곳에서객체를생성한다는것이문제다.
* 메시지를전송하지않고객체를생성하기만한다면이무런문제가없었을것이다.또는객체를생성하 지않고메시지를전송하기만했다면괜찮았을것이다.동일한클래스안에서객체생성과사용이리는 두가지이질적인목적을가진코드가공존하는것이문제인것이다.
* 유연하고재사용가능한설계를원한다면객체와관련된두가지책임을서로다른객체로분리해야한
  다.하니는객체를생성하는것이고.다른하나는객체를사용하는것이다.한마디로말해서객체에대 한 생성과 시용을 분리 (separation use from creation) [BainO8]해야 한다.
* 시용으로부터생성을분리하는데사용되는가장보편적인방법은객체를생성할책임을클라이언트로 옮기는것이다.
* 현 재의컨텍스트에관한결정권을가지고있는클라이언트로컨텍스트에대한지식을옮김으로써Movie 는특정한클라이언트에결합되지않고독립적일수있다.
* FACTORY 추가하기
  * 객체생성과 관련된지식이αient와협력하는클라이언트에게까지새어나가기를원하지않는다고가정해보자.
  * 이경우객체생성과관련된책임만전담히는별도의객체를추가하고αient는이객체를사용하도 록만들수있다.이처􏰀생성과사용을분리하기위해객체생성에특화된객체를FA(TORY라고부른다
* 순수한 가공물에게 책임 할딩하기
  * 책임 할당의 가장 기 본이 되는 원칙은 책임을 수행히는 데 필요한 정보를 가장 많이 일고 있는 INFORMATION E차ERT 에게 책임을 할당히는 것이다. 도메 인 모델은 INFORMATION E꾜ERT를 찾기 위해 침조할 수 있는 일차적인재료다.어떤책임을힐딩하고싶다면제일먼저도메인모델안의개념중에서적절한후보 가 존재하는지 찾아뵈야 한다.
  * FACTORY를추가한이유는순수하게기술적인결정이다.전체적으로결힘도를낮추고재사용성 을 높이기 위해 도메인 개념에게 할딩돼 있던 객체 생성 책임을 도메인 개념괴는 아무런 싱콴이 없는 가공의 객체로 이동시킨 것이다.
  * 크레이그 라만은 시스템을 객체로 분해하는 데는 크게 두 가지 방식이 존재한다고 설명한다. 하나 는 표현적 분해(representational decomposition)이고 디른 하나는 행위적 분해(beh켄vioral decomposition)다[LarmanO4].
    * 표현적 분해는 도메인에 존재히는 시물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것 이다.
    * 표현적분해는도메인모델에담겨있는개념과관계를띠르며도메인과소프트웨어시이의표현 적차이를최소화하는것을목적으로한다.따라서표현적분해는객체지향설계를위한기장기본적인 접근법이다.
  * 종종도메인개념을표현히는객체에게책임을할당하는것만으로는부족한경우가발생한다. 도메인모델은설계를위한중요한출발점이지만단지출발점이리는사실을명심해야한다‘실제로동 작히는애플리케이션은데이터베이스접근을위한객체와같이도메인개념들을초월히는기계적인개 념들을필요로할수있다.
  * 모든책임을도메인객체에게할딩하면낮은응집도,높은결합도,재시용성저히와같은심긱한문제 점에봉칙하게될기능성이높아진다.이경우도메인개념을표현한객체가아닌설계자가편의를위 해임의로만들어낸가공의객체에게책임을할딩해서문제를해결해야한다.크레이그리만은이처􏰀 책임을할당하기위해칭조되는도머I인과무관한인공적인객체를PUREFABRICATION(순수한가 공튑이리고부른다[LarmanO4].
  * 어떤행동을추가하려고히는데이행동을책임질미땅한도메인개념이존재하지않는다면PURE FABRICATION을 추가하고 이 객체에게 책임을 할당하라. 
    * 그 결과로 추가된 PURE FABRICATION 은보통특정한행동을표현히는것이일반적이다.
    * 따라서PUREFABRICATION은표현적분해보다 는행위적분해에의해생성되는것이일반적이다.
  * 이런 측면에서 객처l지향이 실세계의 모방이리는 밀은 옳지 않다
  * 객체지향 애플리케이션은 도메인 개 념뿐만 아니라 설계지들이 임의적으로 칭조한 인공적인 추싱희들을 포힘히고 있다.
  * 애폴리케이션 내에 서 인공적으로 칭조한 객체들이 도메인 개념을 반영하는 객체들보다 오히려 더 많은 비중을 치지히는 것이 일반적이다. 
  * 객체지향 애플리케이션의 대부분은 실제 도메인에서 발견할 수 없는 순수한 인공물 로기득차있다.
  * 설계자로서의 우리의 역할은 도메인 추싱회를 기반으로 애플리케이션 로직을 설계히는 동시에 품질의 측면에서 균형을 맞추는 데 필요한 객체들을 칭조히는 것이다. 
  * 레베카 워프스브록의 말을 빌리자면 “애 플리케이션모델은사용지에게반응하고,실행을제어하며,외부리소스에연결히는컴퓨터객체를이 용해 도메인 모델울 보충한다[WirfS-BrockO3]''.
  * 메인 개념을 표현히는 객체와 순수하게 칭조된 가 공의 객체들이 모여 지신의 역할과 책임을 다하고 조회롭게 협력히는 애플리케이션을 설계히는 것이 목표여야 한다.
  * 먼저도메인의본질적인개념을표현히는추싱회를이용해애플리케이션을구축하기시직히라.만약 도메인개념이만족스􏰁지못히다면주저하지밀고인공적인객체를칭조하라.
  * 객체지향이실세계를 모빙해야한디는헛된주장에현혹될필요가없다.
  * 우리가애플리케이션을구축하는것은사용자들이 원히는기능을제공하기위해서지실세계를모빙하거나시뮬레이션하기위한것이아니다.
  * 도메인을 반영히는애플리케이션의구조리는제약안에서실용적인칭조성을발휘할수있는능력은흘륭한설 계자가갖춰야할기본적인자질이다.
  * PURE FABRICATION
    * 객체지향 설계는 문제 도메인 싱의 개념을 소프르레어 객체로 구현하고 책임을 할당힌다. 하지만 만약 도메인 객체에 책임을 할당할 경우 HIGH COHESION, LOW COUP니NG, x빠倡성 등의 목적을 위반한다면 어떻게 해야 하는가?
      문제도메인개념을표현융"않는인위적으로또는편의상만든클래스에디M우응집된책임욜할당하라이들클래스는 문제도메인상에는존재능肱l않지만순수융pl전체설계의품질을높이기위해설계자의임의에따라추가한싱상속의 7 俉물이댜
      PURE“BRICATION은INFORMArlON탸PERT패턴에따라책임을할딩한결고F}바람직융씨않을경우대안으로 사용된댜어떤객체가책임을수행하는데필요한많은정보를7闊XI만해당책임을할당할경우응집도가낮O防l고 결힙도가높아진다면가공의객처틀추가해서책임을옮기는것을고민하라순수한7罔불murefabncation)이리는
      표현은적절한대인이없올때人팀들이칭조적인무언7튿민들어낸다는것플의미하는관용적인표고
* A(TORY는 객체의 생성 책임을 힐딩할 만한 도메인 객체가 존재하지 않을 때 선택할 수 있는 PURE FABRICATION이다. 
### 의존성 주입
* 외부의독립적인객체가인스턴스를생성한후이를전딜해서의존성을해결하는방법을의존성주입 (DependencyIniection)[FowlerO4]이리코부른다.이
* 이 기법을의존성주입이라고부르는이유는외 부에서의존성의대싱을해결한후이를사용히는객체쪽으로주입하기때문이다.
* 의존성주입은의 존성을해결하기위해의존성을객체의퍼블릭인터페이스에명시적으로드러내서외부에서필요한런 타임의존성을전달할수있도록민드는방법을포괄하는명칭이다.
* 따라서의존성주입에서는의존성 을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.
  * 생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결 
  * setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결
    * 생성자 주입을 통해 설정된 인스턴스는 객체 의생명주기전체에걸쳐관계를유지하는반면.setter주입을사용하면언제라도의존대성을교체할 수 있다.
    * 5etter 주입의 단점은 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현할 수 없다는 것이다. 
    * 5etter 메서드는 객체가 생성된 후에 호출돼야 하기 때문에 setter 메서드 호출을 누 락한다면 객체는 비정상적인 상태로 생성될 것이다.
  * 메서드 주입(method injection): 메서드 실행 시 인자를 이용한 의존성 해결
    * 메서드 주입은 메서드 호출 주입(method cal iniection)이라고도 부르며 메서드가 의존성을 필요로 하는유일한경우일때사용할수있다
    * 성자주입을통해의존성을전달받으면객체가올바 른상태로생성되는데필요한의존성을명확하게표현할수있다는장점이있지만주입된의존성이한 두개의메서드에서만사용된다면각메서드의인자로전딜하는것이더니은방법일수있다.
* 숨겨진 의존성은 나쁘다
  * SERVICELOCATOR매턴은서비스를사용하는코드로부터서비스가누구인지(서비스를구현한구체클래 스의 ER]이 무엇인지). 어디에 있는지 (클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해준다
  * SERVICE LOCAIOR 패턴의 7많 큰 단점은 의존성을 김춘다는 것이다. 
  * 의존성을구현내부로김출경우의존성과관련된문제가컴파일타임이아닌런타임에 가서야발견된디는사실을알수있다.
  * 숨겨진의존성이이해하기어렵고디버깅하기어려운이유는문 제점을발견할수있는시점을코드작성시점이아니라실행시점으로미루기때문이다.
  * 의존성을 숨기는 코드는 단위 테스트 작성도 어렵다. 
  * 일반적인 단위 테스트 프레임워크는 테스트 케이스 단위로 테스트에 시용될 객체들을 새로 생성하는 기능을 제공한다. 하지만 위에서 구현한 5erviceLocator는내부적으로정적변수를사용해객체들을관리하기때문에모든단위테스트케이스 에걸쳐5erviceLocator의상태를공유하게된다.이것은각단위테스트는서로고립돼야한디는단위 테스트의 기본 원칙을 위반한 것이다
  * 캡슐회는코드를읽고이해히는행위와관련이있다.
  * 클래스의퍼블릭인터페이스만으로사용방법울 이해할수있는코드가캡슐회의관점에서홀륭한코드다.
  * 클래스의사용법을익히기위해구현내부를 실샅이뒤져야한다면그클래스의캡슐회는무너진것이다.
  * 숨겨진의존성이가지는7(주)큰문제점은의존성울이해하기위해코드의내부구현을이해할것을강 요한디는것이다.
    * 따라서숨겨진의존성은캡슐회를위반한다.
    * 결과적으로의존성을구현내부로김추 도록강요하는SERVICELOCArOR는캡슐회를위반할수밖에없다.
  * 숨겨진의존성은의존성의대싱을설정하는시점과의존성이해결되는시점을멀리떨어트려놓는다. 이것은코드를이해하고디버깅하기어렵게만든다
  * 의존성 주입은 이 문제를 깔끔하게 해결한다. 필요한 의존성은 클래스의 퍼블릭 인터페이스에 명시 적으로드러난다
  * 의존성을이해하기위해코드내부를읽을필요가없기때문에의존성주입은객 체의캡슐을단단하게보호한다
  * 의존성과관련된문제도최대한컴파일타임에잡을수있다.필요 한의존성을인자에추가하지않을경우컴파일에러가발생하기때문이다.
  * 단위테스트를작성할때 ServiceLocator에객체를추가하거나제거할필요도없다.그저필요한인자를전달해서필요한객체를 생성하면 된다.
  * 이야기의핵심은의존성주입이SERVICELOCArOR패턴보다좋다가아니라명시적인의존성이숨 겨진의존성보다좋다는것이다.가급적의존성을객체의퍼블릭인터페이스에노출하라.의존성을구 현내부에숨기면숨길수록코드를이해하기도.수정하기도어려워진다.
  * 접근해야할객체가있다면전역메커니즘대신필, 요한객체를인수로넘겨줄수는없는지부터생z脯l보자이. 방법은굉징히쉬운데다결합을명획하게보여줄수있다.대부분은이렇게만해도충분하다.
  * 하지만직접객체를넘기는방식이불필요하거나도리어코드를읽기어렵게하기도한다로. 그나메모리관리 같은정보가모듈의공개API에포함돼있어서는인된다렌. 더링합수매개변수에는렌더링에관련된것만있 어야하며로그같은것이섞여있어서는곤린하댜
### 의존성 역전 원칙
* 추싱화와 의존성 역전
  * 객체사이의협력이존재할때그협력의본질을담고있는것은상위수준의정책이다
  * 다시밀해서어떤협력에서중요한정책이나의사결정.비 즈니스의본질을담고있는것은상위수준의클래스다.
  * 이런상위수준의클래스가하위수준의클래스에의존한다면하위수준의변경에의해상위수준클래스가영향을받게될것이다.
  * 의존성은변경의전파와관련된것이기때문에설계는변경의영향을최소화하도록의존성을관 리해야 한다. 
  * 상위수준의
    클래스는어떤식으로든하위수준의클래스에의존해서는안되는것이다.
  * 대부분의경우우리가재사용하려는대싱은상위수준의클래스라 는점을기억하라.
  * 상위수준의클래스가하위수준의클래스에의존하면상위수준의클래스를재사용 할때하위수준의클래스도필요하기때문에재사용하기가어려워진다.
  * 중요한것은상위수준의클래스다.상위수준의변경에의해하위수준이변경되는것은닙득할수있 지만하위수준의변경으로인해상위수준이변경돼서는곤란하다.하위수준의이슈로인해상위수
    준에위치하는클래스들을재사용히는것이어렵다면이것역시문제가된다.
  * 의존성역전원칙
    * 가장중요한조언은추싱회이의존하리는것이다유. 연하고재시용7浩한설계를원한다면모든의존 성의방향이추상클래스나인터페이스와같은추싱회를따큰胎한F 다구. 체클래스는의존성의시작점 이어야한다.의존성의목적지가돼서는안된다.
    * 상위수준의모듈은하위수준의모듈에의존해서는인된다.둘모두추상화에의존해야한다 2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
    * 이 용어 를최초로츠KI한로버트마틴은.역전(inversion),이리는단어를사용한이유에대해의존성역전원칙 을따르는설계는의존성의빙향이전통적인절차형프로그래밍괴는반대방향으로나타나기때문이라 고 설명한다.
  * 의존성역전원칙과패키지
    * 역전은의존성의방힝뿐만
      아니라인터페이스의소유권에도적용된디는것이다객. 체지향프로그래밍언어에서어떤구성요소의
      소유권을결정히는것은모듈이다.자바는패키지를이용해모듈을구현하고C, #이나C卞十는네임스 페 이스를 이용해 모듈을 구현한다.
    * 하지만이것은코드수정에있어서는사실이지만컴파일측면에서는사실이아니다.DiscountPolicy가 포함된패키지안의어떤클래스가수정되더라도패키지전체가재배포돼야한다.이로인해이패키지 에의존하는Movie클래스가포함된패키지역시재컴파일돼야한다.Movie에의존히는또다른패키지
      가있다면컴파일은의존성의그래프를타고애플리케이션코드전체로번져갈것이다.따라서불필요 한클래스들을같은패키지에두는것은전체적인빌드시간을가파르게싱승시킨다.
      ![img.png](img.png)
    * 따라서그림9.10과같이추싱회를별도의독립적인패키지가아니라클라이언트가속한 패키지에 포함시켜야 한다. 그리고 함께 재시용될 필요가 없는 클래스들은 별도의 독립적인 패키지에
모아야 한다. 마틴 파울러는 이 기법을 가리켜 5EPARATED INTERFAcE 패턴[FowIer02]이라고 부른다.
    ![img_1.png](img_1.png)
    * 따라서의존성역전원칙에따라상위수준의협력흐름을재사용하기위해서는추상화가제공하는인
      터페이스의 소유권 역시 역전시켜야 한다. 전통적인 설계 패러다임은 그림 9.9와 같이 인터페이스의 소유권을 클라이언트 모듈이 아닌 서버 모듈에 위치시키는 반면 잘 설계된 객체지향 애플리케이션에서
      는그림9.10과같이인터페이스의소유권을서버가아닌클라이언트에위치시킨다.이것은니중에살 펴보겠지만 객체지향 프레임워크의 모듈 구조를 설계하는 데 가장 중요한 핵심 원칙이다.
    * 유연하고재사용가능하며컨텍스트에독립적인설계는전통적인패러다임이고수히는의존 성의방향을역전시킨다.전통적인패러다임에서는상위수준모듈이하위수준모듈에의존했다면객 체지향패러다임에서는상위수준모듈과하위수준모듈이모두추싱호샤l의존한다.전통적인패러다 임에서는인터페이스가하위수준모듈에속했다면객체지향패러다임에서는인터페이스가상위수준 모듈에 속한다.
    * 훌륭한객체지향설계를위해서는의존성을역전시켜야한다그. 리고의존성을역전시켜야만유연하고 재사용7浩한설계를얻을수있다.이것이핵심이다.
### 유연성에 대한 조언
* 유연한 설계는 유연성이 필요할 때만 옳다
  * 유연하고 재사용 기능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일 타임 의존성으로부터 다잉한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미한다. 
  * 하지 만 유연하고 재사용 기능한 설계가 항상 좋은 것은 아니다. 설계의 미덕은 단순힘과 명확함으로부터 나 온다. 단순하고 명획한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하다. 유연한 설계는 이외는 디른 길을 걷는다. 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순힘과 명확함의 미덕을 버리게 될 가능성이 높다.
  * 유연한 설계라는 말의 이면에는 복잡한 설계리는 의미가 숨어 있다. 유연한 설계의 이런 양면성은 객관 적으로 설계를 판단하기 어렵게 만든다. 이 설계가 복잡한 이유는 무엇인가? 어떤 변경에 대비하기 위 해 설계를 복잡하게 만들었는가? 정말 유연성이 필요한7w 정보가 제한적인 상횡에서 이런 질문에 대 답하는 것은 공학이라기보디는 심리학에 가깝다. 변경은 예상이 아니라 현실이어야 한다. 미래에 변경 이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다. 아직 일어나지 않은 변경
    은 변경이 아니다.
  * 유연성은힝상복잡성을수반한다.유연하지않은설계는단순하고명확하다.유연한설계는복잡하고 암시적이다. 객체지향에 입문한 개빌지들이 가장 이해하기 어려워하는 부분이 바로 코드 상에 표현된 정적인클래스의구조와실행시점의동적인객체구조가다르디는사실이다.절차적인프로그래밍방 식으로작성된코드는코드에표현된정적인구조가곧실행시점의동적인구조를의미한다.객체지향 코드에서클래스의구조는발생가능한모든객체구조를담는틀일뿐이다.특정시점의객체구조를 파악하는유일한방법은클래스를사용히는클라이언트코드내에서객체를생성하거나변경하는부분 을 직접 살펴보는 것뿐이다.
  * 설계가유연할수록클래스구조와객체구조사이의거리는점점멀어진다.따라서유연힘은단순성과 명확성의희생위에서자리난다.유연한설계를단순하고명획하게만드는유일한방법은사람들간의 긴밀한커뮤니케이션뿐이다.복잡성이필요한이유와합리적인근거를제시하지않는다면어느누구도 설계를 만족스러운 해법으로 받아들이지 않을 것이다.
  * 불필요한유연성은불필요한복잡성을넣는다.단순하고명확한해법이그런대로만족스􏰁다면유연성 을제거하라.유연성은코드를읽는사림들이복잡함을수용할수있을때만가치가있다.하지만복잡 성에대한걱정보다유연하고재시용기능한설계의필요성이더크다면코드의구조와실행구조를다 르게 만들어라.
  * 내두번째주장은우리의지적능력은정적인관계에더잘들어맞고.시간에따른진행과정을시각화하는능 력은싱대적으로덜발밀했다는점이댜이러한이유로우리는(자신의한계를알고있는현명한프로그래머 로서) 정적인 프로그램과 동적인 프로세스 中I의 간극을 줄이기 위해 최선을 다해야 하며, 이를 등해 프로그
    램(텍스트공간에흩뿌려진)과(人Rhl흩뿌려진)진행과정사이를가능한한일치시켜야힌다[D떼kstra68].
* 협력과 책임이 중요하다
  * 마지막으로 히고 싶은 말은 객체의 협력과 책임이 중요하다는 것이다. 지금까지 클래스를 중심으로 구
    현 메커니즘 관점에서 의존성을 설명했지만 설계를 유연하게 만들기 위해서는 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요하다.
  * 설계를유연하게만들기위해서는먼저역할책임.협력에초점을맞춰야한다.다양한컨텍스트에서 협력을재사용할필요가없다면설계를유연하게만들당위성도함께사라진다.객체들이메시지전송 자의관점에서동일한책임을수행히는지여부를판단할수없다면공통의추싱회를도출할수없다. 동일한역힐을통해객체들을대체가능하게만들지않았다면협력에참여하는객체들을교체할필요 가 없다.
  * 초보자가 자주 저지르는 실수 중 하니는 객체의 역할과 책임이 자리를 잡기 전에 너무 성급하게 객체 생성에집중하는것이다.이것은객체생성과관련된불필요한세부사항에객체를결합시킨다.객체를 생성할책임을담당할객체나객체생성메커니즘을결정하는시점은책임할당의마지막단계로미뤄
    야만한다.중요한비즈니스로직을처리하기위해책임을할당하고협력의균형을맞추는것이객체 생성에관한책임을할당히는것보다우선이다.책임관점에서객체들간에균형이잡혀있는상태라면 생성과관련된책임을지게될객체를선택하는것은간단한작업이된다.
  * 책임의불균형이심화되고있는상태에서객체의생성책임을지우는것은설계를하부의특정한메커 니즘에종속적으로만들획률이높다.불필요한SINGLETON패턴[GOF94]은객체생성에관해너무 이른시기에고민하고결정할때도입되는경향이있다.핵심은객체를생성하는방법에대한결정은 모든책임이자리를잡은후가장마지막시점에내리는것이적절하다는것이다.
  * 프로섹트를진행하는동안,필자의설계접근법들을반영하고있었다.필자는거의무의식적으로시종일관수 행했던일들을일cl냈다.그것은바로객체가무엇이되고싶은지를일게될때까지객체들을어떻게인스턴스 회할것인지에대해전혀신경쓰지않았다는것이다.이때가장중요한관심거리는마지객체가이미존재하 는것처􏰀이들간의관계를신경쓰는일이다.필자는때가되면이러한관계에맞게객체를생성할수있을것 이라고 추측했다.
    이렇게추측했던이유는설계동안머릿속에기억해야할객체수를최소화해야하기때문이다.보동요구시항 을충족시킬수있는객체를인스턴스화하는방법에대해생긱히는것을뒤로미룰때위험을최소화한상태로 작업할수있다.너무일찍결정하는것은비생산적이다.
    ......객체를생성하는방법을여러분자신이신경쓰기전에시스템에필요한것[책임]들을생긱하자
  * 의존성을관리해야하는이유는역할책임.협력의관점에서설계가유연하고재사용가능해야하기 때문이다.따라서역할.책임,협력에먼저집중하라.이번장에서설명한다잉한기법들을적용하기전 에역할,책임.협력의모습이선명하게그려지지않는다면의존성을관리하는데들이는모든노력이 물거품이 될 수도 있다는 사실을 명심하라.


