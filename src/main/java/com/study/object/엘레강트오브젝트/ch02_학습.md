## 가능하면 적게 캡슐화하세요
* 4개또는 그 이하의 객체를 캡슐화할 것을 권장한다.
* 더 많은 객체를 캡슐화해야 한다면, 클래스에 문제가 있는 것이기 때문에 리팩토링이 필요하다.
* 상태 없는 객체는 존재해서는 안되고, 상태는 객체의 식별자여야 한다.
* 자바의 결함을 해결하기 위해 == 연산자를 사용하지 말고 항상 equals()를 오버라이드 해라
* 객체의 식별자는 기본적으로 세계 안에서 객체가 위치하는 좌표다
  * 4개 이상의 상태는 이해하기가 어렵다.

## 최소한 뭔가는 캡슐화하세요
* 어떤 일을 수행하는 객체는 다른 객체들과 공존하면서 이들을 사용한다. <br>
이 객체는 자기 자신을 식별할 수 있도록 다른 객체들을 캡슐화해야 한다.
* 악명높은 정적 클래스와 동일하다.

## 항상 인터페이스를 사용하세요
* 애플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 분리해야 한다.
* 기술적인 관점에서 객체 분리란 상호작용한ㄴ 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만든다는 것을 의미한다. <br>
이를 가능하게 하는 훌륭한 도구가 인터페이스다.
* 인터페이스는 객체가 다른 객체와 의사소통하기 위해 따라야 하는 계약이다.
* 클래스 안의 모든 퍼블릭 메서드가 인터페이스를 구현하도록 만들어야 한다.
* 올바르게 설계된 클래스라면 최소한 하나의 인터페이스라도 구현하지 않는 퍼블릭 메서드를 포함해서는 안된다.
* 오버라이드 하지 않는 퍼블릭 메서드는 해당 클래스에 강하게 결합되도록 조장한다.
* 클래스가 존재하는 이유는 다른 누군가가 클래스의 서비스를 필요로 하기 때문이다.
* 각각의 경쟁자는 서로 다른 경쟁자를 쉽게 대체할 수 있어야 한다. 이것이 느슨한 결합도의 의미다.
* 클래스가 다른 클래스에 의해 이해되고 사용되기 위해서는 인터페이스를 구현해야 합니다. <br>
인터페이스를 구현하는 모든 클래스와 이 인터페이스를 사용하는 모든 클래스를 함께 변경하지 않고서는 인터페이스를 변경할 수 없다.
* 사실 결합은 전체 시스템을 안정적인 상탤 유지할 수 있게하여 나쁜것이 아니다.

## 메서드 이름을 신중하게 선택하세요
* 빌더란 뭔가를 마들고 새로운 객체를 반환하는 메서드를 가리킨다.
* 조정자란 객체로 추상화한 실세계 엔티티를 수정하는 메서드를 가리킨다.
### 빌더는 명사다
* 브라우니 주세요, 커피 한잔 주세요
* Food cookBrownie()는 객체에게 할 일을 일일이 명령해야 한다고 하는것이다. 절차적인 접근 방식이다.

### 조정자는 동사다
* 바테더에게 음악을 틀고 현재의 볼륨 상태를 말해주세요라고 하는것은 무례한 행동이다.
* 반환타입은 void이어야 한다.
* 빌더 패턴은 유지보수성이 낮고 응집도가 떨어지는 더 커다란 객체를 만들도록 조장하기 때문에 개인적으로는 빌더 패턴에 반대한다.
* 빌더 패턴은 생성자에 너무 많은 인자를 전달하고 싶지 않을 때 유용하게 사용할 수 있다.
* 애초에 인자의 수가 많다는 것 자체가 문제다.
* 빌더 패턴을 사용하는 대신 복잡한 객체를 더 작은 객체들로 나눠햐 한다. (빌더 패턴 사용X) 

### 빌더와 조정자 혼합하기
* 아래와 같이 빌더와 조정자를 분리해라
~~~
class Document {
    int write(InputStream content);
}

class Document {
    OutputPipe write();
}

class OutputPipe {
    void write(InputStream content);
    int bytes();
    long time();
}
~~~
### Boolean 값을 결과로 반환하는 경우
* Boolean을 반환하는 메서드의 경우 형용사로 지어야 한다.
* 왜냐하면 자바는 비교문에 단축 형태를 사용할 수 잇기 때문에 일반적으로 == true를 생략한다. <br>
따라서 메서드의 이름을 형용사로 지어야 더 자연스럽게 읽히는 문장이 된다.

~~~
if (name.empty())
~~~

## 퍼블릭 상수를 사용하지 마세요
* 상수는 데이터를 공유하기 위해 사용한다.
* 객체들은 어떤 것도 공유해서는 안된다. 대신 독립적이고 닫혀 있어야 한다.
* 상수를 이용하는 메커니즘은 캡슐화와 객체지향적인 사고 전체를 부정하는 일이다.
* 퍼블릭 상수는 매우 절차적이다.

### 결합도 증가
* 상수 제공 객체는 사용 방법과 관련된 어떤 정보도 제공하지 않은 채 모든 곳에서 접근 가능한 전역 가시성 안에 방치되어 있다.
* 이 객체가 어떤 문맥 안에서 어떻게 사용되어야 하고, 이 객체의 변경으로 인해 사용자가 어떤 영향을 받는지에 관해서도 알 수 없다.
* 많은 객체들이 다른 객체를 사용하는 상황에서 서로를 어떻게 사용하는지 알 수 없다면, 이 객체들은 매우 강하게 결합되어 있는 것이다.

### 응집도 저하
* 상수는 정말 멍청하다.
* 상수는 자신의 존재를 이유를 이해하지 못하는 하나의 텍스트 덩어리에 불과하다.
* 객체들은 상수를 다루는 방법을 알고 있어야 하기 때문에 응집도가 낮아진다.

### 객체 생성
* 객체 사이에 데이터를 중복해서는 안되고 기능을 공유할 수 있도록 새로운 클래스를 만들어야 한다.
* EOLString은 계약을 통해 추가 된 것이며, 계약에 의한 결합은 언제라도 분리가 가능하기 때문에 유지보수성을 저하시키지 않는다.
* 퍼블릭 상수마다 계약의 의미를 캡슐화하는 새로운 클래스를 만들어야 한다.
* 클래스 사이에 중복 코드가 없다면 클래스가 작아질수록 코드는 더 깔끔해진다.
* 애플리케이션을 구성하는 클래스의 수가 많을수록 설계가 더 좋아지고 유지보수하기도 쉬워진다.
* 내 고양이는 생선을 먹고 우유를 마시는 것을 좋아한다. <br>
내 것은 그것을 먹고 다른 것을 마시는 것을 좋아한다.
* 자바의 열거형에도 정확하게 동일한 규칙이 적용된다. 열거형 역시 사용하지 말아라

~~~
public class EOLString {
    private final String origin;
    
    EOLString(String src) {
        this.origin = src;
    }
    
    @Override
    String toString() {
        return String.format("%s\r\n", origin);
    }
}
~~~

## 불변 객체로 만드세요
* 상태 변경이 불가능한 불변 클래스로 구현하면 유지보수성을 크게 향상시킬 수 있다.
* 가변 객체는 전반적인 객체 패러다임의 오용이다.
* 가변 객체의 사용을 엄격하게 금지해야 한다.

### 식별자 가변성
* 불변 객체를 사용하면 객체를 map에 추가한 후에는 상태 변경이 불가능하기 때문에 식별자 가변성 문제가 발생하지 않는다.
* map의 키로 가변 객체를 사용할때 발생하는 문제

### 실패 원자성
* 완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능한 특성이다.
* 불변 객체를 사용하면 별도의 처리 없이도 원자성을 얻을 수 있다.

### 시간적 결합
* 불변 객체를 사용하면 시간적 결합을 제거할 수 있다.
* 가변 객체의 수가 많은 상황에서 가변 객체들을 처리하는 연산들의 순서를 일일이 기억해야 한다면 유지보수에 있어 어려움이 크다.
  * 객체를 생성하고 set하는 메서드가 있고 실행순서를 지키도록 해야하는게 쉽지 않다.
* 불변 객체는 인스턴스화와 초기화를 분리시킬 수 없이 항상 함께 실행되어야 한다.
* 불변성을 활용하면 코드 전반적으로 구문 사이에 존재하는 시간적인 결합을 제거할 수 있다.

### 부수효과 제거
* 불변객체를 사용하면 객체를 수정할 수 없기 때문에 사이드 이펙트가 발생하지 않는다.

### NULL 참조 없애기
* 가변 객체는 null을 가질수 있기 때문에 setter로 값을 할당하기 전까지는 값이 null이기 때문에 그런듯
* 커다란 클래스를 만드는 이유는 단순히 우리가 문제를 더 작은 부분으로 분해하기 위해 상속과 캡슐화를 어떻게 사용해야 하는 지를 모르기 때문이다.
* 일시적으로 설정하지 않은 프로퍼티를 사용해야하거나 프로퍼티의 초기화 여부(Null이거나 아니거나)에 따라 객체가 누구인지를 판단하는것은 형편없는 방법이다.
* NULL의 존재가 이런 형편없는 프랙티스를 따르도록 조장한다.
* 모든 객체를 불변으로 만듦ㄴ 객체 안에 NULL을 포함시키는 것이 애초에 불가능해진다.
  * 다시 말해서 작고, 견고하고, 응집도 높은 객체를 생성할 수 밖에 없도록 강제되기 때문에 결과적으로 유지보수하기에 훨씬 더 쉬운 객체를 만든다.

### 스레드 안전성
* 객체가 여러 스레드에서 동시에 사용될 수 있으며 그 결과를 예측가능하도록 유지할 수 있는 객체의 품질을 의미한다.
* 불변 객체는 실행 시점에 상태를 수정할 수 없게 금지함으로써 이 문제를 완벽하게 해결한다.

### 더 작고 더 단순한 객체
* 불변성은 단순성을 가지다.
* 객체가 더 단순해질 수록 응집도는 더 높아지고, 유지보수하기는 더 쉬워진다.
* 최고의 소프트웨어는 단순하다. 이해하고, 수정하고, 문서화하고, 지원하고, 리팩토링 하기 쉽다.
* 자바에서 허용 가능한 클래스의 최대 크기는 주석과 공백을 포함해서 250줄 정도라고 생각한다. 그 이상은 리팩토링 필요
* 클래스가 짧을수록 하는일이 무엇이고, 어디에서 실패하고 어떻게 리팩토링해야 하는 지를 더 쉽게 이해할 수 있다.
* 250줄 이하로 유지 할 수 있다면 좋은 소프트웨어 개발자이자 아키텍트라고 생각해도 무방하다.
<br> 이 보다 더 작게 만들면 미친넘 프로적션 코드 + 테스트 코드
* 불변 객체가 작은 이유는 생성자 안에서만 상태를 초기화할 수 있기 때문이다.
  * 생성자가 늘어나면 더 작은 클래스로 분리하게 될 것이기 때문이다.

## 문서를 작성하는 대신 테스트를 만드세요
* 읽기 쉬운 코드를 만들기 위해서는 코드를 읽게 될 사람이 주니어 프로그래머라고 가정해야 한다.
* 나쁜 프로그래머는 복잡한 코드를 짠다.
* 훌륭한 프로그래머는 단순한 코드를 짠다.
* 훌륭하고 유지보수 가능한 클래스는 문서화가 필요하지 않다. 좋은 클래스는 목적이 명확하고 작고 설계가 우아하다.
* 단위 테스트 역시 클래스의 일부로 취급해야 한다.
* 단위 테스트가 문서화다.
* 훌륭하고 깔끔한 단위 테스트를 만들기 위해서는 메인 코드만큼 단위 테스트에도 관심을 기울여라

## 모의 객체 대신 페이크 객체를 사용하세요
* 모킹은 나쁘 프랙티스이며 최후의 수단으로만 사용해야 한다.
* 페이크 클래스가 테스트를 올바르게 지원하도록 만들어야 한다.
* 모킹의 경우 테스트가 매우 장황해지고 이해하거나 리팩토링 하기가 어려워진다.
* 모킹은 가정을 사실로 전환시키기 때문에 단위 테스트를 유지보수하기 어렵게 만든다.
* 단위 클래스 안에서 클래스는 블랙박스 이기 때문에 클래스 내부에서 메서드가 호출되는 지는 정확히 알 수 없다.
* 불확실한 가정을 세우고 이 가정을 중심으로 전체 테스트를 구축하고 있는데 이 가정을 사실로 바꾼다. <br>
클래스의 작동 방식에 대해 우리가 알고 있는 내용이다라고 이야기 한다.
* 리팩토링의 안전망이라는 단위 테스트의 전체적인 목적에 어긋나기 때문에 이런 방식은 매우 좋지 않다.
* 클래스의 행동이 변경되면 단위 테스트가 실패하기 때문에 단위 테스트는 코드 리팩토링에 큰 도움이 된다. 참 양성
* 하지만 동시에 행동이 변경되지 않을 경우에는 실패해서는 안된다. 거짓 양성
* 클래스의 공개된 행동을 변경하지 않을 경우 단위 테스트는 실패해서는 안된다.
* 단위 테스트는 거짓 양성 지표를 제공해서는 안된다.
* 메서드를 시그니처를 변경했다고 해서 실패하게 된다.
* 테스트가 객체 내부의 구현 세부사항을 알면 테스트가 취약해지고 유지보수하기도 어려워진다. 이 문제의 근본 원인은 모킹이다.
* 객체와 의존 대상 사이의 상호작용 방식을 확인하거나 테스트해서는 안된다. 이것은 객체가 캡슐화해야 하는 정보다. 객체가 숨겨야 하는 비밀이다.
* 만드는 인터페이스부터 페이크 클래스들을 함께 제공해라 <br>
우리가 만드는 클래스의 모든 메서드가 인터페이스의 오퍼레이션을 구현하게 만들고 인터페이스와 함께 페이크 클래스를 제공해야 한다.
* 페이크 클래스는 인터페이스의 설계에 관해 더 깊이 고민하도록 해준다.
* 인터페이스를 설계하면서 페이크 클래스를 만들다 보면 필연적으로 인터페이스의 작성자 뿐만 아니라 사용자의 관점에서도 고민한다.
* 인터페이스를 다른 각도에서 바라보고, 테스트 리소르를 사용해서 사용자와 동일한 기능을 구현한다.

## 인터페이스를 짧게 유지하고 스마트를 사용하세요
* 인터페이스는 구현 클래스가 준수해야 하는 계약이다.
* 스마트 클래스는 아주 명확하고 공통적인 작업을 수행하는 많은 메서드들을 포함할 수 있다.
* 스마트 클래스를 인터페이스와 함께 제공해야 하는 또 다른 이유는 인터페이스를 구현하는 서로 다른 클래스 안에 동일한 기능을 반복해서 구현하고 싶지 않기 때문이다.
* 인터페이스가 커질수록 더 많은 것들을 요구하고 더 많은 문제가 발생한다. 단순히 작업략의 문제가 아니다. <br>
클래스의 응집도와 견고함이 심각하게 손상될 수도 있다.
* 스마트 클래스를 인터페이스와 함께 배포함으로써 공통 기능을 추출하고 코드 중복을 피할 수 있다.

~~~
public interface Exchange {
    float rate(String source, String target);
    final class Smart {
        private final Exchange origin;
        public float toUsd(String source) {
            return this.origin.rate(source, "USD");
        }
    }
}
~~~