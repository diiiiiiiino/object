## -er로 끝나는 이름을 사용하지 마세요
* 클래스는 객체의 팩토리다.
* 개념적으로 팩토리 패턴과 new 연산자는 동일하다.
* 필요할 때 객체를 꺼낼 수 있고, 더이상 필요하지 않은 객체를 반환할 수 있는 객체의 웨어하우스로 클래스를 바라봤으면 좋겠다.
* 클래스를 객체의 능동적인 관리자로 생각해야 한다.
* 객체를 살아있는 생명체로 생각한다면 클래스는 객체의 어머니라고 할 수 있다.
* 클래스를 객체의 템플릿으로 생각하면 안된다. 
  * 단순히 필요한 시점에 어딘가에서 복사되는 수동적이고 멍청한 코드 덩어리로 클래스를 격하시킨다.
* 클래스의 이름은 객체가 노출하고 있는 기능에 기반해서는 안된다.
* 클래스의 이름은 무엇을 하는지가 아니라 무엇인지에 기반해야한다.
* 객체는 그의 역량으로 특정지어져야 한다.
  * 어떤 사람인지는 키, 몸무게, 피부색과 같은 속성이 아니라, 내가 할 수 있는 일로 설명하는것처럼
* 객체는 연결장치가 아니라 대표자여야한다.
* 클래스의 이름이 -er로 끝난다면 이 클래스의 인스턴스는 실제로는 객체가 아니라 어떤 데이터를 다루는 절차들의 집합일 뿐이다.
* 클래스의 객체들이 무엇을 캡슐화할 것인지를 관찰하고 이 요소들에 붙일 적합한 이름을 찾아야 한다.
* 새로운 클래스에 이름을 붙일때는 무엇을 하는지가 아니라 무엇인지를 생각해야 한다

~~~
public class Cash {
    private int dollars;
    Cash(int dlr) {
        this.dollars = dlr;
    }
    
    public String usd() {
        return String.format("$ %d", this.dollars);
    }
}
~~~

## 생성자 하나를 주 생성자로 만드세요
* 클래스는 많은 수의 생성자와 적은 메서드가 포함되어야 한다.
* 2~3개의 메서드와 5~10개의 생성자를 포함하는 것이 적당하다. (과학적인 근거는 없다)
* 생성자의 개수가 더 많을수록 클래스는 더 개선되고, 사용자 입장에서 클래스를 더 편하게 사용할 수 있다.
* 메서드가 많아질수록 사용하기가 어려워지고 클래스의 초점이 흐려지고 단일 책임 원칙을 위반한다.
* 생성자가 많을수록 유연성이 향상된다.
* 생성자의 주된 작업은 제공된 인자를 사용해서 캡슐화하고 있는 프로퍼티를 초기화하는 일이다.
* 이런 초기화 로직은 단 하나의 생성자에만 위치시키고 주 생성자라고 부르기를 권장한다.
* 부 생성자라고 부르는 다른 생성자들이 주 생성자를 호출하도록 만들어라
* 주 생성자를 부 생성자들 뒤에 위치시켜라 유지보수성을 위해
* 하나의 주 생성자와 다수의 부 생성자 원칙의 핵심은 중복 코드를 방지하고 설계를 더 간결하게 만들기 때문에 유지보수성이 향상된다.
* 주 생성자에 유효성 검증을 넣으면 일일이 검증할 필요가 없다.

## 생성자에 코드를 넣지 마세요
* 객체 초기화에는 코드가 없어야하고 인자를 건드려서는 안된다. <br>
필요하다면 인자들을 다른 타입의 객체로 감싸거나 가공하지 않은 형식으로 캡슐화해야 한다.
* 아래 예제는 실제로 사용하는 시점까지 객체의 변환작업을 연기한다.
    ~~~
    public class Cash {
        private Number dollars;
        Cash(String dlr) {
            this(new StringAsInter(dlr));
        }
        
        Cash(Number dlr) {
            this.dollars = dlr;
        }
    }
    
    class StringAsInter implements Number {
        private String source;
        
        StringAsInter(String source) {
            this.source = source;
        }
        
        int intValue() {
            return Integer.parseInt(this.source);
        }
    }
    ~~~
* 생성자에서 직접 파싱을 수행하는 경우 최적화가 불가능하다 (객체를 사용하지 않을때 부터 이미 CPU는 파싱을 위해 시간을 소모한다.)
* 인자를 전달된 상태 그대로 캡슐화하고 나중에 요청이 있을때 파싱하도록 하면, 클래스의 사용자들이 파싱 시점을 자유롭게 결정할 수 있게 된다.
* 생성자에서 코드를 없애면 사용자가 쉽게 제어할 수 있는 투명한 객체를 만들 수 있으며 객체를 이해하고 재사용하기도 쉬워진다.
* 올바르게 설계된 객체지향 소프트웨를 살펴보면, 다음과 같은 형태의 코드를 자주 보게 된다 <br>
app을 생성하는 동안 app은 어떤 일도 처리하지 않는다. 내부에 포함된 모드 객체들을 생성하고, 이들이 동작할 수 있도록 주비만 시킨다.
  ~~~
  App app = new App(new Data(), new Screen());
  app.run();
  ~~~
