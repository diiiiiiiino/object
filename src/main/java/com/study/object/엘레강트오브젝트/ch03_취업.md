## 5개 이하의 public 메서드만 노출하세요
* 클래스의 크기를 정하는 기준으로 public 메서드의 개수를 사용하기를 권장한다.
* public 메서드가 많을수록 클래스도 커진다. 커질수록 유지보수성은 저하된다.
* public 메서드가 5개보다 적다면 만족스러운 수준이다. 5개보다 많다면 리팩토링할 필요가 있다.
* protected 메서드도 포함, private 메서드는 제외
* 작은 클래스가 유지보수 하기 쉽고 우아하고 좋다
* 클래스가 작으면 메서드와 프로퍼티가 더 가까이 있을 수 있기 때문에 응집도가 높아진다.
* 모든 메서드가 모든 프로퍼티와 상호작용할 수있게 클래스를 작게 만들어라

## 정적 메서드를 사용하지 마세요
* 정적 메서드는 소프트웨를 유지보수하기 어렵게 만든다.
* 객체지향 프로그래밍이란 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업이다.
* 정적 메서드는 조합이 불가능하다.
  * 정적 메서드를 포함하는 작은 객체들을 조합해서 더 큰 객체를 만들수가 없다.
  * 합성이라는 아이디어와 대치된다. 사용하면 안되는 이유중 하나.

### 객체 대 컴퓨터 사고
* 순차적인 사고 방식을 가리켜 컴퓨터 입장에서 생각하기라고 부른다.
* (def x (max 5 9))
  * 우리는 CPU에게 할 일을 지시하는 것이 아니라 정의한다.
  * x를 (max 5 9)아 바인딩한다.
  * 컴퓨터에게 최댓값을 계산하라고 요청하지 않는다.
  * 단순히 x는 이 두 수의 최댓값이다. 라고 이야기 한다.
  * 이 최댓값을 어떤 방식으로 계산하고 언제 계산하는 지는 우리의 통제 밖에 있다.
* 함수형, 논리형, 객체지향 프로그래밍이 절차적 프로그래밍과 차별화 되는 점이 바로 'is a'이다.
* 객체지향적으로 생각하게에서는 우리는 그저 누가 누구인지만 정의하고 객체들이 필요할 때 스스로 상호작용하도록 제어를 위임한다.
* 정적 메서드는 OOP와 아무런 상관이 없으며, 객체지향 언어의 문법을 이용해서 절차적인 코드를 작성하도록 부추긴다.

### 선언형 스타일 대 명령형 스타일
* 선언형 프로그래밍에서는 제어 흐름을 서술하지 않고 계산 로직을 표현한다.
* 명령형 프로그래밍에서는 프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술한다.
* 정적 메서드를 사용하면 이 메서드를 사용하기 위해서는 정적 메서드여야 한다.
* 정적 메서드는 호출 즉시 결과를 반환하기 때문에 명령형 스타일이다.
* 선언형은 우리가 직접 성능 최적화를 제어할 수 있다.
* CPU에게 결과가 실제로 필요한 시점과 위치를 결정하도록 위임하고, CPU는 요청이 있을 경우에만 계산을 실행한다.
* 명령형 방식보다 선언형 방식이 좋은 이유
  * 실행 관점에서 선언형 방식이 더 최적화되기 때문에 더 빠르다는 사실이다. 이것이 첫번째 이유다.
  * 다형성이 두번째 이유다, 생성자의 인자로 객체를 전달 할 수 있지만 정적 메서드를 전달하는 것을 불가능하다.
  * 표현력이 세번째 이유다, 알고리즘과 실행 대신 객체와 행동의 관점에서 사고하기 시작해야한다.
  * 응집도가 네번째 이유다, 책임지는 코드들이 한 곳에 뭉쳐 있기 때문에 실수로라도 분리할 수 없다, 명령형은 코드의 각 줄을 이어주는 접착제가 없어서 오류가 발생한 가능성이 높다.
* 정적 메서드를 사용하면 계속 증가한다.
* 유틸 클래스와 정적 메서드로 만들어진 라이브러리를 사용할때는 정적 메서드를 감싸는 클래스를 만들어서 고립시켜라

### 유틸리티 클래스
* 정적 메서드의 집합체가 끔찍한 안티 패턴이다 사용하지 말라.

### 싱글톤 패턴
* 끔찍한 안티 패턴이다.
* 싱글톤은 상태를 유지 하지 않는다. 목적이 아니다.
* 유틸 클래스와 구분하는 핵심적인 차이는 싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다는 것이다.
  * 싱글톤의 장점은 getInstance()와 함께 setInstance()를 추가할 수 있다는 점이다.
* 싱글톤은 전역 변수 그 이상도 그 이하도 아니다.
* OOP에는 전역 범위가 없다. 따라서 전역 변수를 위한 자리 역시 없다.
* 정적 메서드가 존재하기 때문에 등장한 안티패턴이다.

### 함수형 프로그래밍
* FP보다 OOP의 표현력이 더 뛰어나고 강력하다
* FP에서는 오직 함수만 사용할 수 있지만 OOP에서는 객체와 메서드를 조합할 수 있다.
* 자바의 람다 표현식은 객체지향 스타일로부터 우리르 멀어지게 만들기 떄문에 자바의 견고함을 약화시킨다.

### 조합 가능한 데코레이터
* if, for, switch, while과 같은 절차적인 문장이 포함되어 있어서는 안된다.

## 인자의 값으로 NULL을 절대 허용하지 마세요
* 인자의 값으로 NULL을 허용하면 mask == null과 같은 비교문을 사용할 수 밖에 없다.
* OOP에서는 존재하지 않는 인자 문제는 널 객체를 이용해서 해결해야 한다.
* 전달한 것이 없다면 비어있는 것처럼 행동하는 객체를 전달하면 된다.
* 전달한 인자가 객체인지 널인지를 확인하는 짐을 메서드 구현자에게 떠넘겨서는 안된다.
* 항상 객체를 전달하되 전달한 객체에게 무리한 요청을 한다면 응답을 거부하도록 객체를 구현해야 한다.
* 클라이언트가 여전이 널을 전달한다면 
  * 방어적인 방법으로 널을 체크한 후 예외를 던진다.
  * 널을 무시한다. NPE을 던져버린다, 어떤 대비도 하지 않는다.
    * 메서드 호출자는 자신이 실수했다는 사실을 인지하게 된다.
* 중요하지 않은 널 확인 로직으로 코드를 오염시켜서는 안된다.
* NPE는 잘못된 위치에 널이 전달됐다는 사실을 알려주는 올바른 지표다. <br>
더 똑똑하거나 더 유용한 정보를 제공하도록 만들 필요가 없다.
* 올바른 방식으로 설계된 소프트웨어에는 널 참조가 존재해서는 안된다.
* 방어적으로 대응하지 말고 무시함으로써 JVM에 정의된 표준방식으로 처리해야 한다.

## 충성스러우면서 불변이거나 아니면 상수이거나
* 메서드를 호출할 때마다 서로 다른 값이 반환되더라도 불변이다.
* 객체의 행동이나 메서드의 반환값은 중요하지 않다.
* 객체가 살아있는 동안 상태가 변하지 않는다는 사실이다.
* 객체란 실제 엔티티의 대표자다.
  * 실제라는 말은 객체의 가시성 범위 밖에 존재하는 모든 것을 의미한다.
* 불변 객체의 식별자는 객체의 상태와 완전히 동일하다.
* 가변 객체와 불변 객체의 중요한 차이는 불변 객체에는 식별자가 존재하지 않으며 절대로 상태를 변경할 수 없다는 점이다.
* 자바에서는 상태가 동일하더라도 서로 다른 객체라고 판단한다.
* 각 객체는 재정의할 수 있는 자신만의 유일한 식별자를 가진다.
* equals, hasCode 메서드 모두 객체를 투명하게 만들어서 자신만의 식별자를 가지지 않게 한다.
* 가변 객체의 상태는 변경이 가능하기 때문에 상태에 독립적인 식별자를 별도로 포함해야 한다.
* 불변 객체는 어떤 경우에도 항상 동일한 엔티티를 대표한다. 충성스럽다.
* 

## 절대 getter와 setter를 사용하지 마세요

### 객체 대 자료구조
* 자료구조는 글래스 박스 이지만, 객체는 블랙 박스다
* 자료구조는 수동적이지만 객체는 능동적이다.
* 발가벗겨진 데이터가 절차적인 프로그래밍 스타일을 사용하도록 부추긴다.

### 좋은 의도, 나쁜 결과
* 캡슐환 원칙을 위반하기 위해 설계되었다.
* 행동이 아닌 데이터를 표현할 뿐이다.
* 겉으로는 메서드처럼 보이지만, 실제로는 우리가 데이터에 직접 접근하고 있다.

### 접두사에 관한 모든 것
* getDollars()는 데이터 중에 dollars를 찾은 후 반환하세요 라고 이야기 하고
* dollars()는 얼마나 많은 달러가 필요한가요라고 묻는것이다.
  * 객체를 데이터의 저장소로 취급하지 않고 객체를 존중한다.

## 부 생성자 밖에서는 new를 사용하지 마세요
* 필요한 의존성 전체를 생성자를 통해 전달받아야 한다.
* 생성자 내부에서 new 연산자를 통해 객체를 생성하면 안된다. 테스트도 어렵기 때문에
* 부 생성자를 제외한 어떤 곳에서도 new를 사용하지 마라
  * 객체들은 상호간에 충분히 분리되고 테스트 용이성과 유지보수성을 크게 향상시킬 수 있따.
* 이 규칙이 의존성 주입과 제어 역전에 관해 알아야 하는 전부다

## 인트로스펙션과 캐스팅을 피하세요
* 타입에 따라 객체를 차별하기 때문에 OOP의 기본 사상을 심각하게 훼손 시킨다.
* 동일한 기준을 객체에게 적용할 수 있도록 해야한다.


